{"title":"Model Evaluation and Refinement","markdown":{"headingText":"Model Evaluation and Refinement","containsRefs":false,"markdown":"\n## Training and Testing\n\nLet's first prepare our environment: \n\n```{python}\n#load libs\nimport pandas as pd\nimport numpy as np\n\n#libs for plotting\nfrom ipywidgets import interact, interactive, fixed, interact_manual\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n#for model training\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.model_selection import cross_val_predict\nfrom sklearn.preprocessing import PolynomialFeatures\n```\n\n```{python}\n#load data\ndf = pd.read_csv(\"../data/module_5_auto.csv\")\n\n#only use numeric data\ndf=df._get_numeric_data()\ndf.head()\n```\n\n```{python}\n#define functions for plotting\ndef DistributionPlot(RedFunction, BlueFunction, RedName, BlueName, Title):\n    width = 8\n    height = 6\n    plt.figure(figsize=(width, height))\n\n    ax1 = sns.distplot(RedFunction, hist=False, color=\"r\", label=RedName)\n    ax2 = sns.distplot(BlueFunction, hist=False, color=\"b\", label=BlueName, ax=ax1)\n\n    plt.title(Title)\n    plt.xlabel('Price (in dollars)')\n    plt.ylabel('Proportion of Cars')\n\n    plt.show()\n    plt.close()\n```\n\n\n```{python}\n#| warning: false\n\ndef PollyPlot(xtrain, xtest, y_train, y_test, lr,poly_transform):\n    width = 8\n    height = 6\n    plt.figure(figsize=(width, height))\n    \n    #training data \n    #testing data \n    # lr:  linear regression object \n    #poly_transform:  polynomial transformation object \n    xmax=max([xtrain.values.max(), xtest.values.max()])\n    xmin=min([xtrain.values.min(), xtest.values.min()])\n    x=np.arange(xmin, xmax, 0.1)\n\n    plt.plot(xtrain, y_train, 'ro', label='Training Data')\n    plt.plot(xtest, y_test, 'go', label='Test Data')\n    plt.plot(x, lr.predict(poly_transform.fit_transform(x.reshape(-1, 1))), label='Predicted Function')\n    plt.ylim([-10000, 60000])\n    plt.ylabel('Price')\n    plt.legend()\n```\n```{python}\ndef f(order, test_data):\n    x_train, x_test, y_train, y_test = train_test_split(x_data, y_data, test_size=test_data, random_state=0)\n    pr = PolynomialFeatures(degree=order)\n    x_train_pr = pr.fit_transform(x_train[['horsepower']])\n    x_test_pr = pr.fit_transform(x_test[['horsepower']])\n    poly = LinearRegression()\n    poly.fit(x_train_pr,y_train)\n    PollyPlot(x_train[['horsepower']], x_test[['horsepower']], y_train,y_test, poly, pr)\n```\n\n\nAn important step in testing your model is to split your data into training and testing data. We will place the target data price in a separate dataframe y_data and Drop price data in dataframe x_data:\n\n```{python}\n#prepare the df\ny_data = df['price']\nx_data=df.drop('price',axis=1)\n```\n\nNow, we randomly split our data into training and testing data using the function train_test_split\n\n```{python}\nfrom sklearn.model_selection import train_test_split\n\n#split data\nx_train, x_test, y_train, y_test = train_test_split(x_data, y_data, test_size=0.10, random_state=1)\n\n#see if this worked\nprint(\"number of test samples :\", x_test.shape[0])\nprint(\"number of training samples:\",x_train.shape[0])\n```\n\nWe see that the test_size parameter sets the proportion of data that is split into the testing set. In the above, the testing set is 10% of the total dataset.\n\nNow, lets prepare the model\"\n\n```{python}\n#load libs\nfrom sklearn.linear_model import LinearRegression\n\n#create regression object\nlre = LinearRegression()\n\n#fit the model using the feature `horsepower`\nlre.fit(x_train[['horsepower']], y_train)\n\n#calculate the R2 on the test data\nprint(lre.score(x_test[['horsepower']], y_test))\n\n#compare the R2 of the training data\nprint(lre.score(x_train[['horsepower']], y_train))\n```\n\nWe can see the R^2 is much smaller using the test data compared to the training data.\n\n\n## Model evaluation\n\nModel evaluation tells us how our model performs in the real world. \n\n- In-sample evaluation tells us how well our model fits the data already given to train it\n- However, the problem is that it does not give us an estimate of how well the train model can predict new data\n- The solution is to split our data up, use the in-sample data or training data to train the model. The rest of the data, called Test Data, is used as out-of-sample data. This data is then used to approximate, how the model performs in the real world\n- When we split a dataset, usually the larger portion of data is used for training and a smaller part is used for testing\n-  When we have completed testing our model, we should use all the data to train the model\n\n\n### Generalization performance\n\n- Generalization error is a measure how well our data does at predicting previously unseen data\n- The error we obtain using our testing data is an approximation of this error\n- Using a lot of data for training,gives us an accurate means of determining how well our model will perform in the real world. But the precision of the performance will be low\n- If we use fewer data points to train the model and more to test the model, the accuracy of the generalization performance will be less, but the model will have good precision.\n\nTo overcome this problem, we use cross-validation.\n\n\n\n### Cross validation\n\n- One of the most common out of sample evaluation metrics is cross-validation\n- More effective use of data, as each observation is used for both training and testing\n- In this method, the dataset is split into K equal groups. Each group is referred to as a fold.\n- Some of the folds can be used as a training set which we use to train the model and the remaining parts are used as a test set, which we use to test the model. For example, we can use three folds for training, then use one fold for testing\n- This is repeated until each partition is used for both training and testing \n- At the end, we use the average results as the estimate of out-of-sample error\n\n\n```{python}\n#load lib\nfrom sklearn.model_selection import cross_val_score\n```\n\nFor cross-validation we  input the object, the feature (\"horsepower\"), and the target data (y_data). The parameter 'cv' determines the number of folds. In this case, it is 4.\n\n\n```{python}\n#cross validate\nRcross = cross_val_score(lre, x_data[['horsepower']], y_data, cv = 4)\n```\n\nThe default scoring is R^2. Each element in the array has the average R^2 value for the fold:\n\n```{python}\n#view data\nRcross\n```\n\nWe can calculate the average and standard deviation of our estimate:\n\n```{python}\nprint(\"The mean of the folds are\", Rcross.mean(), \"and the standard deviation is\" , Rcross.std())\n```\n\nWe can use negative squared error as a score by setting the parameter 'scoring' metric to 'neg_mean_squared_error'.\n\n\n```{python}\n-1 * cross_val_score(lre,x_data[['horsepower']], y_data,cv=4,scoring='neg_mean_squared_error')\n```\n\nYou can also use the function 'cross_val_predict' to predict the output. The function splits up the data into the specified number of folds, with one fold for testing and the other folds are used for training. First, import the function:\n\nWe input the object, the feature \"horsepower\", and the target data y_data. The parameter 'cv' determines the number of folds. In this case, it is 4. We can produce an output:\n\n```{python}\n#load lib\nfrom sklearn.model_selection import cross_val_predict\n\n#predict the output\nyhat = cross_val_predict(lre,x_data[['horsepower']], y_data,cv=4)\nyhat[0:5]\n```\n\n\n\n## Overfitting, Underfitting and Model Selection\n\nIt turns out that the test data, sometimes referred to as the \"out of sample data\", is a much better measure of how well your model performs in the real world. One reason for this is overfitting.\n\nLet's go over some examples. It turns out these differences are more apparent in Multiple Linear Regression and Polynomial Regression so we will explore overfitting in that context.\n\nIn this section, we will discuss how to pick the best polynomial order and problems that arise when selecting the wrong order polynomial.\n\n- **Underfitting**: the model is too simple to fit the data\n- **Overfitting** : the estimated function oscillates but doesn't track the function\n\nFor Model selection we can compare the mean square error and the polynomial order:\n\n- The training error decreases with the order of the polynomial\n- The test error is a better means to estimate the error of the polynomial. The error decreases 'till the best order of the polynomial is determined. Then the error begins to increase. We select the order that minimizes the test error.Anything on the left would be considered underfitting. Anything on the right is overfitting\n- If we select the best order of the polynomial, we will still have some errors, i.e. due to random noise or our polynomial assumption may be wrong \n\n\nLet's create Multiple Linear Regression objects and train the model using 'horsepower', 'curb-weight', 'engine-size' and 'highway-mpg' as features.\n\n```{python}\nlr = LinearRegression()\nlr.fit(x_train[['horsepower', 'curb-weight', 'engine-size', 'highway-mpg']], y_train)\n```\n\nNext, we run the prediction using training data:\n\n```{python}\nyhat_train = lr.predict(x_train[['horsepower', 'curb-weight', 'engine-size', 'highway-mpg']])\nyhat_train[0:5]\n```\n\nNext, we run the prediction using test data:\n\n```{python}\nyhat_test = lr.predict(x_test[['horsepower', 'curb-weight', 'engine-size', 'highway-mpg']])\nyhat_test[0:5]\n```\n\nLet's perform some model evaluation using our training and testing data separately. First, we import the seaborn and matplotlib library for plotting.\n\n```{python}\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n```\n\nLet's examine the distribution of the predicted values of the training data.\n\n```{python}\nTitle = 'Distribution  Plot of  Predicted Value Using Training Data vs Training Data Distribution'\nDistributionPlot(y_train, yhat_train, \"Actual Values (Train)\", \"Predicted Values (Train)\", Title)\n```\n\n\nSo far, the model seems to be doing well in learning from the training dataset. But what happens when the model encounters new data from the testing dataset? When the model generates new values from the test data, we see the distribution of the predicted values is much different from the actual target values.\n\n```{python}\nTitle='Distribution  Plot of  Predicted Value Using Test Data vs Data Distribution of Test Data'\nDistributionPlot(y_test,yhat_test,\"Actual Values (Test)\",\"Predicted Values (Test)\",Title)\n```\n\nComparing Figure 1 and Figure 2, it is evident that the distribution of the test data in Figure 1 is much better at fitting the data. This difference in Figure 2 is apparent in the range of 5000 to 15,000. This is where the shape of the distribution is extremely different. Let's see if polynomial regression also exhibits a drop in the prediction accuracy when analysing the test dataset.\n\n\n### Overfitting\n\nOverfitting occurs when the model fits the noise, but not the underlying process. Therefore, when testing your model using the test set, your model does not perform as well since it is modelling noise, not the underlying process that generated the relationship. Let's create a degree 5 polynomial model.\n\nLet's use 55 percent of the data for training and the rest for testing:\n\n```{python}\n#load lib\nfrom sklearn.preprocessing import PolynomialFeatures\n\n#use 55 percent of the data for training and the rest for testing\nx_train, x_test, y_train, y_test = train_test_split(x_data, y_data, test_size=0.45, random_state=0)\n\n#perform a degree 5 polynomial transformation on the feature 'horsepower'\npr = PolynomialFeatures(degree=5)\nx_train_pr = pr.fit_transform(x_train[['horsepower']])\nx_test_pr = pr.fit_transform(x_test[['horsepower']])\npr\n```\n\nNow, let's create a Linear Regression model \"poly\" and train it.\n\n```{python}\npoly = LinearRegression()\npoly.fit(x_train_pr, y_train)\n```\n\nWe can see the output of our model using the method \"predict.\" We assign the values to \"yhat\".\n\n```{python}\nyhat = poly.predict(x_test_pr)\nyhat[0:5]\n```\n\n\nLet's take the first five predicted values and compare it to the actual targets.\n\n```{python}\nprint(\"Predicted values:\", yhat[0:4])\nprint(\"True values:\", y_test[0:4].values)\n```\n\nWe will use the function \"PollyPlot\" that we defined at the beginning of the lab to display the training data, testing data, and the predicted function.\n\n```{python}\nPollyPlot(x_train[['horsepower']], x_test[['horsepower']], y_train, y_test, poly,pr)\n```\n\nFigure 3: A polynomial regression model where red dots represent training data, green dots represent test data, and the blue line represents the model prediction.\n\nWe see that the estimated function appears to track the data but around 200 horsepower, the function begins to diverge from the data points.\n\nR^2 of the training data:\n\n```{python}\npoly.score(x_train_pr, y_train)\n```\n\n\nR^2 of the test data:\n\n```{python}\npoly.score(x_test_pr, y_test)\n```\n\nWe see the R^2 for the training data is 0.5567 while the R^2 on the test data was -29.87. The lower the R^2, the worse the model. A negative R^2 is a sign of overfitting.\n\nLet's see how the R^2 changes on the test data for different order polynomials and then plot the results:\n\n```{python}\nRsqu_test = []\n\norder = [1, 2, 3, 4]\nfor n in order:\n    pr = PolynomialFeatures(degree=n)\n    \n    x_train_pr = pr.fit_transform(x_train[['horsepower']])\n    \n    x_test_pr = pr.fit_transform(x_test[['horsepower']])    \n    \n    lr.fit(x_train_pr, y_train)\n    \n    Rsqu_test.append(lr.score(x_test_pr, y_test))\n\nplt.plot(order, Rsqu_test)\nplt.xlabel('order')\nplt.ylabel('R^2')\nplt.title('R^2 Using Test Data')\nplt.text(3, 0.75, 'Maximum R^2 ')    \nplt.show()\nplt.close()\n\n```\n\nWe see the R^2 gradually increases until an order three polynomial is used. Then, the R^2 dramatically decreases at an order four polynomial.\n\nThe following interface allows you to experiment with different polynomial orders and different amounts of data.\n\n```{python}\ninteract(f, order=(0, 6, 1), test_data=(0.05, 0.95, 0.05))\n```\n\n\n\n## Ridge regression\n\nRidge regression is a regression that is employed in a Multiple regression model when Multicollinearity occurs. Multicollinearity is when there is a strong relationship among the independent variables. Ridge regression is very common with polynomial regression and is used to regularize and reduce the standard errors to avoid over-fitting a regression model.\n\nLet's perform a degree two polynomial transformation on our data.\n\n```{python}\npr=PolynomialFeatures(degree=2)\nx_train_pr=pr.fit_transform(x_train[['horsepower', 'curb-weight', 'engine-size', 'highway-mpg','normalized-losses','symboling']])\nx_test_pr=pr.fit_transform(x_test[['horsepower', 'curb-weight', 'engine-size', 'highway-mpg','normalized-losses','symboling']])\n```\n\n```{python}\n#load lib\nfrom sklearn.linear_model import Ridge\n\n#create a ridge regression object\nRigeModel=Ridge(alpha=1)\n\n#fit the model using the method fit.\nRigeModel.fit(x_train_pr, y_train)\n\n#obtain a prediction\nyhat = RigeModel.predict(x_test_pr)\n\n#Let's compare the first five predicted samples to our test set:\nprint('predicted:', yhat[0:4])\nprint('test set :', y_test[0:4].values)\n```\n\nWe select the value of alpha that minimizes the test error. To do so, we can use a for loop. We have also created a progress bar to see how many iterations we have completed so far.\n\n```{python}\n#| warning: false\n#| error: false\n\nfrom tqdm import tqdm\n\nRsqu_test = []\nRsqu_train = []\ndummy1 = []\nAlpha = 10 * np.array(range(0,1000))\npbar = tqdm(Alpha)\n\nfor alpha in pbar:\n    RigeModel = Ridge(alpha=alpha) \n    RigeModel.fit(x_train_pr, y_train)\n    test_score, train_score = RigeModel.score(x_test_pr, y_test), RigeModel.score(x_train_pr, y_train)\n    \n    pbar.set_postfix({\"Test Score\": test_score, \"Train Score\": train_score})\n\n    Rsqu_test.append(test_score)\n    Rsqu_train.append(train_score)\n```\n\nWe can plot out the value of R^2 for different alphas:\n\n```{python}\nwidth = 5\nheight = 8\nplt.figure(figsize=(width, height))\n\nplt.plot(Alpha,Rsqu_test, label='validation data  ')\nplt.plot(Alpha,Rsqu_train, 'r', label='training Data ')\nplt.xlabel('alpha')\nplt.ylabel('R^2')\nplt.legend()\n\nplt.show()\nplt.close()\n```\n\nFigure 4: The blue line represents the R^2 of the validation data, and the red line represents the R^2 of the training data. The x-axis represents the different values of Alpha.\n\nHere the model is built and tested on the same data, so the training and test data are the same.\n\nThe red line in Figure 4 represents the R^2 of the training data. As alpha increases the R^2 decreases. Therefore, as alpha increases, the model performs worse on the training data\n\nThe blue line represents the R^2 on the validation data. As the value for alpha increases, the R^2 increases and converges at a point.\n\n\n\n\n## Grid Search\n\nGrid Search allows us to scan through multiple free parameters with few lines of code.\n\nParameters like the alpha term in Ridge regression are not part of the fitting or training process. These values are called **hyperparameters**.\n\nScikit-learn has a means of automatically iterating over these hyperparameters using cross-validation. This method is called **Grid Search**. Grid Search takes the model or objects you would like to train and different values of the hyperparameters. It then calculates the mean square error or R-squared for various hyperparameter values, allowing you to choose the best values based on the set of parameters that minimize the error.\n\nTo select the hyperparameter, we split our dataset into three parts:\n\n- The **training set** in which we train the model for different hyperparameters.\n- We select the hyperparameter that minimizes the mean squared error or maximizes the R-squared on the **validation set**. \n- Finally, we test our model set using the **test set**\n\n```{python}\n#load lib\nfrom sklearn.model_selection import GridSearchCV\n\n#create a dic of the parameter values\nparameters1= [{'alpha': [0.001,0.1,1, 10, 100, 1000, 10000, 100000, 100000]}]\nparameters1\n```\n\n\n```{python}\n#lCreate a Ridge regression object:\nRR=Ridge()\nRR\n```\n\n\n```{python}\n#Create a ridge grid search object:\nGrid1 = GridSearchCV(RR, parameters1,cv=4)\n```\n\n\n```{python}\n#fit the model\nGrid1.fit(x_data[['horsepower', 'curb-weight', 'engine-size', 'highway-mpg']], y_data)\n```\n\nThe object finds the best parameter values on the validation data. We can obtain the estimator with the best parameters and assign it to the variable BestRR as follows:\n\n\n```{python}\nBestRR=Grid1.best_estimator_\nBestRR\n```\n\nWe now test our model on the test data:\n\n```{python}\nBestRR.score(x_test[['horsepower', 'curb-weight', 'engine-size', 'highway-mpg']], y_test)\n```"},"formats":{"html":{"execute":{"fig-width":3.5,"fig-height":3.5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"5_model_eval_and_refinement.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.251","bibliography":["../references.bib"],"space-before-code-block":"10pt","space-after-code-block":"8pt","linespacing":"22pt plus2pt","frontmatter-linespacing":"17pt plus1pt minus1pt","title-size":"22pt","title-size-linespacing":"28pt","gap-before-crest":"25mm","gap-after-crest":"25mm","execute-dir":"file","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":3.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"pdflatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","highlight-style":"github","output-file":"5_model_eval_and_refinement.pdf"},"language":{},"metadata":{"block-headings":true,"bibliography":["../references.bib"],"space-before-code-block":"10pt","space-after-code-block":"8pt","linespacing":"22pt plus2pt","frontmatter-linespacing":"17pt plus1pt minus1pt","title-size":"22pt","title-size-linespacing":"28pt","gap-before-crest":"25mm","gap-after-crest":"25mm","execute-dir":"file","documentclass":"scrreprt","geometry":["heightrounded"],"pandoc_args":"--listings","header-includes":["\\usepackage{fvextra} \\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}"],"colorlinks":true,"code-block-bg":"D3D3D3"},"extensions":{"book":{}}}}}