[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data analysis with python",
    "section": "",
    "text": "In this module, you will learn about data visualization and some of the best practices to keep in mind when creating plots and visuals. You will also learn about the history and the architecture of Matplotlib and learn about basic plotting with Matplotlib. In addition, you will learn about the dataset on immigration to Canada, which will be used extensively throughout the course. Finally, you will briefly learn how to read csv files into a pandas dataframe and process and manipulate the data in the dataframe, and how to generate line plots using Matplotlib.\nLearning Objectives\n\nDescribe the importance of data visualization\nRelate the history of Matplotlib and its architecture\nApply Matplotlib to create plots using Jupyter notebooks\nRead csv files into a Pandas DataFrame; process and manipulate the data in the - DataFrame; and generate line plots using Matplotlib"
  },
  {
    "objectID": "code/1_intro.html",
    "href": "code/1_intro.html",
    "title": "2  Introduction into data vis",
    "section": "",
    "text": "Dataset Source: International migration flows to and from selected countries - The 2015 revision.\nThe dataset contains annual data on the flows of international immigrants as recorded by the countries of destination. The data presents both inflows and outflows according to the place of birth, citizenship or place of previous / next residence both for foreigners and nationals. The current version presents data pertaining to 45 countries.\nIn this lab, we will focus on the Canadian immigration data.\nThe Canada Immigration dataset can be fetched from here.\n\n\n\n#load libs\nimport pandas as pd\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\n\n#load data\ndf_can = pd.read_excel(\"../data/Canada.xlsx\", sheet_name='Canada by Citizenship',skiprows=range(20), skipfooter=2)\n\n#check data\ndf_can.head()\n\n\n\n\n\n  \n    \n      \n      Type\n      Coverage\n      OdName\n      AREA\n      AreaName\n      REG\n      RegName\n      DEV\n      DevName\n      1980\n      ...\n      2004\n      2005\n      2006\n      2007\n      2008\n      2009\n      2010\n      2011\n      2012\n      2013\n    \n  \n  \n    \n      0\n      Immigrants\n      Foreigners\n      Afghanistan\n      935\n      Asia\n      5501\n      Southern Asia\n      902\n      Developing regions\n      16\n      ...\n      2978\n      3436\n      3009\n      2652\n      2111\n      1746\n      1758\n      2203\n      2635\n      2004\n    \n    \n      1\n      Immigrants\n      Foreigners\n      Albania\n      908\n      Europe\n      925\n      Southern Europe\n      901\n      Developed regions\n      1\n      ...\n      1450\n      1223\n      856\n      702\n      560\n      716\n      561\n      539\n      620\n      603\n    \n    \n      2\n      Immigrants\n      Foreigners\n      Algeria\n      903\n      Africa\n      912\n      Northern Africa\n      902\n      Developing regions\n      80\n      ...\n      3616\n      3626\n      4807\n      3623\n      4005\n      5393\n      4752\n      4325\n      3774\n      4331\n    \n    \n      3\n      Immigrants\n      Foreigners\n      American Samoa\n      909\n      Oceania\n      957\n      Polynesia\n      902\n      Developing regions\n      0\n      ...\n      0\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n    \n    \n      4\n      Immigrants\n      Foreigners\n      Andorra\n      908\n      Europe\n      925\n      Southern Europe\n      901\n      Developed regions\n      0\n      ...\n      0\n      0\n      1\n      1\n      0\n      0\n      0\n      0\n      1\n      1\n    \n  \n\n5 rows × 43 columns\n\n\n\nLet’s first inspect the data frame, to get a feel for what we have:\n\n#get a summary\ndf_can.info(verbose = False)\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 195 entries, 0 to 194\nColumns: 43 entries, Type to 2013\ndtypes: int64(37), object(6)\nmemory usage: 65.6+ KB\n\n\n\n#get column headers\ndf_can.columns\n\nIndex([    'Type', 'Coverage',   'OdName',     'AREA', 'AreaName',      'REG',\n        'RegName',      'DEV',  'DevName',       1980,       1981,       1982,\n             1983,       1984,       1985,       1986,       1987,       1988,\n             1989,       1990,       1991,       1992,       1993,       1994,\n             1995,       1996,       1997,       1998,       1999,       2000,\n             2001,       2002,       2003,       2004,       2005,       2006,\n             2007,       2008,       2009,       2010,       2011,       2012,\n             2013],\n      dtype='object')\n\n\n\n#view the dimensions of our data\ndf_can.shape\n\n(195, 43)\n\n\nNow, lets clean the data and remove some unnecessary columns using drop()\n\ndf_can.drop(['AREA','REG','DEV','Type','Coverage'], axis = 1, inplace = True)\ndf_can.head()\n\n\n\n\n\n  \n    \n      \n      OdName\n      AreaName\n      RegName\n      DevName\n      1980\n      1981\n      1982\n      1983\n      1984\n      1985\n      ...\n      2004\n      2005\n      2006\n      2007\n      2008\n      2009\n      2010\n      2011\n      2012\n      2013\n    \n  \n  \n    \n      0\n      Afghanistan\n      Asia\n      Southern Asia\n      Developing regions\n      16\n      39\n      39\n      47\n      71\n      340\n      ...\n      2978\n      3436\n      3009\n      2652\n      2111\n      1746\n      1758\n      2203\n      2635\n      2004\n    \n    \n      1\n      Albania\n      Europe\n      Southern Europe\n      Developed regions\n      1\n      0\n      0\n      0\n      0\n      0\n      ...\n      1450\n      1223\n      856\n      702\n      560\n      716\n      561\n      539\n      620\n      603\n    \n    \n      2\n      Algeria\n      Africa\n      Northern Africa\n      Developing regions\n      80\n      67\n      71\n      69\n      63\n      44\n      ...\n      3616\n      3626\n      4807\n      3623\n      4005\n      5393\n      4752\n      4325\n      3774\n      4331\n    \n    \n      3\n      American Samoa\n      Oceania\n      Polynesia\n      Developing regions\n      0\n      1\n      0\n      0\n      0\n      0\n      ...\n      0\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n    \n    \n      4\n      Andorra\n      Europe\n      Southern Europe\n      Developed regions\n      0\n      0\n      0\n      0\n      0\n      0\n      ...\n      0\n      0\n      1\n      1\n      0\n      0\n      0\n      0\n      1\n      1\n    \n  \n\n5 rows × 38 columns\n\n\n\nLet’s rename the columns so that they make sense. We can use rename() method by passing in a dictionary of old and new names as follows:\n\ndf_can.rename(columns = {'OdName':'Country', 'AreaName':'Continent', 'RegName':'Region'}, inplace = True)\n\ndf_can.columns\n\nIndex([  'Country', 'Continent',    'Region',   'DevName',        1980,\n              1981,        1982,        1983,        1984,        1985,\n              1986,        1987,        1988,        1989,        1990,\n              1991,        1992,        1993,        1994,        1995,\n              1996,        1997,        1998,        1999,        2000,\n              2001,        2002,        2003,        2004,        2005,\n              2006,        2007,        2008,        2009,        2010,\n              2011,        2012,        2013],\n      dtype='object')\n\n\nWe will also add a ‘Total’ column that sums up the total immigrants by country over the entire period 1980 - 2013, as follows\n\ndf_can['Total'] = df_can.sum(axis = 1)\ndf_can.head()\n\n\n\n\n\n  \n    \n      \n      Country\n      Continent\n      Region\n      DevName\n      1980\n      1981\n      1982\n      1983\n      1984\n      1985\n      ...\n      2005\n      2006\n      2007\n      2008\n      2009\n      2010\n      2011\n      2012\n      2013\n      Total\n    \n  \n  \n    \n      0\n      Afghanistan\n      Asia\n      Southern Asia\n      Developing regions\n      16\n      39\n      39\n      47\n      71\n      340\n      ...\n      3436\n      3009\n      2652\n      2111\n      1746\n      1758\n      2203\n      2635\n      2004\n      58639\n    \n    \n      1\n      Albania\n      Europe\n      Southern Europe\n      Developed regions\n      1\n      0\n      0\n      0\n      0\n      0\n      ...\n      1223\n      856\n      702\n      560\n      716\n      561\n      539\n      620\n      603\n      15699\n    \n    \n      2\n      Algeria\n      Africa\n      Northern Africa\n      Developing regions\n      80\n      67\n      71\n      69\n      63\n      44\n      ...\n      3626\n      4807\n      3623\n      4005\n      5393\n      4752\n      4325\n      3774\n      4331\n      69439\n    \n    \n      3\n      American Samoa\n      Oceania\n      Polynesia\n      Developing regions\n      0\n      1\n      0\n      0\n      0\n      0\n      ...\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      6\n    \n    \n      4\n      Andorra\n      Europe\n      Southern Europe\n      Developed regions\n      0\n      0\n      0\n      0\n      0\n      0\n      ...\n      0\n      1\n      1\n      0\n      0\n      0\n      0\n      1\n      1\n      15\n    \n  \n\n5 rows × 39 columns\n\n\n\nCheck for null objects:\n\ndf_can.isnull().sum()\n\nCountry      0\nContinent    0\nRegion       0\nDevName      0\n1980         0\n1981         0\n1982         0\n1983         0\n1984         0\n1985         0\n1986         0\n1987         0\n1988         0\n1989         0\n1990         0\n1991         0\n1992         0\n1993         0\n1994         0\n1995         0\n1996         0\n1997         0\n1998         0\n1999         0\n2000         0\n2001         0\n2002         0\n2003         0\n2004         0\n2005         0\n2006         0\n2007         0\n2008         0\n2009         0\n2010         0\n2011         0\n2012         0\n2013         0\nTotal        0\ndtype: int64\n\n\nLet’s view a quick summary of each column in our dataframe using the describe() method.\n\ndf_can.describe()\n\n\n\n\n\n  \n    \n      \n      1980\n      1981\n      1982\n      1983\n      1984\n      1985\n      1986\n      1987\n      1988\n      1989\n      ...\n      2005\n      2006\n      2007\n      2008\n      2009\n      2010\n      2011\n      2012\n      2013\n      Total\n    \n  \n  \n    \n      count\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      ...\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n      195.000000\n    \n    \n      mean\n      508.394872\n      566.989744\n      534.723077\n      387.435897\n      376.497436\n      358.861538\n      441.271795\n      691.133333\n      714.389744\n      843.241026\n      ...\n      1320.292308\n      1266.958974\n      1191.820513\n      1246.394872\n      1275.733333\n      1420.287179\n      1262.533333\n      1313.958974\n      1320.702564\n      32867.451282\n    \n    \n      std\n      1949.588546\n      2152.643752\n      1866.997511\n      1204.333597\n      1198.246371\n      1079.309600\n      1225.576630\n      2109.205607\n      2443.606788\n      2555.048874\n      ...\n      4425.957828\n      3926.717747\n      3443.542409\n      3694.573544\n      3829.630424\n      4462.946328\n      4030.084313\n      4247.555161\n      4237.951988\n      91785.498686\n    \n    \n      min\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      ...\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      1.000000\n    \n    \n      25%\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.500000\n      0.500000\n      1.000000\n      1.000000\n      ...\n      28.500000\n      25.000000\n      31.000000\n      31.000000\n      36.000000\n      40.500000\n      37.500000\n      42.500000\n      45.000000\n      952.000000\n    \n    \n      50%\n      13.000000\n      10.000000\n      11.000000\n      12.000000\n      13.000000\n      17.000000\n      18.000000\n      26.000000\n      34.000000\n      44.000000\n      ...\n      210.000000\n      218.000000\n      198.000000\n      205.000000\n      214.000000\n      211.000000\n      179.000000\n      233.000000\n      213.000000\n      5018.000000\n    \n    \n      75%\n      251.500000\n      295.500000\n      275.000000\n      173.000000\n      181.000000\n      197.000000\n      254.000000\n      434.000000\n      409.000000\n      508.500000\n      ...\n      832.000000\n      842.000000\n      899.000000\n      934.500000\n      888.000000\n      932.000000\n      772.000000\n      783.000000\n      796.000000\n      22239.500000\n    \n    \n      max\n      22045.000000\n      24796.000000\n      20620.000000\n      10015.000000\n      10170.000000\n      9564.000000\n      9470.000000\n      21337.000000\n      27359.000000\n      23795.000000\n      ...\n      42584.000000\n      33848.000000\n      28742.000000\n      30037.000000\n      29622.000000\n      38617.000000\n      36765.000000\n      34315.000000\n      34129.000000\n      691904.000000\n    \n  \n\n8 rows × 35 columns\n\n\n\nBefore we proceed, notice that the default index of the dataset is a numeric range from 0 to 194. This makes it very difficult to do a query by a specific country. For example to search for data on Japan, we need to know the corresponding index value.\nThis can be fixed very easily by setting the ‘Country’ column as the index using set_index() method.\nTip: The opposite of set is reset. So to reset the index, we can use df_can.reset_index()\n\ndf_can.set_index('Country', inplace = True)\ndf_can.head()\n\n\n\n\n\n  \n    \n      \n      Continent\n      Region\n      DevName\n      1980\n      1981\n      1982\n      1983\n      1984\n      1985\n      1986\n      ...\n      2005\n      2006\n      2007\n      2008\n      2009\n      2010\n      2011\n      2012\n      2013\n      Total\n    \n    \n      Country\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Afghanistan\n      Asia\n      Southern Asia\n      Developing regions\n      16\n      39\n      39\n      47\n      71\n      340\n      496\n      ...\n      3436\n      3009\n      2652\n      2111\n      1746\n      1758\n      2203\n      2635\n      2004\n      58639\n    \n    \n      Albania\n      Europe\n      Southern Europe\n      Developed regions\n      1\n      0\n      0\n      0\n      0\n      0\n      1\n      ...\n      1223\n      856\n      702\n      560\n      716\n      561\n      539\n      620\n      603\n      15699\n    \n    \n      Algeria\n      Africa\n      Northern Africa\n      Developing regions\n      80\n      67\n      71\n      69\n      63\n      44\n      69\n      ...\n      3626\n      4807\n      3623\n      4005\n      5393\n      4752\n      4325\n      3774\n      4331\n      69439\n    \n    \n      American Samoa\n      Oceania\n      Polynesia\n      Developing regions\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      ...\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      6\n    \n    \n      Andorra\n      Europe\n      Southern Europe\n      Developed regions\n      0\n      0\n      0\n      0\n      0\n      0\n      2\n      ...\n      0\n      1\n      1\n      0\n      0\n      0\n      0\n      1\n      1\n      15\n    \n  \n\n5 rows × 38 columns\n\n\n\nColumn names that are integers (such as the years) might introduce some confusion. For example, when we are referencing the year 2013, one might confuse that when the 2013th positional index.\nTo avoid this ambuigity, let’s convert the column names into strings: ‘1980’ to ‘2013’.\n\ndf_can.columns = list(map(str, df_can.columns))\n# [print (type(x)) for x in df_can.columns.values] #<-- uncomment to check type of column headers\ndf_can.head()\n\n\n\n\n\n  \n    \n      \n      Continent\n      Region\n      DevName\n      1980\n      1981\n      1982\n      1983\n      1984\n      1985\n      1986\n      ...\n      2005\n      2006\n      2007\n      2008\n      2009\n      2010\n      2011\n      2012\n      2013\n      Total\n    \n    \n      Country\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Afghanistan\n      Asia\n      Southern Asia\n      Developing regions\n      16\n      39\n      39\n      47\n      71\n      340\n      496\n      ...\n      3436\n      3009\n      2652\n      2111\n      1746\n      1758\n      2203\n      2635\n      2004\n      58639\n    \n    \n      Albania\n      Europe\n      Southern Europe\n      Developed regions\n      1\n      0\n      0\n      0\n      0\n      0\n      1\n      ...\n      1223\n      856\n      702\n      560\n      716\n      561\n      539\n      620\n      603\n      15699\n    \n    \n      Algeria\n      Africa\n      Northern Africa\n      Developing regions\n      80\n      67\n      71\n      69\n      63\n      44\n      69\n      ...\n      3626\n      4807\n      3623\n      4005\n      5393\n      4752\n      4325\n      3774\n      4331\n      69439\n    \n    \n      American Samoa\n      Oceania\n      Polynesia\n      Developing regions\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      ...\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      6\n    \n    \n      Andorra\n      Europe\n      Southern Europe\n      Developed regions\n      0\n      0\n      0\n      0\n      0\n      0\n      2\n      ...\n      0\n      1\n      1\n      0\n      0\n      0\n      0\n      1\n      1\n      15\n    \n  \n\n5 rows × 38 columns\n\n\n\nSince we converted the years to string, let’s declare a variable that will allow us to easily call upon the full range of years:\n\nyears = list(map(str, range(1980, 2014)))\nyears\n\n['1980',\n '1981',\n '1982',\n '1983',\n '1984',\n '1985',\n '1986',\n '1987',\n '1988',\n '1989',\n '1990',\n '1991',\n '1992',\n '1993',\n '1994',\n '1995',\n '1996',\n '1997',\n '1998',\n '1999',\n '2000',\n '2001',\n '2002',\n '2003',\n '2004',\n '2005',\n '2006',\n '2007',\n '2008',\n '2009',\n '2010',\n '2011',\n '2012',\n '2013']\n\n\nLets review the changes\n\nprint('data dimensions:', df_can.shape)\nprint(df_can.columns)\n\ndata dimensions: (195, 38)\nIndex(['Continent', 'Region', 'DevName', '1980', '1981', '1982', '1983',\n       '1984', '1985', '1986', '1987', '1988', '1989', '1990', '1991', '1992',\n       '1993', '1994', '1995', '1996', '1997', '1998', '1999', '2000', '2001',\n       '2002', '2003', '2004', '2005', '2006', '2007', '2008', '2009', '2010',\n       '2011', '2012', '2013', 'Total'],\n      dtype='object')"
  },
  {
    "objectID": "code/1_intro.html#background-into-matplotlib",
    "href": "code/1_intro.html#background-into-matplotlib",
    "title": "2  Introduction into data vis",
    "section": "2.2 Background into Matplotlib",
    "text": "2.2 Background into Matplotlib\nThe primary plotting library we will explore in the course is Matplotlib. As mentioned on their website:\n\nMatplotlib is a Python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. Matplotlib can be used in Python scripts, the Python and IPython shell, the jupyter notebook, web application servers, and four graphical user interface toolkits.\n\nIf you are aspiring to create impactful visualization with python, Matplotlib is an essential tool to have at your disposal.\n\n2.2.1 Layers\nMatplotlib’s architecture is composed of three main layers:\n\n2.2.1.1 Backend layer\nThe Back-end layer, which comes with three build-in abstract interacted\n\nFigure canvas: encompasses the area on which the figure is drawn\nRenderer: knows how to draw the figure canvas\nEvent: which handels user inputs, such as keyboard strokes or mouse clicks\n\n\n\n2.2.1.2 Artist layer\nThe Artist layer where much of the heavy lifting happens and is usually the appropriate programming paradigm when writing a web application server, or a UI application, or perhaps a script to be shared with other developers. Its composed of one main object, the Artist. The artist knows how to use the renderer to draw on the canvas. There are two types of artist objects:\n\nPrimitive: Line2D, rectangle, circle, text\nComposite: Axes, Tick and figure\n\n\n\n2.2.1.3 Scripting layer\nThe Scripting layer, which is the appropriate layer for everyday purposes and is considered a lighter scripting interface to simplify common tasks and for a quick and easy generation of graphics and plots.\nThis layer is mainly comprised of pyplot, a scripting interface that is lighter than the Artist layer."
  },
  {
    "objectID": "code/1_intro.html#matplotlib.pyplot",
    "href": "code/1_intro.html#matplotlib.pyplot",
    "title": "2  Introduction into data vis",
    "section": "2.3 Matplotlib.Pyplot",
    "text": "2.3 Matplotlib.Pyplot\nOne of the core aspects of Matplotlib is matplotlib.pyplot, Matplotlib’s scripting layer. It is a collection of command style functions that make Matplotlib work like MATLAB. Each pyplot function makes some change to a figure: e.g., creates a figure, creates a plotting area in a figure, plots some lines in a plotting area, decorates the plot with labels, etc.\nFor aesthetics we can check and apply styles in matplotlib as follows:\n\nprint(plt.style.available)\nmpl.style.use(['ggplot']) # optional: for ggplot-like style\n\n['Solarize_Light2', '_classic_test_patch', '_mpl-gallery', '_mpl-gallery-nogrid', 'bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn', 'seaborn-bright', 'seaborn-colorblind', 'seaborn-dark', 'seaborn-dark-palette', 'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook', 'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk', 'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'tableau-colorblind10']"
  },
  {
    "objectID": "code/1_intro.html#plotting-in-pandas",
    "href": "code/1_intro.html#plotting-in-pandas",
    "title": "2  Introduction into data vis",
    "section": "2.4 Plotting in pandas",
    "text": "2.4 Plotting in pandas\nPandas has a built-in implementation of Matplotlib that we can use. Plotting in pandas is as simple as appending a .plot() method to a series or dataframe.\nDocumentation:\n\nPlotting with Series\nPlotting with Dataframes"
  },
  {
    "objectID": "code/1_intro.html#line-plots",
    "href": "code/1_intro.html#line-plots",
    "title": "2  Introduction into data vis",
    "section": "2.5 Line plots",
    "text": "2.5 Line plots\nA line plot is a plot in the form of a series of data points connected by straight line segments.\nhe best use case for a line plot is when you have a continuous dataset and you’re interested in visualizing the data over a period of time.\nLine plot is a handy tool to display several dependent variables against one independent variable. However, it is recommended that no more than 5-10 lines on a single graph; any more than that and it becomes difficult to interpret.\nA case study\nIn 2010, Haiti suffered a catastrophic magnitude 7.0 earthquake. The quake caused widespread devastation and loss of life and aout three million people were affected by this natural disaster. As part of Canada’s humanitarian effort, the Government of Canada stepped up its effort in accepting refugees from Haiti. We can quickly visualize this effort using a Line plot:\nFirst, lets extract the data\n\nhaiti = df_can.loc['Haiti', years]\nhaiti.head()\n\n1980    1666\n1981    3692\n1982    3498\n1983    2860\n1984    1418\nName: Haiti, dtype: object\n\n\nNext, we can plot:\n\nhaiti.plot()\nplt.show()\nplt.close()\n\n\n\n\npandas automatically populated the x-axis with the index values (years), and the y-axis with the column values (population). However, notice how the years were not displayed because they are of type string. Therefore, let’s change the type of the index values to integer for plotting.\nAlso, let’s label the x and y axis using plt.title(), plt.ylabel(), and plt.xlabel() as follows:\n\n## let's change the index values of Haiti to type integer for plotting\nhaiti.index = haiti.index.map(int)\n\n#plot\nhaiti.plot(kind = 'line')\n\n#add labels\nplt.title(\"Immigration from Haiti\")\nplt.ylabel(\"Number of immigrants\")\nplt.xlabel(\"Years\")\n\nplt.show()\nplt.close()\n\n\n\n\nWe can clearly notice how number of immigrants from Haiti spiked up from 2010 as Canada stepped up its efforts to accept refugees from Haiti. Let’s annotate this spike in the plot by using the plt.text() method.\n\n#plot\nhaiti.plot(kind = 'line')\n\n#add labels\nplt.title(\"Immigration from Haiti\")\nplt.ylabel(\"Number of immigrants\")\nplt.xlabel(\"Years\")\n\n# annotate the 2010 Earthquake. \n# syntax: plt.text(x, y, label)\nplt.text(2000, 6000, \"2010 Earthquake\")\n\nplt.show()\nplt.close()\n\n\n\n\nLet’s compare the number of immigrants from India and China from 1980 to 2013.\nStep 1: Get the data set for China and India, and display the dataframe.\n\ndf_CI = df_can.loc[[\"China\", \"India\"], years]\ndf_CI.head()\n\n\n\n\n\n  \n    \n      \n      1980\n      1981\n      1982\n      1983\n      1984\n      1985\n      1986\n      1987\n      1988\n      1989\n      ...\n      2004\n      2005\n      2006\n      2007\n      2008\n      2009\n      2010\n      2011\n      2012\n      2013\n    \n    \n      Country\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      China\n      5123\n      6682\n      3308\n      1863\n      1527\n      1816\n      1960\n      2643\n      2758\n      4323\n      ...\n      36619\n      42584\n      33518\n      27642\n      30037\n      29622\n      30391\n      28502\n      33024\n      34129\n    \n    \n      India\n      8880\n      8670\n      8147\n      7338\n      5704\n      4211\n      7150\n      10189\n      11522\n      10343\n      ...\n      28235\n      36210\n      33848\n      28742\n      28261\n      29456\n      34235\n      27509\n      30933\n      33087\n    \n  \n\n2 rows × 34 columns\n\n\n\nLet’s try plotting\n\n#plot\ndf_CI.plot(kind = 'line')\n\nplt.show()\nplt.close()\n\n\n\n\nThat doesn’t look right.\nPandas plots the indices on the x-axis and the columns as individual lines on the y-axis. Since df_CI is a dataframe with the country as the index and years as the columns, we must first transpose the dataframe using transpose() method to swap the row and columns.\n\ndf_CI = df_CI.transpose()\ndf_CI.head()\n\n\n\n\n\n  \n    \n      Country\n      China\n      India\n    \n  \n  \n    \n      1980\n      5123\n      8880\n    \n    \n      1981\n      6682\n      8670\n    \n    \n      1982\n      3308\n      8147\n    \n    \n      1983\n      1863\n      7338\n    \n    \n      1984\n      1527\n      5704\n    \n  \n\n\n\n\n\n#change the index values\ndf_CI.index = df_CI.index.map(int)\n\n#plot\ndf_CI.plot(kind = 'line')\n\n#add labels\nplt.title(\"Immigration from China and India\")\nplt.ylabel(\"Number of immigrants\")\nplt.xlabel(\"Years\")\n\nplt.show()\nplt.close()\n\n\n\n\nQuestion: Compare the trend of top 5 countries that contributed the most to immigration to Canada.\nTo make the plot more readeable, we will change the size using the figsize parameter.\n\n#sort our data by the total column\ndf_can.sort_values(by = \"Total\", ascending = False, axis = 0, inplace = True)\n\n#get top five hits\ndf_top5 = df_can.head(5)\n\n#transpose the data\ndf_top5 = df_top5[years].transpose()\n\n#change the index values\ndf_top5.index = df_top5.index.map(int)\n\n#plot\ndf_top5.plot(kind='line', figsize=(8, 8))\n\n#add labels\nplt.title(\"Immigration in the top 5 countries that contributed most to immigration\")\nplt.xlabel(\"Years\")\nplt.ylabel(\"Number of immigrants\")\n\n\nplt.show()\nplt.close()"
  },
  {
    "objectID": "code/1_intro.html#other-plots",
    "href": "code/1_intro.html#other-plots",
    "title": "2  Introduction into data vis",
    "section": "2.6 Other Plots",
    "text": "2.6 Other Plots\nCongratulations! you have learned how to wrangle data with python and create a line plot with Matplotlib. There are many other plotting styles available other than the default Line plot, all of which can be accessed by passing kind keyword to plot(). The full list of available plots are as follows:\nbar for vertical bar plots barh for horizontal bar plots hist for histogram box for boxplot kde or density for density plots area for area plots pie for pie plots scatter for scatter plots hexbin for hexbin plot"
  },
  {
    "objectID": "code/2_basic_vis_tools.html",
    "href": "code/2_basic_vis_tools.html",
    "title": "3  Basic visualization tools",
    "section": "",
    "text": "#load libs\nimport pandas as pd\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\n#set graphics style\nmpl.style.use('ggplot') \n\n\n#load data\ndf_can = pd.read_excel(\"../data/Canada.xlsx\", sheet_name='Canada by Citizenship',skiprows=range(20), skipfooter=2)\n\n#check data\nprint(df_can.head())\nprint(df_can.shape)\n\n         Type    Coverage          OdName  AREA AreaName   REG  \\\n0  Immigrants  Foreigners     Afghanistan   935     Asia  5501   \n1  Immigrants  Foreigners         Albania   908   Europe   925   \n2  Immigrants  Foreigners         Algeria   903   Africa   912   \n3  Immigrants  Foreigners  American Samoa   909  Oceania   957   \n4  Immigrants  Foreigners         Andorra   908   Europe   925   \n\n           RegName  DEV             DevName  1980  ...  2004  2005  2006  \\\n0    Southern Asia  902  Developing regions    16  ...  2978  3436  3009   \n1  Southern Europe  901   Developed regions     1  ...  1450  1223   856   \n2  Northern Africa  902  Developing regions    80  ...  3616  3626  4807   \n3        Polynesia  902  Developing regions     0  ...     0     0     1   \n4  Southern Europe  901   Developed regions     0  ...     0     0     1   \n\n   2007  2008  2009  2010  2011  2012  2013  \n0  2652  2111  1746  1758  2203  2635  2004  \n1   702   560   716   561   539   620   603  \n2  3623  4005  5393  4752  4325  3774  4331  \n3     0     0     0     0     0     0     0  \n4     1     0     0     0     0     1     1  \n\n[5 rows x 43 columns]\n(195, 43)\n\n\n\n\n\n#drop irrelevant columns\ndf_can.drop(['AREA', 'REG', 'DEV', 'Type', 'Coverage'], axis=1, inplace=True)\n\n#give some columns better names\ndf_can.rename(columns={'OdName':'Country', 'AreaName':'Continent','RegName':'Region'}, inplace=True)\n\n# check whether all column have labels of type string.\nprint(all(isinstance(column, str) for column in df_can.columns))\n\n#change all columns to string type\ndf_can.columns = list(map(str, df_can.columns))\n\n# let's check the column labels types now\nprint(all(isinstance(column, str) for column in df_can.columns))\n\n# Set the country name as index \ndf_can.set_index('Country', inplace=True)\n\n#add a total column\ndf_can['Total'] = df_can.sum(axis=1)\n\n#create a list for the years of interest\nyears = list(map(str, range(1980, 2014)))\n\n#check df\nprint(df_can.head())\nprint('data dimensions:', df_can.shape)\n\nFalse\nTrue\n               Continent           Region             DevName  1980  1981  \\\nCountry                                                                     \nAfghanistan         Asia    Southern Asia  Developing regions    16    39   \nAlbania           Europe  Southern Europe   Developed regions     1     0   \nAlgeria           Africa  Northern Africa  Developing regions    80    67   \nAmerican Samoa   Oceania        Polynesia  Developing regions     0     1   \nAndorra           Europe  Southern Europe   Developed regions     0     0   \n\n                1982  1983  1984  1985  1986  ...  2005  2006  2007  2008  \\\nCountry                                       ...                           \nAfghanistan       39    47    71   340   496  ...  3436  3009  2652  2111   \nAlbania            0     0     0     0     1  ...  1223   856   702   560   \nAlgeria           71    69    63    44    69  ...  3626  4807  3623  4005   \nAmerican Samoa     0     0     0     0     0  ...     0     1     0     0   \nAndorra            0     0     0     0     2  ...     0     1     1     0   \n\n                2009  2010  2011  2012  2013  Total  \nCountry                                              \nAfghanistan     1746  1758  2203  2635  2004  58639  \nAlbania          716   561   539   620   603  15699  \nAlgeria         5393  4752  4325  3774  4331  69439  \nAmerican Samoa     0     0     0     0     0      6  \nAndorra            0     0     0     1     1     15  \n\n[5 rows x 38 columns]\ndata dimensions: (195, 38)"
  },
  {
    "objectID": "code/2_basic_vis_tools.html#area-plots",
    "href": "code/2_basic_vis_tools.html#area-plots",
    "title": "3  Basic visualization tools",
    "section": "3.2 Area plots",
    "text": "3.2 Area plots\n\nalso known as an area chart or graph is a type of plot\ndepicts cumulated totals using numbers or percentages over time\nbased on a line plot\n\nIn the last module, we created a line plot that visualized the top 5 countries that contribued the most immigrants to Canada from 1980 to 2013. With a little modification to the code, we can visualize this plot as a cumulative plot, also knows as a Stacked Line Plot or Area plot.\nLet’s first get the data for the top5 countries\n\n#sort df\ndf_can.sort_values(['Total'], ascending = False, axis = 0 , inplace =  True)\n\n#get the top5 countries\ndf_top5 = df_can.head(5)\n\n#transpose data\ndf_top5 = df_top5[years].transpose()\n\n#check data\ndf_top5.head()\n\n\n\n\n\n  \n    \n      Country\n      India\n      China\n      United Kingdom of Great Britain and Northern Ireland\n      Philippines\n      Pakistan\n    \n  \n  \n    \n      1980\n      8880\n      5123\n      22045\n      6051\n      978\n    \n    \n      1981\n      8670\n      6682\n      24796\n      5921\n      972\n    \n    \n      1982\n      8147\n      3308\n      20620\n      5249\n      1201\n    \n    \n      1983\n      7338\n      1863\n      10015\n      4562\n      900\n    \n    \n      1984\n      5704\n      1527\n      10170\n      3801\n      668\n    \n  \n\n\n\n\nArea plots are stacked by default. And to produce a stacked area plot, each column must be either all positive or all negative values (any NaN, i.e. not a number, values will default to 0). To produce an unstacked plot, set parameter stacked to value False.\n\n#change the index values to type integer\n#df_top5.index = df_top5.index.map(int)\n\n#create area plot\ndf_top5.plot(kind = 'area', stacked = False, figsize = (8,4))\n\n#add labels\nplt.title('Immigration trend in top5 countries')\nplt.ylabel('Number of Immigrants')\nplt.xlabel('Years')\n\nplt.show()\nplt.close()\n\n\n\n\nThe unstacked plot has a default transparency (alpha value) at 0.5. We can modify this value by passing in the alpha parameter.\n\n#create area plot\ndf_top5.plot(kind = 'area', alpha = 0.25, stacked = False, figsize = (8,4))\n\n#add labels\nplt.title('Immigration trend in top5 countries')\nplt.ylabel('Number of Immigrants')\nplt.xlabel('Years')\n\nplt.show()\nplt.close()\n\n\n\n\n\n3.2.1 Types of plotting\n\n\n3.2.2 Two types of plotting\n\n3.2.2.1 Option 1: Scripting layer (procedural method) - using matplotlib.pyplot as ‘plt’\nYou can use plt i.e. matplotlib.pyplot and add more elements by calling different methods procedural; for example, plt.title(...) to add title or plt.xlabel(...) to add label to the x-axis.\n\n\n3.2.2.2 Option 2: Artist layer (Object oriented method) - using an Axes instance from Matplotlib (preferred)\nYou can use an Axes instance of your current plot and store it in a variable (eg. ax). You can add more elements by calling methods with a little change in syntax (by adding “set_” to the previous methods). For example, use ax.set_title() instead of plt.title() to add title, or ax.set_xlabel() instead of plt.xlabel() to add label to the x-axis.\nThis option sometimes is more transparent and flexible to use for advanced plots (in particular when having multiple plots, as you will see later).\nIn this course, we will stick to the scripting layer, except for some advanced visualizations where we will need to use the artist layer to manipulate advanced aspects of the plots.\nLet’s try an example for using the artist layer:\n\nax = df_top5.plot(kind = 'area', alpha = 0.35, figsize = (10,5))\n\nax.set_title('Immigration Trend of Top 5 Countries')\nax.set_ylabel('Number of Immigrants')\nax.set_xlabel('Years')\n\nplt.show()\nplt.close()\n\n\n\n\nLet’s Use the scripting layer to create a stacked area plot of the 5 countries that contributed the least to immigration to Canada from 1980 to 2013. Use a transparency value of 0.45.\n\n#prep data\ndf_can_tail5 = df_can.tail(5)\ndf_can_tail5 = df_can_tail5[years].transpose()\n\n#plot\ndf_can_tail5.plot(kind='area',\n             stacked=False,\n             figsize=(10, 5))  # pass a tuple (x, y) size\n\nplt.title('Immigration Trend of lowest 5 Countries')\nplt.ylabel('Number of Immigrants')\nplt.xlabel('Years')\n\nplt.show()\nplt.close()"
  },
  {
    "objectID": "code/2_basic_vis_tools.html#histograms",
    "href": "code/2_basic_vis_tools.html#histograms",
    "title": "3  Basic visualization tools",
    "section": "3.3 Histograms",
    "text": "3.3 Histograms\n\nA way of representing the frequency distribution of a numeric dataset\nTo do this numeric data is partitioned into into bins, each datapoint in the dataset is assigned to a bin, and then the number of datapoints that have been assigned to each bin are counted\nThe vertical axis is actually the frequency or the number of datapoints in each bin.\n\nQuestion: What is the frequency distribution of the number (population) of new immigrants from the various countries to Canada in 2013?\nBefore we proceed with creating the histogram plot, let’s first examine the data split into intervals. To do this, we will us Numpy’s histrogram method to get the bin ranges and frequency counts as follows:\n\ncount, bin_edges = np.histogram(df_can['2013'])\n\n#print the frequency count and the bin ranges (by default 10 bins are used)\nprint(count)\nprint(bin_edges)\n\n[178  11   1   2   0   0   0   0   1   2]\n[    0.   3412.9  6825.8 10238.7 13651.6 17064.5 20477.4 23890.3 27303.2\n 30716.1 34129. ]\n\n\nBy default, the histrogram method breaks up the dataset into 10 bins. The figure below summarizes the bin ranges and the frequency distribution of immigration in 2013. We can see that in 2013:\n\n178 countries contributed between 0 to 3412.9 immigrants\n11 countries contributed between 3412.9 to 6825.8 immigrants\n1 country contributed between 6285.8 to 10238.7 immigrants, and so on..\n\nWe can easily graph this distribution by passing kind=hist to plot().\n\n#plot\ndf_can['2013'].plot(kind = 'hist', figsize = (8,5))\n\n#add titles\nplt.title(\"Histogram of Immigration from 195 countries in 2013\")\nplt.ylabel(\"Number of Countries\")\nplt.xlabel(\"Number of Immigrants\")\n\nplt.show()\nplt.close()\n\n\n\n\nIn the above plot, the x-axis represents the population range of immigrants in intervals of 3412.9. The y-axis represents the number of countries that contributed to the aforementioned population.\nNotice that the x-axis labels do not match with the bin size. This can be fixed by passing in a xticks keyword that contains the list of the bin sizes, as follows:\n\n#define the intervals\ncount, bin_edges = np.histogram(df_can['2013'])\n\n\n#plot\ndf_can['2013'].plot(kind = 'hist', figsize = (8,5), xticks = bin_edges)\n\n#add titles\nplt.title(\"Histogram of Immigration from 195 countries in 2013\")\nplt.ylabel(\"Number of Countries\")\nplt.xlabel(\"Number of Immigrants\")\n\nplt.show()\nplt.close()\n\n\n\n\nWe can also plot multiple histograms on the same plot\nQuestion: What is the immigration distribution for Denmark, Norway, and Sweden for years 1980 - 2013?\n\ndf_can.loc[['Denmark', 'Norway', 'Sweden'], years].plot.hist()\nplt.show()\nplt.close()\n\n\n\n\nThat does not look right!\nDon’t worry, you’ll often come across situations like this when creating plots. The solution often lies in how the underlying dataset is structured.\nInstead of plotting the population frequency distribution of the population for the 3 countries, pandas instead plotted the population frequency distribution for the years.\nThis can be easily fixed by first transposing the dataset, and then plotting as shown below.\n\n#transform data\ndf_t = df_can.loc[['Denmark', 'Norway', 'Sweden'], years].transpose()\n\n#plot\ndf_t.plot(kind='hist', figsize=(10, 6))\n\nplt.title('Histogram of Immigration from Denmark, Norway, and Sweden from 1980 - 2013')\nplt.ylabel('Number of Years')\nplt.xlabel('Number of Immigrants')\n\nplt.show()\nplt.close()\n\n\n\n\nLet’s make a few modifications to improve the impact and aesthetics of the previous plot:\n\nincrease the bin size to 15 by passing in bins parameter;\nset transparency to 60% by passing in alpha parameter;\nlabel the x-axis by passing in x-label parameter;\nchange the colors of the plots by passing in color parameter.\n\n\n#get the tick values\ncount, bin_edges = np.histogram(df_t, 15)\n\n#plot an unstacked histogram\ndf_t.plot(kind='hist', figsize=(10, 6), bins = 15, alpha = 0.6, xticks = bin_edges,\ncolor = ['coral', 'darkslateblue', 'mediumseagreen'])\n\nplt.title('Histogram of Immigration from Denmark, Norway, and Sweden from 1980 - 2013')\nplt.ylabel('Number of Years')\nplt.xlabel('Number of Immigrants')\n\nplt.show()\nplt.close()\n\n\n\n\nFor a full listing of colors available in Matplotlib, run the following code in your python shell:\n\n#import matplotlib\n#for name, hex in matplotlib.colors.cnames.items():\n#    print(name, hex)\n\nIf we do not want the plots to overlap each other, we can stack them using the stacked parameter. Let’s also adjust the min and max x-axis labels to remove the extra gap on the edges of the plot. We can pass a tuple (min,max) using the xlim paramater, as show below.\n\n#get the tick values\ncount, bin_edges = np.histogram(df_t, 15)\n\n#  first bin value is 31.0, last is 308, adding buffer of 10 for aesthetic purposes\nxmin = bin_edges[0] -10\nxmax = bin_edges[-1] + 10 \n\n#plot a stacked histogram\n# stacked Histogram\ndf_t.plot(kind='hist',\n          figsize=(10, 6), \n          bins=15,\n          xticks=bin_edges,\n          color=['coral', 'darkslateblue', 'mediumseagreen'],\n          stacked=True,\n          xlim=(xmin, xmax)\n         )\n\nplt.title('Histogram of Immigration from Denmark, Norway, and Sweden from 1980 - 2013')\nplt.ylabel('Number of Years')\nplt.xlabel('Number of Immigrants')\n\nplt.show()\nplt.close()\n\n\n\n\nQuestion: Use the scripting layer to display the immigration distribution for Greece, Albania, and Bulgaria for years 1980 - 2013? Use an overlapping plot with 15 bins and a transparency value of 0.35.\n\n#prep data\ndf_2 = df_can.loc[['Greece', 'Albania', 'Bulgaria'], years].transpose()\n\n#set bins\ncount, bin_edges = np.histogram(df_2, 15)\n\n#plot\ndf_2.plot(kind = 'hist', figsize = (8,6), alpha = 0.35, xticks = bin_edges, bins = 15)\nplt.title('Histogram of Immigration from Greece, Albania, and Bulgaria from 1980 - 2013')\nplt.ylabel('Number of Years')\nplt.xlabel('Number of Immigrants')\n\nplt.show()\nplt.close()"
  },
  {
    "objectID": "code/2_basic_vis_tools.html#bar-charts",
    "href": "code/2_basic_vis_tools.html#bar-charts",
    "title": "3  Basic visualization tools",
    "section": "3.4 Bar charts",
    "text": "3.4 Bar charts\n\nUsed to compare the values of a variable at a given point in time\n\nTo create a bar plot, we can pass one of two arguments via kind parameter in plot():\n\nkind=bar creates a vertical bar plot\nkind=barh creates a horizontal bar plot\n\n\n3.4.1 Vertical bar plot\nIn vertical bar graphs, the x-axis is used for labelling, and the length of bars on the y-axis corresponds to the magnitude of the variable being measured. Vertical bar graphs are particularly useful in analyzing time series data. One disadvantage is that they lack space for text labelling at the foot of each bar.\nLet’s start off by analyzing the effect of Iceland’s Financial Crisis:\nThe 2008 - 2011 Icelandic Financial Crisis was a major economic and political event in Iceland. Relative to the size of its economy, Iceland’s systemic banking collapse was the largest experienced by any country in economic history. The crisis led to a severe economic depression in 2008 - 2011 and significant political unrest.\nQuestion: Let’s compare the number of Icelandic immigrants (country = ‘Iceland’) to Canada from year 1980 to 2013.\n\n#prep data\ndf_iceland = df_can.loc['Iceland', years]\ndf_iceland.head(3)\n\n1980    17\n1981    33\n1982    10\nName: Iceland, dtype: object\n\n\n\n#plot the data\ndf_iceland.plot(kind = 'bar', figsize = (8,6))\n\nplt.xlabel('Year') # add to x-label to the plot\nplt.ylabel('Number of immigrants') # add y-label to the plot\nplt.title('Icelandic immigrants to Canada from 1980 to 2013') # add title to the plot\n\nplt.show()\nplt.close()\n\n\n\n\nThe bar plot above shows the total number of immigrants broken down by each year. We can clearly see the impact of the financial crisis; the number of immigrants to Canada started increasing rapidly after 2008.\nLet’s annotate this on the plot using the annotate method of the scripting layer or the pyplot interface. We will pass in the following parameters:\n\ns: str, the text of annotation.\nxy: Tuple specifying the (x,y) point to annotate (in this case, end point of arrow).\nxytext: Tuple specifying the (x,y) point to place the text (in this case, start point of arrow).\nxycoords: The coordinate system that xy is given in - ‘data’ uses the coordinate system of the object being annotated (default).\narrowprops: Takes a dictionary of properties to draw the arrow:\n\narrowstyle: Specifies the arrow style, '->' is standard arrow.\nconnectionstyle: Specifies the connection type. arc3 is a straight line.\ncolor: Specifies color of arrow.\nlw: Specifies the line width.\n\n\nI encourage you to read the Matplotlib documentation for more details on annotations: http://matplotlib.orsg/api/pyplot_api.html#matplotlib.pyplot.annotate.\n\n#plot the data and rotate xticks\ndf_iceland.plot(kind = 'bar', figsize = (8,6), rot = 90)\n\nplt.xlabel('Year') # add to x-label to the plot\nplt.ylabel('Number of immigrants') # add y-label to the plot\nplt.title('Icelandic immigrants to Canada from 1980 to 2013') # add title to the plot\n\n#annotate arrow, h\nplt.annotate('', # s: str. Will leave it blank for no text\n            xy=(32,70), # place head of the arrow at point (year 2012 , pop 70)\n            xytext=(28,20), # place base of the arrow at point (year 2008 , pop 20)\n            xycoords='data', # will use the coordinate system of the object being annotated\n            arrowprops = dict(arrowstyle='->', connectionstyle='arc3', color='blue', lw=2)\n            )\n\nplt.show()\nplt.close()\n\n\n\n\nLet’s also annotate a text to go over the arrow. We will pass in the following additional parameters:\n\nrotation: rotation angle of text in degrees (counter clockwise)\nva: vertical alignment of text [‘center’ | ‘top’ | ‘bottom’ | ‘baseline’]\nha: horizontal alignment of text [‘center’ | ‘right’ | ‘left’]\n\n\n#plot the data and rotate xticks\ndf_iceland.plot(kind = 'bar', figsize = (8,6), rot = 90)\n\nplt.xlabel('Year') # add to x-label to the plot\nplt.ylabel('Number of immigrants') # add y-label to the plot\nplt.title('Icelandic immigrants to Canada from 1980 to 2013') # add title to the plot\n\n#annotate arrow\nplt.annotate('', # s: str. Will leave it blank for no text\n            xy=(32,70), # place head of the arrow at point (year 2012 , pop 70)\n            xytext=(28,20), # place base of the arrow at point (year 2008 , pop 20)\n            xycoords='data', # will use the coordinate system of the object being annotated\n            arrowprops = dict(arrowstyle='->', connectionstyle='arc3', color='blue', lw=2)\n            )\n\n#annotate arrow\nplt.annotate('2008-2011 Financal crisis',  # text to display\n            xy=(28,30),  # start the text at at point (year 2008 , pop 30)\n            rotation=73.5, # based on trial and error to match the arrow\n            va='bottom', # want the text to be vertically 'bottom' aligned\n            ha='left' # want the text to be horizontally 'left' aligned\n            )\n\nplt.show()\nplt.close()\n\n\n\n\n\n\n3.4.2 Horizontal barplots\nSometimes it is more practical to represent the data horizontally, especially if you need more room for labelling the bars. In horizontal bar graphs, the y-axis is used for labelling, and the length of bars on the x-axis corresponds to the magnitude of the variable being measured. As you will see, there is more room on the y-axis to label categorical variables.\nQuestion: Using the scripting later and the df_can dataset, create a horizontal bar plot showing the total number of immigrants to Canada from the top 15 countries, for the period 1980 - 2013. Label each country with the total immigrant count.\nStep 1: Get the data pertaining to the top 15 countries.\n\ndf_top15 = df_can['Total'].head(15)\n\nStep 2: Plot data:\n\nUse kind='barh' to generate a bar chart with horizontal bars.\nMake sure to choose a good size for the plot and to label your axes and to give the plot a title.\nLoop through the countries and annotate the immigrant population using the anotate function of the scripting interface.\n\n\ndf_top15.plot(kind='barh', figsize=(10,6))\n\n#plt.xlabel('Year')\n#plt.ylabel('Number of Immigrants')\nplt.title('Total number of Immigrants to Canada from 1980 to 2013\\n in the Top15 countries')\n\n#annotate value labels for each country and add to plot\nfor index, value in enumerate(df_top15):\n    label = format(value, ',')\n    plt.annotate(label, xy = (value,  index - 0.1), color = 'black', size =8)\n\nplt.show()\nplt.close()"
  },
  {
    "objectID": "code/2_basic_vis_tools.html#pie-charts",
    "href": "code/2_basic_vis_tools.html#pie-charts",
    "title": "3  Basic visualization tools",
    "section": "3.5 Pie charts",
    "text": "3.5 Pie charts\nA pie chart is a circular graphic that displays numeric proportions by dividing a circle (or pie) into proportional slices. You are most likely already familiar with pie charts as it is widely used in business and media. We can create pie charts in Matplotlib by passing in the kind=pie keyword.\nLet’s use a pie chart to explore the proportion (percentage) of new immigrants grouped by continents for the entire time period from 1980 to 2013.\nStep 1: Gather data.\nWe will use pandas groupby method to summarize the immigration data by Continent. The general process of groupby involves the following steps:\n\nSplit: Splitting the data into groups based on some criteria.\nApply: Applying a function to each group independently: .sum() .count() .mean() .std() .aggregate() .apply() .etc..\nCombine: Combining the results into a data structure.\n\n\n\n#group countries by continents and apply the sum function\ndf_continents = df_can.groupby('Continent', axis = 0).sum()\ndf_continents.head()\n\n\n\n\n\n  \n    \n      \n      1980\n      1981\n      1982\n      1983\n      1984\n      1985\n      1986\n      1987\n      1988\n      1989\n      ...\n      2005\n      2006\n      2007\n      2008\n      2009\n      2010\n      2011\n      2012\n      2013\n      Total\n    \n    \n      Continent\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Africa\n      3951\n      4363\n      3819\n      2671\n      2639\n      2650\n      3782\n      7494\n      7552\n      9894\n      ...\n      27523\n      29188\n      28284\n      29890\n      34534\n      40892\n      35441\n      38083\n      38543\n      618948\n    \n    \n      Asia\n      31025\n      34314\n      30214\n      24696\n      27274\n      23850\n      28739\n      43203\n      47454\n      60256\n      ...\n      159253\n      149054\n      133459\n      139894\n      141434\n      163845\n      146894\n      152218\n      155075\n      3317794\n    \n    \n      Europe\n      39760\n      44802\n      42720\n      24638\n      22287\n      20844\n      24370\n      46698\n      54726\n      60893\n      ...\n      35955\n      33053\n      33495\n      34692\n      35078\n      33425\n      26778\n      29177\n      28691\n      1410947\n    \n    \n      Latin America and the Caribbean\n      13081\n      15215\n      16769\n      15427\n      13678\n      15171\n      21179\n      28471\n      21924\n      25060\n      ...\n      24747\n      24676\n      26011\n      26547\n      26867\n      28818\n      27856\n      27173\n      24950\n      765148\n    \n    \n      Northern America\n      9378\n      10030\n      9074\n      7100\n      6661\n      6543\n      7074\n      7705\n      6469\n      6790\n      ...\n      8394\n      9613\n      9463\n      10190\n      8995\n      8142\n      7677\n      7892\n      8503\n      241142\n    \n  \n\n5 rows × 35 columns\n\n\n\nStep 2: Plot the data. We will pass in kind = 'pie' keyword, along with the following additional parameters:\n\nautopct - is a string or function used to label the wedges with their numeric value. The label will be placed inside the wedge. If it is a format string, the label will be fmt%pct.\nstartangle - rotates the start of the pie chart by angle degrees counterclockwise from the x-axis.\nshadow - Draws a shadow beneath the pie (to give a 3D feel).\n\n\n# autopct create %, start angle represent starting point\ndf_continents['Total'].plot(kind = 'pie',\n                            figsize = (5,6),\n                            autopct='%1.1f%%', #add in percentages\n                            startangle=90,\n                            shadow=True\n                            )\n\nplt.title('Immigration to Canada by Continent [1980 - 2013]')\nplt.axis('equal') # Sets the pie chart to look like a circle.\n\nplt.show()\nplt.close()\n\n\n\n\nThe above visual is not very clear, the numbers and text overlap in some instances. Let’s make a few modifications to improve the visuals:\n\nRemove the text labels on the pie chart by passing in legend and add it as a seperate legend using plt.legend().\nPush out the percentages to sit just outside the pie chart by passing in pctdistance parameter.\nPass in a custom set of colors for continents by passing in colors parameter.\nExplode the pie chart to emphasize the lowest three continents (Africa, North America, and Latin America and Caribbean) by passing in explode parameter.\n\n\ncolors_list = ['gold', 'yellowgreen', 'lightcoral', 'lightskyblue', 'lightgreen', 'pink']\nexplode_list = [0.1, 0, 0, 0, 0.1, 0.1] # ratio for each continent with which to offset each wedge.\n\n#plot\ndf_continents['Total'].plot(kind = 'pie',\n                            figsize = (5,6),\n                            autopct='%1.1f%%', #add in percentages\n                            startangle=90,\n                            shadow=True,\n                            labels=None,\n                            pctdistance=1.12,\n                            colors=colors_list,\n                            explode=explode_list\n                            )\n\n# scale the title up by 12% to match pctdistance\nplt.title('Immigration to Canada by Continent [1980 - 2013]', y=1.12) \nplt.axis('equal') # Sets the pie chart to look like a circle.\n\n# add legend\nplt.legend(labels=df_continents.index, loc='upper left') \n\nplt.show()\nplt.close()\n\n\n\n\nQuestion: Using a pie chart, explore the proportion (percentage) of new immigrants grouped by continents in the year 2013.\n\nexplode_list = [0.0, 0, 0, 0.1, 0.1, 0.2]\n\n#plot\ndf_continents['2013'].plot(kind='pie',\n                            figsize = (6,5),\n                            autopct='%1.1f%%',\n                            startangle=90,\n                            shadow=True,\n                            labels=None,\n                            pctdistance=1.12, \n                            explode=explode_list)\n\nplt.title(\"Immigration to canada in 2013\", y =1.12)\n\n#add legend\nplt.legend(labels = df_continents.index, loc='upper left')\n\nplt.show()\nplt.close()"
  },
  {
    "objectID": "code/2_basic_vis_tools.html#boxplots",
    "href": "code/2_basic_vis_tools.html#boxplots",
    "title": "3  Basic visualization tools",
    "section": "3.6 Boxplots",
    "text": "3.6 Boxplots\nSo, what is a boxplot? A boxplot is a way of statistically representing the distribution of given data through 5 main dimensions.\n\nminimum, which is the smallest number in the sorted data. Its value can be obtained by subtracting 1.5 times the IQR where IQR is interquartile range from the first quartile.\nfirst quartile which is 25% of the way through the sorted data. In other words, 1/4 of the data points are less than this value\nmedian, which is the median of the sorted data\nthird quartile, which is 75% of the way through the sorted data. In other words, 3/4 of the data points are less than this value\nmaximum, which is the highest number in the sorted data where maximum equals third quartile summed with 1.5 multiplied by IQR\nBoxplots also display outliers as individual dots that occur outside the upper and lower extremes\n\n\nTo make a boxplot, we can use kind=box in plot method invoked on a pandas series or dataframe.\nLet’s plot the box plot for the Japanese immigrants between 1980 - 2013.\nStep 1: Get the subset of the dataset. Even though we are extracting the data for just one country, we will obtain it as a dataframe. This will help us with calling the dataframe.describe() method to view the percentiles.\n\n#subset data\ndf_japan = df_can.loc[['Japan'], years].transpose()\n\n#ensure we have numericdata\ndf_japan.Japan =df_japan.Japan.astype(int)\n\ndf_japan.head(3)\n\n\n\n\n\n  \n    \n      Country\n      Japan\n    \n  \n  \n    \n      1980\n      701\n    \n    \n      1981\n      756\n    \n    \n      1982\n      598\n    \n  \n\n\n\n\nStep 2: Plot by passing in kind=‘box’.\n\ndf_japan.plot(kind='box', figsize=(6, 6))\n\nplt.title('Box plot of Japanese Immigrants from 1980 - 2013')\nplt.ylabel('Number of Immigrants')\n\nplt.show()\nplt.close()\n\n\n\n\nWe can immediately make a few key observations from the plot above:\n\nThe minimum number of immigrants is around 200 (min), maximum number is around 1300 (max), and median number of immigrants is around 900 (median).\n25% of the years for period 1980 - 2013 had an annual immigrant count of ~500 or fewer (First quartile).\n75% of the years for period 1980 - 2013 had an annual immigrant count of ~1100 or fewer (Third quartile).\n\nWe can view the actual numbers by calling the describe() method on the dataframe.\n\ndf_japan.describe()\n\n\n\n\n\n  \n    \n      Country\n      Japan\n    \n  \n  \n    \n      count\n      34.000000\n    \n    \n      mean\n      814.911765\n    \n    \n      std\n      337.219771\n    \n    \n      min\n      198.000000\n    \n    \n      25%\n      529.000000\n    \n    \n      50%\n      902.000000\n    \n    \n      75%\n      1079.000000\n    \n    \n      max\n      1284.000000\n    \n  \n\n\n\n\nOne of the key benefits of box plots is comparing the distribution of multiple datasets. In one of the previous labs, we observed that China and India had very similar immigration trends. Let’s analyze these two countries further using box plots.\nQuestion: Compare the distribution of the number of new immigrants from India and China for the period 1980 - 2013.\nStep 1: Get the dataset for China and India and call the dataframe df_CI.\n\ndf_CI = df_can.loc[['China', 'India'], years].transpose()\ndf_CI.head()\n\n\n\n\n\n  \n    \n      Country\n      China\n      India\n    \n  \n  \n    \n      1980\n      5123\n      8880\n    \n    \n      1981\n      6682\n      8670\n    \n    \n      1982\n      3308\n      8147\n    \n    \n      1983\n      1863\n      7338\n    \n    \n      1984\n      1527\n      5704\n    \n  \n\n\n\n\nLet’s view the percentiles associated with both countries using the describe() method.\n\ndf_CI.describe()\n\n\n\n\n\n  \n    \n      Country\n      China\n      India\n    \n  \n  \n    \n      count\n      34.000000\n      34.000000\n    \n    \n      mean\n      19410.647059\n      20350.117647\n    \n    \n      std\n      13568.230790\n      10007.342579\n    \n    \n      min\n      1527.000000\n      4211.000000\n    \n    \n      25%\n      5512.750000\n      10637.750000\n    \n    \n      50%\n      19945.000000\n      20235.000000\n    \n    \n      75%\n      31568.500000\n      28699.500000\n    \n    \n      max\n      42584.000000\n      36210.000000\n    \n  \n\n\n\n\nStep 2: Plot data.\n\ndf_CI.plot(kind='box', figsize = (6,6))\n\nplt.title('Box plot of Chinese and Indian Immigrants from 1980 - 2013')\nplt.ylabel('Number of Immigrants')\n\nplt.show()\nplt.close()\n\n\n\n\nWe can observe that, while both countries have around the same median immigrant population (~20,000), China’s immigrant population range is more spread out than India’s. The maximum population from India for any year (36,210) is around 15% lower than the maximum population from China (42,584).\nIf you prefer to create horizontal box plots, you can pass the vert parameter in the plot function and assign it to False. You can also specify a different color in case you are not a big fan of the default red color.\n\ndf_CI.plot(kind='box', figsize = (6,6), color = 'blue', vert = False)\n\nplt.title('Box plot of Chinese and Indian Immigrants from 1980 - 2013')\nplt.ylabel('Number of Immigrants')\n\nplt.show()\nplt.close()\n\n\n\n\nSubplots\nOften times we might want to plot multiple plots within the same figure. For example, we might want to perform a side by side comparison of the box plot with the line plot of China and India’s immigration.\nTo visualize multiple plots together, we can create a figure (overall canvas) and divide it into subplots, each containing a plot. With subplots, we usually work with the artist layer instead of the scripting layer.\nTypical syntax is : \n    fig = plt.figure() # create figure\n    ax = fig.add_subplot(nrows, ncols, plot_number) # create subplots\nWhere\n\nnrows and ncols are used to notionally split the figure into (nrows * ncols) sub-axes,\nplot_number is used to identify the particular subplot that this function is to create within the notional grid. plot_number starts at 1, increments across rows first and has a maximum of nrows * ncols as shown below.\n\n\nWe can then specify which subplot to place each plot by passing in the ax paramemter in plot() method as follows:\n\nfig = plt.figure() # create figure\n\nax0 = fig.add_subplot(2, 1, 1) # add subplot 1 (2 row, 1 columns, first plot)\nax1 = fig.add_subplot(2, 1, 2) # add subplot 2 (2 row, 1 columns, second plot). See tip below**\n\n# Subplot 1: Box plot\ndf_CI.plot(kind='box', color='blue', vert=False, figsize=(10, 6), ax=ax0) # add to subplot 1\nax0.set_title('Box Plots of Immigrants from China and India (1980 - 2013)')\nax0.set_xlabel('Number of Immigrants')\nax0.set_ylabel('Countries')\n\n# Subplot 2: Line plot\ndf_CI.plot(kind='line', figsize=(20, 6), ax=ax1) # add to subplot 2\nax1.set_title ('Line Plots of Immigrants from China and India (1980 - 2013)')\nax1.set_ylabel('Number of Immigrants')\nax1.set_xlabel('Years')\n\nplt.show()\nplt.close()\n\n\n\n\nTip regarding subplot convention\nIn the case when nrows, ncols, and plot_number are all less than 10, a convenience exists such that a 3-digit number can be given instead, where the hundreds represent nrows, the tens represent ncols and the units represent plot_number. For instance,\n   subplot(211) == subplot(2, 1, 1) \nproduces a subaxes in a figure which represents the top plot (i.e. the first) in a 2 rows by 1 column notional grid (no grid actually exists, but conceptually this is how the returned subplot has been positioned).\nQuestion: Create a box plot to visualize the distribution of the top 15 countries (based on total immigration) grouped by the decades 1980s, 1990s, and 2000s.\nStep 1: Get the dataset. Get the top 15 countries based on Total immigrant population. Name the dataframe df_top15.\n\ndf_can.sort_values(['Total'], ascending = False, axis = 0 , inplace =  True)\ndf_top15 = df_can.head(15)\n\nStep 2: Create a new dataframe which contains the aggregate for each decade. One way to do that:\n\nCreate a list of all years in decades 80’s, 90’s, and 00’s.\nSlice the original dataframe df_can to create a series for each decade and sum across all years for each country.\nMerge the three series into a new data frame. Call your dataframe new_df.\n\n\n# create a list of all years in decades 80's, 90's, and 00's\nyears_80s = list(map(str, range(1980, 1990))) \nyears_90s = list(map(str, range(1990, 2000))) \nyears_00s = list(map(str, range(2000, 2010))) \n\n# slice the original dataframe df_can to create a series for each decade\ndf_80s = df_top15.loc[:, years_80s].sum(axis=1) \ndf_90s = df_top15.loc[:, years_90s].sum(axis=1) \ndf_00s = df_top15.loc[:, years_00s].sum(axis=1)\n\n# merge the three series into a new data frame\nnew_df = pd.DataFrame({'1980s': df_80s, '1990s': df_90s, '2000s':df_00s}) \n\n# display dataframe\nnew_df.head()\n\n\n\n\n\n  \n    \n      \n      1980s\n      1990s\n      2000s\n    \n    \n      Country\n      \n      \n      \n    \n  \n  \n    \n      India\n      82154\n      180395\n      303591\n    \n    \n      China\n      32003\n      161528\n      340385\n    \n    \n      United Kingdom of Great Britain and Northern Ireland\n      179171\n      261966\n      83413\n    \n    \n      Philippines\n      60764\n      138482\n      172904\n    \n    \n      Pakistan\n      10591\n      65302\n      127598\n    \n  \n\n\n\n\n\n#get basic stats\nnew_df.describe()\n\n\n\n\n\n  \n    \n      \n      1980s\n      1990s\n      2000s\n    \n  \n  \n    \n      count\n      15.000000\n      15.000000\n      15.000000\n    \n    \n      mean\n      44418.333333\n      85594.666667\n      97471.533333\n    \n    \n      std\n      44190.676455\n      68237.560246\n      100583.204205\n    \n    \n      min\n      7613.000000\n      30028.000000\n      13629.000000\n    \n    \n      25%\n      16698.000000\n      39259.000000\n      36101.500000\n    \n    \n      50%\n      30638.000000\n      56915.000000\n      65794.000000\n    \n    \n      75%\n      59183.000000\n      104451.500000\n      105505.500000\n    \n    \n      max\n      179171.000000\n      261966.000000\n      340385.000000\n    \n  \n\n\n\n\nStep 3: Plot the box plots.\n\nnew_df.plot(kind='box', figsize = (6,6), color = 'blue', vert = False)\n\nplt.title('Immigration from top 15 countries for decades 80s, 90s and 2000s')\nplt.ylabel('Number of Immigrants')\n\nplt.show()\nplt.close()\n\n\n\n\nNote how the box plot differs from the summary table created. The box plot scans the data and identifies the outliers. In order to be an outlier, the data value must be:\n\nlarger than Q3 by at least 1.5 times the interquartile range (IQR), or,\nsmaller than Q1 by at least 1.5 times the IQR.\n\nLet’s look at decade 2000s as an example: \n\nQ1 (25%) = 36,101.5 \nQ3 (75%) = 105,505.5 \nIQR = Q3 - Q1 = 69,404 \n\nUsing the definition of outlier, any value that is greater than Q3 by 1.5 times IQR will be flagged as outlier.\nOutlier > 105,505.5 + (1.5 * 69,404)  Outlier > 209,611.5"
  },
  {
    "objectID": "code/2_basic_vis_tools.html#scatter-plots",
    "href": "code/2_basic_vis_tools.html#scatter-plots",
    "title": "3  Basic visualization tools",
    "section": "3.7 Scatter plots",
    "text": "3.7 Scatter plots\n\nA scatter plot is a type of plot that displays values pertaining to typically two variables against each other.\nUsually it is a dependent variable to be plotted against an independent variable in order to determine if any correlation between the two variables exists\n\nLet’s start by exploring the following:\nUsing a scatter plot, let’s visualize the trend of total immigrantion to Canada (all countries combined) for the years 1980 - 2013.\nStep 1: Get the dataset. Since we are expecting to use the relationship betewen years and total population, we will convert years to int type.\n\n# we can use the sum() method to get the total population per year\ndf_tot = pd.DataFrame(df_can[years].sum(axis=0))\n\n# change the years to type int (useful for regression later on)\ndf_tot.index = map(int, df_tot.index)\n\n# reset the index to put in back in as a column in the df_tot dataframe\ndf_tot.reset_index(inplace = True)\n\n# rename columns\ndf_tot.columns = ['year', 'total']\n\n# view the final dataframe\ndf_tot.head()\n\n\n\n\n\n  \n    \n      \n      year\n      total\n    \n  \n  \n    \n      0\n      1980\n      99137\n    \n    \n      1\n      1981\n      110563\n    \n    \n      2\n      1982\n      104271\n    \n    \n      3\n      1983\n      75550\n    \n    \n      4\n      1984\n      73417\n    \n  \n\n\n\n\nStep 2: Plot the data. In Matplotlib, we can create a scatter plot set by passing in kind=‘scatter’ as plot argument. We will also need to pass in x and y keywords to specify the columns that go on the x- and the y-axis.\n\ndf_tot.plot(kind='scatter', x='year', y='total', figsize=(6, 6), color='darkblue')\n\nplt.title('Total Immigration to Canada from 1980 - 2013')\nplt.xlabel('Year')\nplt.ylabel('Number of Immigrants')\n\nplt.show()\nplt.close()\n\n\n\n\nNotice how the scatter plot does not connect the data points together. We can clearly observe an upward trend in the data: as the years go by, the total number of immigrants increases. We can mathematically analyze this upward trend using a regression line (line of best fit).\nSo let’s try to plot a linear line of best fit, and use it to predict the number of immigrants in 2015.\nStep 1: Get the equation of line of best fit. We will use Numpy’s polyfit() method by passing in the following:\n\nx: x-coordinates of the data.\ny: y-coordinates of the data.\ndeg: Degree of fitting polynomial. 1 = linear, 2 = quadratic, and so on.\n\n\nx = df_tot['year']\ny = df_tot['total']\nfit = np.polyfit(x,y, deg = 1)\n\nfit\n\narray([ 5.56709228e+03, -1.09261952e+07])\n\n\nThe output is an array with the polynomial coefficients, highest powers first. Since we are plotting a linear regression y= a * x + b, our output has 2 elements [5.56709228e+03, -1.09261952e+07] with the the slope in position 0 and intercept in position 1.\nStep 2: Plot the regression line on the scatter plot.\n\n# print out the line of best fit\n'No. Immigrants = {0:.0f} * Year + {1:.0f}'.format(fit[0], fit[1]) \n\n'No. Immigrants = 5567 * Year + -10926195'\n\n\n\ndf_tot.plot(kind='scatter', x='year', y='total', figsize=(6, 6), color='darkblue')\n\nplt.title('Total Immigration to Canada from 1980 - 2013')\nplt.xlabel('Year')\nplt.ylabel('Number of Immigrants')\n\n#plot line of the best fit\nplt.plot(x, fit[0] * x + fit[1], color='red') # recall that x is the Years\nplt.annotate('y={0:.0f} x + {1:.0f}'.format(fit[0], fit[1]), xy=(2000, 150000))\n\nplt.show()\nplt.close()\n\n\n\n\nUsing the equation of line of best fit, we can estimate the number of immigrants in 2015:\nNo. Immigrants = 5567 * Year - 10926195\nNo. Immigrants = 5567 * 2015 - 10926195\nNo. Immigrants = 291,310\nWhen compared to the actual from Citizenship and Immigration Canada’s (CIC) 2016 Annual Report, we see that Canada accepted 271,845 immigrants in 2015. Our estimated value of 291,310 is within 7% of the actual number, which is pretty good considering our original data came from United Nations (and might differ slightly from CIC data).\nAs a side note, we can observe that immigration took a dip around 1993 - 1997. Further analysis into the topic revealed that in 1993 Canada introcuded Bill C-86 which introduced revisions to the refugee determination system, mostly restrictive. Further amendments to the Immigration Regulations cancelled the sponsorship required for “assisted relatives” and reduced the points awarded to them, making it more difficult for family members (other than nuclear family) to immigrate to Canada. These restrictive measures had a direct impact on the immigration numbers for the next several years.\nQuestion: Create a scatter plot of the total immigration from Denmark, Norway, and Sweden to Canada from 1980 to 2013?\nStep 1: Get the data:\n\nCreate a dataframe the consists of the numbers associated with Denmark, Norway, and Sweden only. Name it df_countries.\nSum the immigration numbers across all three countries for each year and turn the result into a dataframe. Name this new dataframe df_total.\nReset the index in place.\nRename the columns to year and total.\nDisplay the resulting dataframe.\n\n\n#subset data\ndf_countries = df_can.loc[['Denmark', 'Norway', 'Sweden'], years]\n\n#get total\ndf_total = pd.DataFrame(df_can[years].sum(axis=0))\n\n#reset index\ndf_total.reset_index(inplace = True)\n\n#rename columns\ndf_total.columns = ['year', 'total']\n\n# change column year from string to int to create scatter plot\ndf_total['year'] = df_total['year'].astype(int)\n    \ndf_total.head(3)\n\n\n\n\n\n  \n    \n      \n      year\n      total\n    \n  \n  \n    \n      0\n      1980\n      99137\n    \n    \n      1\n      1981\n      110563\n    \n    \n      2\n      1982\n      104271\n    \n  \n\n\n\n\nStep 2: Generate the scatter plot by plotting the total versus year in df_total.\n\ndf_total.plot(kind='scatter', x='year', y='total', figsize=(6, 6), color='darkblue')\n\nplt.title('Total Immigration from Denmark, Norway and Sweden to Canada from 1980 - 2013')\nplt.xlabel('Year')\nplt.ylabel('Number of Immigrants')\n\nplt.show()\nplt.close()"
  },
  {
    "objectID": "code/2_basic_vis_tools.html#bubble-plots",
    "href": "code/2_basic_vis_tools.html#bubble-plots",
    "title": "3  Basic visualization tools",
    "section": "3.8 Bubble Plots",
    "text": "3.8 Bubble Plots\nA bubble plot is a variation of the scatter plot that displays three dimensions of data (x, y, z). The data points are replaced with bubbles, and the size of the bubble is determined by the third variable z, also known as the weight. In maplotlib, we can pass in an array or scalar to the parameter s to plot(), that contains the weight of each point.\nLet’s start by analyzing the effect of Argentina’s great depression.\nArgentina suffered a great depression from 1998 to 2002, which caused widespread unemployment, riots, the fall of the government, and a default on the country’s foreign debt. In terms of income, over 50% of Argentines were poor, and seven out of ten Argentine children were poor at the depth of the crisis in 2002.\nLet’s analyze the effect of this crisis, and compare Argentina’s immigration to that of it’s neighbour Brazil. Let’s do that using a bubble plot of immigration from Brazil and Argentina for the years 1980 - 2013. We will set the weights for the bubble as the normalized value of the population for each year.\nStep 1: Get the data for Brazil and Argentina. Like in the previous example, we will convert the Years to type int and include it in the dataframe.\n\n# transposed dataframe\ndf_can_t = df_can[years].transpose()\n\n# cast the Years (the index) to type int\ndf_can_t.index = map(int, df_can_t.index)\n\n# let's label the index. This will automatically be the column name when we reset the index\ndf_can_t.index.name = 'Year'\n\n# reset index to bring the Year in as a column\ndf_can_t.reset_index(inplace=True)\n\n# view the changes\ndf_can_t.head()\n\n\n\n\n\n  \n    \n      Country\n      Year\n      India\n      China\n      United Kingdom of Great Britain and Northern Ireland\n      Philippines\n      Pakistan\n      United States of America\n      Iran (Islamic Republic of)\n      Sri Lanka\n      Republic of Korea\n      ...\n      Kiribati\n      Vanuatu\n      Sao Tome and Principe\n      Tuvalu\n      American Samoa\n      San Marino\n      New Caledonia\n      Marshall Islands\n      Western Sahara\n      Palau\n    \n  \n  \n    \n      0\n      1980\n      8880\n      5123\n      22045\n      6051\n      978\n      9378\n      1172\n      185\n      1011\n      ...\n      0\n      0\n      0\n      0\n      0\n      1\n      0\n      0\n      0\n      0\n    \n    \n      1\n      1981\n      8670\n      6682\n      24796\n      5921\n      972\n      10030\n      1429\n      371\n      1456\n      ...\n      0\n      0\n      0\n      1\n      1\n      0\n      0\n      0\n      0\n      0\n    \n    \n      2\n      1982\n      8147\n      3308\n      20620\n      5249\n      1201\n      9074\n      1822\n      290\n      1572\n      ...\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n    \n    \n      3\n      1983\n      7338\n      1863\n      10015\n      4562\n      900\n      7100\n      1592\n      197\n      1081\n      ...\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n    \n    \n      4\n      1984\n      5704\n      1527\n      10170\n      3801\n      668\n      6661\n      1977\n      1086\n      847\n      ...\n      0\n      0\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n    \n  \n\n5 rows × 196 columns\n\n\n\nStep 2: Create the normalized weights.\nThere are several methods of normalizations in statistics, each with its own use. In this case, we will use feature scaling to bring all values into the range. The general formula is:\n\nwhere \\(X\\) is the original value, \\(X'\\) is the corresponding normalized value. The formula sets the max value in the dataset to 1, and sets the min value to 0. The rest of the data points are scaled to a value between 0-1 accordingly.\n\n# normalize Brazil data\nnorm_brazil = (df_can_t['Brazil'] - df_can_t['Brazil'].min()) / (df_can_t['Brazil'].max() - df_can_t['Brazil'].min())\n\n# normalize Argentina data\nnorm_argentina = (df_can_t['Argentina'] - df_can_t['Argentina'].min()) / (df_can_t['Argentina'].max() - df_can_t['Argentina'].min())\n\nStep 3: Plot the data.\n\nTo plot two different scatter plots in one plot, we can include the axes one plot into the other by passing it via the ax parameter.\nWe will also pass in the weights using the s parameter. Given that the normalized weights are between 0-1, they won’t be visible on the plot. Therefore, we will:\n\nmultiply weights by 2000 to scale it up on the graph, and,\nadd 10 to compensate for the min value (which has a 0 weight and therefore scale with \\(\\times 2000\\)).\n\n\n\n# Brazil\nax0 = df_can_t.plot(kind='scatter',\n                    x='Year',\n                    y='Brazil',\n                    figsize=(8, 6),\n                    alpha=0.5,  # transparency\n                    color='green',\n                    s=norm_brazil * 2000 + 10,  # pass in weights \n                    xlim=(1975, 2015)\n                    )\n\n# Argentina\nax1 = df_can_t.plot(kind='scatter',\n                    x='Year',\n                    y='Argentina',\n                    alpha=0.5,\n                    color=\"blue\",\n                    s=norm_argentina * 2000 + 10,\n                    ax=ax0\n                    )\n\nax0.set_ylabel('Number of Immigrants')\nax0.set_title('Immigration from Brazil and Argentina from 1980 to 2013')\nax0.legend(['Brazil', 'Argentina'], loc='upper left', fontsize='x-large')\n\nplt.show()\nplt.close()\n\n\n\n\nThe size of the bubble corresponds to the magnitude of immigrating population for that year, compared to the 1980 - 2013 data. The larger the bubble is, the more immigrants are in that year.\nFrom the plot above, we can see a corresponding increase in immigration from Argentina during the 1998 - 2002 great depression. We can also observe a similar spike around 1985 to 1993. In fact, Argentina had suffered a great depression from 1974 to 1990, just before the onset of 1998 - 2002 great depression.\nOn a similar note, Brazil suffered the Samba Effect where the Brazilian real (currency) dropped nearly 35% in 1999. There was a fear of a South American financial crisis as many South American countries were heavily dependent on industrial exports from Brazil. The Brazilian government subsequently adopted an austerity program, and the economy slowly recovered over the years, culminating in a surge in 2010. The immigration data reflect these events.\nQuestion: Previously in this lab, we created box plots to compare immigration from China and India to Canada. Create bubble plots of immigration from China and India to visualize any differences with time from 1980 to 2013. You can use df_can_t that we defined and used in the previous example.\n\n# normalized Chinese data\nnorm_china = (df_can_t['China'] - df_can_t['China'].min()) / (df_can_t['China'].max() - df_can_t['China'].min())\n\n# normalized Indian data\nnorm_india = (df_can_t['India'] - df_can_t['India'].min()) / (df_can_t['India'].max() - df_can_t['India'].min())\n\n\nax0 = df_can_t.plot(kind='scatter',\n                        x='Year',\n                        y='China',\n                        figsize=(14, 8),\n                        alpha=0.5,                  # transparency\n                        color='green',\n                        s=norm_china * 2000 + 10,  # pass in weights \n                        xlim=(1975, 2015)\n                       )\n\n# India\nax1 = df_can_t.plot(kind='scatter',\n                        x='Year',\n                        y='India',\n                        alpha=0.5,\n                        color=\"blue\",\n                        s=norm_india * 2000 + 10,\n                        ax = ax0\n                       )\n\nax0.set_ylabel('Number of Immigrants')\nax0.set_title('Immigration from China and India from 1980 - 2013')\nax0.legend(['China', 'India'], loc='upper left', fontsize='x-large')\n\nplt.show()\nplt.close()"
  },
  {
    "objectID": "code/3_advanced_vis_tools.html",
    "href": "code/3_advanced_vis_tools.html",
    "title": "4  Advanced visualization tools",
    "section": "",
    "text": "#load libs\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom PIL import Image\nimport json\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches # needed for waffle Charts\n\nimport folium\n\n\n#load data\ndf_can = pd.read_excel(\"../data/Canada.xlsx\", sheet_name='Canada by Citizenship',skiprows=range(20), skipfooter=2)\n\n#check data\nprint(df_can.head(3))\n\n         Type    Coverage       OdName  AREA AreaName   REG          RegName  \\\n0  Immigrants  Foreigners  Afghanistan   935     Asia  5501    Southern Asia   \n1  Immigrants  Foreigners      Albania   908   Europe   925  Southern Europe   \n2  Immigrants  Foreigners      Algeria   903   Africa   912  Northern Africa   \n\n   DEV             DevName  1980  ...  2004  2005  2006  2007  2008  2009  \\\n0  902  Developing regions    16  ...  2978  3436  3009  2652  2111  1746   \n1  901   Developed regions     1  ...  1450  1223   856   702   560   716   \n2  902  Developing regions    80  ...  3616  3626  4807  3623  4005  5393   \n\n   2010  2011  2012  2013  \n0  1758  2203  2635  2004  \n1   561   539   620   603  \n2  4752  4325  3774  4331  \n\n[3 rows x 43 columns]\n\n\n\n# clean up the dataset to remove unnecessary columns (eg. REG) \ndf_can.drop(['AREA','REG','DEV','Type','Coverage'], axis = 1, inplace = True)\n\n# let's rename the columns so that they make sense\ndf_can.rename (columns = {'OdName':'Country', 'AreaName':'Continent','RegName':'Region'}, inplace = True)\n\n# for sake of consistency, let's also make all column labels of type string\ndf_can.columns = list(map(str, df_can.columns))\n\n# set the country name as index - useful for quickly looking up countries using .loc method\ndf_can.set_index('Country', inplace = True)\n\n# years that we will be using in this lesson - useful for plotting later on\nyears = list(map(str, range(1980, 2014)))\n\n# add total column\ndf_can['Total'] =  df_can[years].sum (axis = 1)\n\n#control dimensions\nprint ('data dimensions:', df_can.shape)\n\ndata dimensions: (195, 38)"
  },
  {
    "objectID": "code/3_advanced_vis_tools.html#waffle-charts",
    "href": "code/3_advanced_vis_tools.html#waffle-charts",
    "title": "4  Advanced visualization tools",
    "section": "4.2 Waffle charts",
    "text": "4.2 Waffle charts\nA waffle chart is a great way to visualize data in relation to a whole or to highlight progress against a given threshold.\nLet’s revisit the previous case study about Denmark, Norway, and Sweden.\n\ndf_dsn = df_can.loc[['Denmark', 'Norway', 'Sweden']]\ndf_dsn.head()\n\n\n\n\n\n  \n    \n      \n      Continent\n      Region\n      DevName\n      1980\n      1981\n      1982\n      1983\n      1984\n      1985\n      1986\n      ...\n      2005\n      2006\n      2007\n      2008\n      2009\n      2010\n      2011\n      2012\n      2013\n      Total\n    \n    \n      Country\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Denmark\n      Europe\n      Northern Europe\n      Developed regions\n      272\n      293\n      299\n      106\n      93\n      73\n      93\n      ...\n      62\n      101\n      97\n      108\n      81\n      92\n      93\n      94\n      81\n      3901\n    \n    \n      Norway\n      Europe\n      Northern Europe\n      Developed regions\n      116\n      77\n      106\n      51\n      31\n      54\n      56\n      ...\n      57\n      53\n      73\n      66\n      75\n      46\n      49\n      53\n      59\n      2327\n    \n    \n      Sweden\n      Europe\n      Northern Europe\n      Developed regions\n      281\n      308\n      222\n      176\n      128\n      158\n      187\n      ...\n      205\n      139\n      193\n      165\n      167\n      159\n      134\n      140\n      140\n      5866\n    \n  \n\n3 rows × 38 columns\n\n\n\nUnfortunately, unlike R, waffle charts are not built into any of the Python visualization libraries. Therefore, we will learn how to create them from scratch.\nStep 1. The first step into creating a waffle chart is determining the proportion of each category with respect to the total.\n\n#compute the proportion of each category with respect to the total\ntotal_values = df_dsn['Total'].sum()\ncategory_proportions = df_dsn['Total'] / total_values\n\n# print out proportions\npd.DataFrame({\"Category Proportion\": category_proportions})\n\n\n\n\n\n  \n    \n      \n      Category Proportion\n    \n    \n      Country\n      \n    \n  \n  \n    \n      Denmark\n      0.322557\n    \n    \n      Norway\n      0.192409\n    \n    \n      Sweden\n      0.485034\n    \n  \n\n\n\n\nStep 2. The second step is defining the overall size of the waffle chart.\n\nwidth=40\nheight=10\n\ntotal_num_tiles = width * height\n\nprint(f'Total number of tiles is {total_num_tiles}.')\n\nTotal number of tiles is 400.\n\n\nStep 3. The third step is using the proportion of each category to determe it respective number of tiles\n\ntiles_per_category = (category_proportions * total_num_tiles).round().astype(int)\n\n# print out number of tiles per category\npd.DataFrame({\"Number of tiles\": tiles_per_category})\n\n\n\n\n\n  \n    \n      \n      Number of tiles\n    \n    \n      Country\n      \n    \n  \n  \n    \n      Denmark\n      129\n    \n    \n      Norway\n      77\n    \n    \n      Sweden\n      194\n    \n  \n\n\n\n\nBased on the calculated proportions, Denmark will occupy 129 tiles of the waffle chart, Norway will occupy 77 tiles, and Sweden will occupy 194 tiles.\nStep 4. The fourth step is creating a matrix that resembles the waffle chart and populating it.\n\n# initialize the waffle chart as an empty matrix\nwaffle_chart = np.zeros((height, width), dtype = np.uint)\n\n# define indices to loop through waffle chart\ncategory_index = 0\ntile_index = 0\n\n\n# populate the waffle chart\nfor col in range(width):\n    for row in range(height):\n        tile_index += 1\n        # if the number of tiles populated for the current category is equal to its corresponding allocated tiles...\n        if tile_index > sum(tiles_per_category[0:category_index]):\n            # ...proceed to the next category\n            category_index += 1       \n        # set the class value to an integer, which increases with class\n        waffle_chart[row, col] = category_index\nprint ('Waffle chart populated!')\n\nWaffle chart populated!\n\n\n\n#view chart\nwaffle_chart\n\narray([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]],\n      dtype=uint64)\n\n\nAs expected, the matrix consists of three categories and the total number of each category’s instances matches the total number of tiles allocated to each category.\nStep 5. Map the waffle chart matrix into a visual.\n\n# instantiate a new figure object\nfig = plt.figure()\n\n# use matshow to display the waffle chart\ncolormap = plt.cm.coolwarm\nplt.matshow(waffle_chart, cmap=colormap)\nplt.colorbar()\n\nplt.show()\nplt.close()\n\n<Figure size 336x336 with 0 Axes>\n\n\n\n\n\nPrettify\n\n# instantiate a new figure object\nfig = plt.figure()\n\n# use matshow to display the waffle chart\ncolormap = plt.cm.coolwarm\nplt.matshow(waffle_chart, cmap=colormap)\nplt.colorbar()\n\n# get the axis\nax = plt.gca()\n\n# set minor ticks\nax.set_xticks(np.arange(-.5, (width), 1), minor=True)\nax.set_yticks(np.arange(-.5, (height), 1), minor=True)\n    \n# add gridlines based on minor ticks\nax.grid(which='minor', color='w', linestyle='-', linewidth=2)\n\nplt.xticks([])\nplt.yticks([])\nplt.show()\nplt.close()\n\n<Figure size 336x336 with 0 Axes>\n\n\n\n\n\nStep 7. Create a legend and add it to chart.\n\n# instantiate a new figure object\nfig = plt.figure()\n\n# use matshow to display the waffle chart\ncolormap = plt.cm.coolwarm\nplt.matshow(waffle_chart, cmap=colormap)\nplt.colorbar()\n\n# get the axis\nax = plt.gca()\n\n# set minor ticks\nax.set_xticks(np.arange(-.5, (width), 1), minor=True)\nax.set_yticks(np.arange(-.5, (height), 1), minor=True)\n    \n# add gridlines based on minor ticks\nax.grid(which='minor', color='w', linestyle='-', linewidth=2)\n\nplt.xticks([])\nplt.yticks([])\n\n# compute cumulative sum of individual categories to match color schemes between chart and legend\nvalues_cumsum = np.cumsum(df_dsn['Total'])\ntotal_values = values_cumsum[len(values_cumsum) - 1]\n\n# create legend\nlegend_handles = []\nfor i, category in enumerate(df_dsn.index.values):\n    label_str = category + ' (' + str(df_dsn['Total'][i]) + ')'\n    color_val = colormap(float(values_cumsum[i])/total_values)\n    legend_handles.append(mpatches.Patch(color=color_val, label=label_str))\n\n# add legend to chart\nplt.legend(handles=legend_handles,\n           loc='lower center', \n           ncol=len(df_dsn.index.values),\n           bbox_to_anchor=(0., -0.2, 0.95, .1)\n          )\nplt.show()\n\nplt.close()\n\n<Figure size 336x336 with 0 Axes>\n\n\n\n\n\nNow it would very inefficient to repeat these seven steps every time we wish to create a waffle chart. So let’s combine all seven steps into one function called create_waffle_chart. This function would take the following parameters as input:\n\ncategories: Unique categories or classes in dataframe.\nvalues: Values corresponding to categories or classes.\nheight: Defined height of waffle chart.\nwidth: Defined width of waffle chart.\ncolormap: Colormap class\nvalue_sign: In order to make our function more generalizable, we will add this parameter to address signs that could be associated with a value such as %, $, and so on. value_sign has a default value of empty string.\n\n\ndef create_waffle_chart(categories, values, height, width, colormap, value_sign=''):\n\n    # compute the proportion of each category with respect to the total\n    total_values = sum(values)\n    category_proportions = [(float(value) / total_values) for value in values]\n\n    # compute the total number of tiles\n    total_num_tiles = width * height # total number of tiles\n    print ('Total number of tiles is', total_num_tiles)\n    \n    # compute the number of tiles for each catagory\n    tiles_per_category = [round(proportion * total_num_tiles) for proportion in category_proportions]\n\n    # print out number of tiles per category\n    for i, tiles in enumerate(tiles_per_category):\n        print (df_dsn.index.values[i] + ': ' + str(tiles))\n    \n    # initialize the waffle chart as an empty matrix\n    waffle_chart = np.zeros((height, width))\n\n    # define indices to loop through waffle chart\n    category_index = 0\n    tile_index = 0\n\n    # populate the waffle chart\n    for col in range(width):\n        for row in range(height):\n            tile_index += 1\n\n            # if the number of tiles populated for the current category \n            # is equal to its corresponding allocated tiles...\n            if tile_index > sum(tiles_per_category[0:category_index]):\n                # ...proceed to the next category\n                category_index += 1       \n            \n            # set the class value to an integer, which increases with class\n            waffle_chart[row, col] = category_index\n    \n    # instantiate a new figure object\n    fig = plt.figure()\n\n    # use matshow to display the waffle chart\n    colormap = plt.cm.coolwarm\n    plt.matshow(waffle_chart, cmap=colormap)\n    plt.colorbar()\n\n    # get the axis\n    ax = plt.gca()\n\n    # set minor ticks\n    ax.set_xticks(np.arange(-.5, (width), 1), minor=True)\n    ax.set_yticks(np.arange(-.5, (height), 1), minor=True)\n    \n    # add dridlines based on minor ticks\n    ax.grid(which='minor', color='w', linestyle='-', linewidth=2)\n\n    plt.xticks([])\n    plt.yticks([])\n\n    # compute cumulative sum of individual categories to match color schemes between chart and legend\n    values_cumsum = np.cumsum(values)\n    total_values = values_cumsum[len(values_cumsum) - 1]\n\n    # create legend\n    legend_handles = []\n    for i, category in enumerate(categories):\n        if value_sign == '%':\n            label_str = category + ' (' + str(values[i]) + value_sign + ')'\n        else:\n            label_str = category + ' (' + value_sign + str(values[i]) + ')'\n            \n        color_val = colormap(float(values_cumsum[i])/total_values)\n        legend_handles.append(mpatches.Patch(color=color_val, label=label_str))\n\n    # add legend to chart\n    plt.legend(\n        handles=legend_handles,\n        loc='lower center', \n        ncol=len(categories),\n        bbox_to_anchor=(0., -0.2, 0.95, .1)\n    )\n    plt.show()\n    plt.close()\n\nNow to create a waffle chart, all we have to do is call the function create_waffle_chart. Let’s define the input parameters:\n\nwidth = 40 # width of chart\nheight = 10 # height of chart\n\ncategories = df_dsn.index.values # categories\nvalues = df_dsn['Total'] # correponding values of categories\n\ncolormap = plt.cm.coolwarm # color map class\n\nAnd now let’s call our function to create a waffle chart.\n\ncreate_waffle_chart(categories, values, height, width, colormap)\nplt.close()\n\nTotal number of tiles is 400\nDenmark: 129\nNorway: 77\nSweden: 194\n\n\n<Figure size 336x336 with 0 Axes>\n\n\n\n\n\nThere seems to be a new Python package for generating waffle charts called PyWaffle, but it looks like the repository is still being built. But feel free to check it out and play with it."
  },
  {
    "objectID": "code/3_advanced_vis_tools.html#word-clouds",
    "href": "code/3_advanced_vis_tools.html#word-clouds",
    "title": "4  Advanced visualization tools",
    "section": "4.3 Word clouds",
    "text": "4.3 Word clouds\nA word cloud is simply a depiction of the importance of different words in the body of text. A word cloud works in a simple way; the more a specific word appears in a source of textual data the bigger and bolder it appears in the world cloud.\nLuckily, a Python package already exists in Python for generating word clouds. The package, called word_cloud was developed by Andreas Mueller. You can learn more about the package by following this link."
  },
  {
    "objectID": "code/3_advanced_vis_tools.html#seaborn-and-regression-plots",
    "href": "code/3_advanced_vis_tools.html#seaborn-and-regression-plots",
    "title": "4  Advanced visualization tools",
    "section": "4.4 Seaborn and regression plots",
    "text": "4.4 Seaborn and regression plots\nSeaborn is another data visualization library, based on Matplotlib. It was built primarily to provide a high-level interface for drawing attractive statistical graphics, such as regression plots, box plots, … in a more efficient way.\nIn lab Pie Charts, Box Plots, Scatter Plots, and Bubble Plots, we learned how to create a scatter plot and then fit a regression line. It took ~20 lines of code to create the scatter plot along with the regression fit. In this final section, we will explore seaborn and see how efficient it is to create regression lines and fits using this library!\nCreate a new dataframe that stores that total number of landed immigrants to Canada per year from 1980 to 2013.\n\n#get the total poulation per year\ndf_tot = pd.DataFrame(df_can[years].sum(axis=0))\n\n#change the years to fload\ndf_tot.index = map(float, df_tot.index)\n\n#reset the index and put it back as a column in the df\ndf_tot.reset_index(inplace = True)\n\n#rename columns\ndf_tot.columns = ['year', 'total']\n\n#view df\ndf_tot.head()\n\n\n\n\n\n  \n    \n      \n      year\n      total\n    \n  \n  \n    \n      0\n      1980.0\n      99137\n    \n    \n      1\n      1981.0\n      110563\n    \n    \n      2\n      1982.0\n      104271\n    \n    \n      3\n      1983.0\n      75550\n    \n    \n      4\n      1984.0\n      73417\n    \n  \n\n\n\n\nWith seaborn, generating a regression plot is as simple as calling the regplot function.\n\nsns.regplot(x='year', y='total', data = df_tot)\nplt.show()\nplt.close()\n\n\n\n\nThis is not magic; it is seaborn! You can also customize the color of the scatter plot and regression line. Let’s change the color to green.\n\nsns.regplot(x='year', y='total', data = df_tot, color = 'green')\nplt.show()\nplt.close()\n\n\n\n\nYou can always customize the marker shape, so instead of circular markers, let’s use +.\n\nsns.regplot(x='year', y='total', data = df_tot, color = 'green', marker = '+')\nplt.show()\nplt.close()\n\n\n\n\nLet’s blow up the plot a little so that it is more appealing to the sight.\n\nplt.figure(figsize=(8, 6))\nsns.regplot(x='year', y='total', data = df_tot, color = 'green', marker = '+')\nplt.show()\nplt.close()\n\n\n\n\nAnd let’s increase the size of markers so they match the new size of the figure, and add a title and x- and y-labels.\n\nplt.figure(figsize=(8, 6))\n\nsns.set(font_scale=1.2)\n\nsns.regplot(x='year', y='total', data = df_tot, color = 'green', marker = '+', scatter_kws={'s':200})\nax.set(xlabel = 'Year', ylabel = 'Total Immigration')\nax.set_title('Total Immigration to Canada from 1980 to 2013')\n\nplt.show()\nplt.close()\n\n\n\n\nAmazing! A complete scatter plot with a regression fit with 5 lines of code only. Isn’t this really amazing?\nIf you are not a big fan of the purple background, you can easily change the style to a white plain background.\n\nplt.figure(figsize=(8, 6))\n\nsns.set(font_scale=1.2)\nsns.set_style('ticks')\n\nsns.regplot(x='year', y='total', data = df_tot, color = 'green', marker = '+', scatter_kws={'s':200})\nax.set(xlabel = 'Year', ylabel = 'Total Immigration')\nax.set_title('Total Immigration to Canada from 1980 to 2013')\n\nplt.show()\nplt.close()\n\n\n\n\nOr to a white background with gridlines.\n\nplt.figure(figsize=(8, 6))\n\nsns.set(font_scale=1.2)\nsns.set_style('whitegrid')\n\nsns.regplot(x='year', y='total', data = df_tot, color = 'green', marker = '+', scatter_kws={'s':200})\nax.set(xlabel = 'Year', ylabel = 'Total Immigration')\nax.set_title('Total Immigration to Canada from 1980 to 2013')\n\nplt.show()\nplt.close()"
  },
  {
    "objectID": "code/3_advanced_vis_tools.html#folium",
    "href": "code/3_advanced_vis_tools.html#folium",
    "title": "4  Advanced visualization tools",
    "section": "4.5 Folium",
    "text": "4.5 Folium\nFolium is a powerful data visualization library in Python that was built primarily to help people visualize geospatial data. What is nice about Folium is that it was developed for the sole purpose of visualizing geospatial data. While other libraries are available to visualize geospatial data, such as plotly, they might have a cap on how many API calls you can make within a defined time frame. Folium, on the other hand, is completely free.\nDatasets:\n\nSan Francisco Police Department Incidents for the year 2016 - Police Department Incidents from San Francisco public data portal. Incidents derived from San Francisco Police Department (SFPD) Crime Incident Reporting system. Updated daily, showing data for the entire year of 2016. Address and location has been anonymized by moving to mid-block or to an intersection.\nImmigration to Canada from 1980 to 2013 - International migration flows to and from selected countries - The 2015 revision from United Nation’s website. The dataset contains annual data on the flows of international migrants as recorded by the countries of destination. The data presents both inflows and outflows according to the place of birth, citizenship or place of previous / next residence both for foreigners and nationals. For this lesson, we will focus on the Canadian Immigration data\n\nGenerating the world map is straightforward in Folium. You simply create a Folium Map object, and then you display it. What is attractive about Folium maps is that they are interactive, so you can zoom into any region of interest despite the initial zoom level.\n\n#define world map\nworld_map = folium.Map()\n\n#display map\nworld_map\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\nYou can customize this default definition of the world map by specifying the centre of your map, and the initial zoom level.\nAll locations on a map are defined by their respective Latitude and Longitude values. So you can create a map and pass in a center of Latitude and Longitude values of [0, 0].\nFor a defined center, you can also define the initial zoom level into that location when the map is rendered. The higher the zoom level the more the map is zoomed into the center.\nLet’s create a map centered around Canada and play with the zoom level to see how it affects the rendered map. As The higher the zoom level the more the map is zoomed into the given center.\n\n#define world map\nworld_map = folium.Map(location=[56.130, -106.35], zoom_start=4)\n\n#display map\nworld_map\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\n\n4.5.1 Stamen Toner maps\nThese are high-contrast B+W (black and white) maps. They are perfect for data mashups and exploring river meanders and coastal zones.\nLet’s create a Stamen Toner map of canada with a zoom level of 4.\n\n#define world map\nworld_map = folium.Map(location=[56.130, -106.35], zoom_start=4, tiles = 'Stamen Toner')\n\n#display map\nworld_map\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\n\n\n4.5.2 Stamen Terrain maps\nThese are maps that feature hill shading and natural vegetation colors. They showcase advanced labeling and linework generalization of dual-carriageway roads.\n\n#define world map\nworld_map = folium.Map(location=[56.130, -106.35], zoom_start=4, tiles = 'Stamen Terrain')\n\n#display map\nworld_map\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\n\n\n4.5.3 Maps with markers\nLet’s download and import the data on police department incidents using pandas read_csv() method.\n\n#load data\ndf_incidents = pd.read_csv(\"../data/Police_Department_Incidents_-_Previous_Year__2016_.csv\")\n\n#check data\nprint(df_incidents.head(3))\n\n   IncidntNum     Category                                        Descript  \\\n0   120058272  WEAPON LAWS                       POSS OF PROHIBITED WEAPON   \n1   120058272  WEAPON LAWS  FIREARM, LOADED, IN VEHICLE, POSSESSION OR USE   \n2   141059263     WARRANTS                                  WARRANT ARREST   \n\n  DayOfWeek                    Date   Time PdDistrict      Resolution  \\\n0    Friday  01/29/2016 12:00:00 AM  11:00   SOUTHERN  ARREST, BOOKED   \n1    Friday  01/29/2016 12:00:00 AM  11:00   SOUTHERN  ARREST, BOOKED   \n2    Monday  04/25/2016 12:00:00 AM  14:59    BAYVIEW  ARREST, BOOKED   \n\n                  Address           X          Y  \\\n0  800 Block of BRYANT ST -122.403405  37.775421   \n1  800 Block of BRYANT ST -122.403405  37.775421   \n2   KEITH ST / SHAFTER AV -122.388856  37.729981   \n\n                                Location            PdId  \n0   (37.775420706711, -122.403404791479)  12005827212120  \n1   (37.775420706711, -122.403404791479)  12005827212168  \n2  (37.7299809672996, -122.388856204292)  14105926363010  \n\n\nSo each row consists of 13 features:\n\nIncidntNum: Incident Number\nCategory: Category of crime or incident\nDescript: Description of the crime or incident\nDayOfWeek: The day of week on which the incident occurred\nDate: The Date on which the incident occurred\nTime: The time of day on which the incident occurred\nPdDistrict: The police department district\nResolution: The resolution of the crime in terms whether the perpetrator was arrested or not\nAddress: The closest address to where the incident took place\nX: The longitude value of the crime location\nY: The latitude value of the crime location\nLocation: A tuple of the latitude and the longitude values\nPdId: The police department ID\n\nThe dataframe consists of 150,500 crimes, which took place in the year 2016. In order to reduce computational cost, let’s just work with the first 100 incidents in this dataset.\n\nlimit = 100\ndf_incidents = df_incidents.iloc[0:limit,:]\ndf_incidents.shape\n\n(100, 13)\n\n\nNow that we reduced the data a little, let’s visualize where these crimes took place in the city of San Francisco. We will use the default style, and we will initialize the zoom level to 12.\n\n# San Francisco latitude and longitude values\nlatitude = 37.77\nlongitude = -122.42\n\n\n# create map and display it\nsanfran_map = folium.Map(location=[latitude, longitude], zoom_start=12)\n\n# display the map of San Francisco\nsanfran_map\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\nNow let’s superimpose the locations of the crimes onto the map. The way to do that in Folium is to create a feature group with its own features and style and then add it to the sanfran_map.\n\n# instantiate a feature group for the incidents in the dataframe\nincidents = folium.map.FeatureGroup()\n\n# loop through the 100 crimes and add each to the incidents feature group\nfor lat, lng, in zip(df_incidents.Y, df_incidents.X):\n    incidents.add_child(\n        folium.features.CircleMarker(\n            [lat, lng],\n            radius=5, # define how big you want the circle markers to be\n            color='yellow',\n            fill=True,\n            fill_color='blue',\n            fill_opacity=0.6\n        )\n    )\n\n# add incidents to map\nsanfran_map.add_child(incidents)\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\nYou can also add some pop-up text that would get displayed when you hover over a marker. Let’s make each marker display the category of the crime when hovered over.\n\n# instantiate a feature group for the incidents in the dataframe\nincidents = folium.map.FeatureGroup()\n\n# loop through the 100 crimes and add each to the incidents feature group\nfor lat, lng, in zip(df_incidents.Y, df_incidents.X):\n    incidents.add_child(\n        folium.features.CircleMarker(\n            [lat, lng],\n            radius=5, # define how big you want the circle markers to be\n            color='yellow',\n            fill=True,\n            fill_color='blue',\n            fill_opacity=0.6\n        )\n    )\n\n# add pop-up text to each marker on the map\nlatitudes = list(df_incidents.Y)\nlongitudes = list(df_incidents.X)\nlabels = list(df_incidents.Category)\n\nfor lat, lng, label in zip(latitudes, longitudes, labels):\n    folium.Marker([lat, lng], popup=label).add_to(sanfran_map)    \n    \n# add incidents to map\nsanfran_map.add_child(incidents)\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\nIf you find the map to be so congested will all these markers, there are two remedies to this problem. The simpler solution is to remove these location markers and just add the text to the circle markers themselves as follows:\n\n# create map and display it\nsanfran_map = folium.Map(location=[latitude, longitude], zoom_start=12)\n\n# loop through the 100 crimes and add each to the map\nfor lat, lng, label in zip(df_incidents.Y, df_incidents.X, df_incidents.Category):\n    folium.features.CircleMarker(\n        [lat, lng],\n        radius=5, # define how big you want the circle markers to be\n        color='yellow',\n        fill=True,\n        popup=label,\n        fill_color='blue',\n        fill_opacity=0.6\n    ).add_to(sanfran_map)\n\n# show map\nsanfran_map\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\nThe other proper remedy is to group the markers into different clusters. Each cluster is then represented by the number of crimes in each neighborhood. These clusters can be thought of as pockets of San Francisco which you can then analyze separately.\nTo implement this, we start off by instantiating a MarkerCluster object and adding all the data points in the dataframe to this object.\n\nfrom folium import plugins\n\n# let's start again with a clean copy of the map of San Francisco\nsanfran_map = folium.Map(location = [latitude, longitude], zoom_start = 12)\n\n# instantiate a mark cluster object for the incidents in the dataframe\nincidents = plugins.MarkerCluster().add_to(sanfran_map)\n\n# loop through the dataframe and add each data point to the mark cluster\nfor lat, lng, label, in zip(df_incidents.Y, df_incidents.X, df_incidents.Category):\n    folium.Marker(\n        location=[lat, lng],\n        icon=None,\n        popup=label,\n    ).add_to(incidents)\n\n# display map\nsanfran_map\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\nNotice how when you zoom out all the way, all markers are grouped into one cluster, the global cluster, of 100 markers or crimes, which is the total number of crimes in our dataframe. Once you start zooming in, the global cluster will start breaking up into smaller clusters. Zooming in all the way will result in individual markers.\n\n\n4.5.4 Choropleth maps\nA Choropleth map is a thematic map in which areas are shaded or patterned in proportion to the measurement of the statistical variable being displayed on the map, such as population density or per-capita income. The choropleth map provides an easy way to visualize how a measurement varies across a geographic area, or it shows the level of variability within a region.\nNow, let’s create our own Choropleth map of the world depicting immigration from various countries to Canada.\nDownload the Canadian Immigration dataset and read it into a pandas dataframe.\n\n#load data\ndf_can = pd.read_excel(\"../data/Canada.xlsx\", sheet_name='Canada by Citizenship',skiprows=range(20), skipfooter=2)\n\n#check data\nprint(df_can.head(3))\n\n         Type    Coverage       OdName  AREA AreaName   REG          RegName  \\\n0  Immigrants  Foreigners  Afghanistan   935     Asia  5501    Southern Asia   \n1  Immigrants  Foreigners      Albania   908   Europe   925  Southern Europe   \n2  Immigrants  Foreigners      Algeria   903   Africa   912  Northern Africa   \n\n   DEV             DevName  1980  ...  2004  2005  2006  2007  2008  2009  \\\n0  902  Developing regions    16  ...  2978  3436  3009  2652  2111  1746   \n1  901   Developed regions     1  ...  1450  1223   856   702   560   716   \n2  902  Developing regions    80  ...  3616  3626  4807  3623  4005  5393   \n\n   2010  2011  2012  2013  \n0  1758  2203  2635  2004  \n1   561   539   620   603  \n2  4752  4325  3774  4331  \n\n[3 rows x 43 columns]\n\n\n\n# clean up the dataset to remove unnecessary columns (eg. REG) \ndf_can.drop(['AREA','REG','DEV','Type','Coverage'], axis=1, inplace=True)\n\n# let's rename the columns so that they make sense\ndf_can.rename(columns={'OdName':'Country', 'AreaName':'Continent','RegName':'Region'}, inplace=True)\n\n# for sake of consistency, let's also make all column labels of type string\ndf_can.columns = list(map(str, df_can.columns))\n\n# years that we will be using in this lesson - useful for plotting later on\nyears = list(map(str, range(1980, 2014)))\n\n# add total column\ndf_can['Total'] = df_can[years].sum(axis=1)\n\n#control dimensions\nprint ('data dimensions:', df_can.shape)\n\ndata dimensions: (195, 39)\n\n\nIn order to create a Choropleth map, we need a GeoJSON file that defines the areas/boundaries of the state, county, or country that we are interested in. In our case, since we are endeavoring to create a world map, we want a GeoJSON that defines the boundaries of all world countries. For your convenience, we will be providing you with this file, so let’s go ahead and load it.\n\nimport io\nimport json\n\n# Opening JSON file\nf = open('../data/world_countries.json',)\nworld_geo = json.load(f)\nf.close()\n\n\n# create a plain world map\nworld_map = folium.Map(location=[0, 0], zoom_start=2)\n\nAnd now to create a Choropleth map, we will use the choropleth method with the following main parameters:\n\ngeo_data, which is the GeoJSON file.\ndata, which is the dataframe containing the data.\ncolumns, which represents the columns in the dataframe that will be used to create the Choropleth map.\nkey_on, which is the key or variable in the GeoJSON file that contains the name of the variable of interest. To determine that, you will need to open the GeoJSON file using any text editor and note the name of the key or variable that contains the name of the countries, since the countries are our variable of interest. In this case, name is the key in the GeoJSON file that contains the name of the countries. Note that this key is case_sensitive, so you need to pass exactly as it exists in the GeoJSON file.\n\n\n# generate choropleth map using the total immigration of each country to Canada from 1980 to 2013\nworld_map.choropleth(\n    geo_data=world_geo,\n    data=df_can,\n    columns=['Country', 'Total'],\n    key_on='feature.properties.name',\n    fill_color='YlOrRd', \n    fill_opacity=0.7, \n    line_opacity=0.2,\n    legend_name='Immigration to Canada'\n)\n\n# display map\nworld_map\n\nMake this Notebook Trusted to load map: File -> Trust Notebook\n\n\nAs per our Choropleth map legend, the darker the color of a country and the closer the color to red, the higher the number of immigrants from that country. Accordingly, the highest immigration over the course of 33 years (from 1980 to 2013) was from China, India, and the Philippines, followed by Poland, Pakistan, and interestingly, the US.\nNotice how the legend is displaying a negative boundary or threshold. Let’s fix that by defining our own thresholds and starting with 0 instead of -6,918\n\n# create a numpy array of length 6 and has linear spacing from the minimum total immigration to the maximum total immigration\nthreshold_scale = np.linspace(df_can['Total'].min(),\n                              df_can['Total'].max(),\n                              6, dtype=int)\nthreshold_scale = threshold_scale.tolist() # change the numpy array to a list\nthreshold_scale[-1] = threshold_scale[-1] + 1 # make sure that the last value of the list is greater than the maximum immigration\n\n# let Folium determine the scale.\nworld_map = folium.Map(location=[0, 0], zoom_start=2)\nworld_map.choropleth(\n    geo_data=world_geo,\n    data=df_can,\n    columns=['Country', 'Total'],\n    key_on='feature.properties.name',\n    threshold_scale=threshold_scale,\n    fill_color='YlOrRd', \n    fill_opacity=0.7, \n    line_opacity=0.2,\n    legend_name='Immigration to Canada',\n    reset=True\n)\nworld_map\n\nMake this Notebook Trusted to load map: File -> Trust Notebook"
  },
  {
    "objectID": "code/4_dashbords.html",
    "href": "code/4_dashbords.html",
    "title": "5  Creating Dashbords with Plotly and Dash",
    "section": "",
    "text": "Web-based dashboarding can be done in python with:\n\nPlotly | Dash\nPanel\nvoila\nStreamlit\n\nDashbord tools:\n\nbokeh\nipywidgets (useful for jupyter)\nmatplotlib\nbowtie\nFlask\n\nFor more information about Dashboards, visit the following links:\n\nPython dashboarding tools\nJohn Snow’s data journalism\n\nTo learn more about using Plotly to create dashboards, explore\n\nPlotly python\nPlotly graph objects with example\nPlotly express\nAPI reference\n\nHere are additional useful resources:\n\nPlotly cheatsheet\nPlotly community\nRelated blogs\nOpen-source datasets"
  },
  {
    "objectID": "code/4_dashbords.html#plotly-basics-scatter-line-bar-bubble-histogram-pie-sunburst",
    "href": "code/4_dashbords.html#plotly-basics-scatter-line-bar-bubble-histogram-pie-sunburst",
    "title": "5  Creating Dashbords with Plotly and Dash",
    "section": "5.2 Plotly basics: scatter, line, bar, bubble, histogram, pie, sunburst",
    "text": "5.2 Plotly basics: scatter, line, bar, bubble, histogram, pie, sunburst\nOur data:\nThe Reporting Carrier On-Time Performance Dataset contains information on approximately 200 million domestic US flights reported to the United States Bureau of Transportation Statistics. The dataset contains basic information about each flight (such as date, time, departure airport, arrival airport) and, if applicable, the amount of time the flight was delayed and information about the reason for the delay. This dataset can be used to predict the likelihood of a flight arriving on time.\nPreview data, dataset metadata, and data glossary here.\n\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport kaleido\n\n\n#read in data\nairline_data = pd.read_csv(\"../data/airline_data.csv\", encoding = \"ISO-8859-1\",dtype={'Div1Airport': str, 'Div1TailNum': str,'Div2Airport': str, 'Div2TailNum': str})\n\n#check the data\nprint(airline_data.head())\n\n# Shape of the data\nprint(airline_data.shape)\n\n   Unnamed: 0  Year  Quarter  Month  DayofMonth  DayOfWeek  FlightDate  \\\n0     1295781  1998        2      4           2          4  1998-04-02   \n1     1125375  2013        2      5          13          1  2013-05-13   \n2      118824  1993        3      9          25          6  1993-09-25   \n3      634825  1994        4     11          12          6  1994-11-12   \n4     1888125  2017        3      8          17          4  2017-08-17   \n\n  Reporting_Airline  DOT_ID_Reporting_Airline IATA_CODE_Reporting_Airline  \\\n0                AS                     19930                          AS   \n1                EV                     20366                          EV   \n2                UA                     19977                          UA   \n3                HP                     19991                          HP   \n4                UA                     19977                          UA   \n\n   ... Div4WheelsOff  Div4TailNum  Div5Airport  Div5AirportID  \\\n0  ...           NaN          NaN          NaN            NaN   \n1  ...           NaN          NaN          NaN            NaN   \n2  ...           NaN          NaN          NaN            NaN   \n3  ...           NaN          NaN          NaN            NaN   \n4  ...           NaN          NaN          NaN            NaN   \n\n   Div5AirportSeqID Div5WheelsOn Div5TotalGTime Div5LongestGTime  \\\n0               NaN          NaN            NaN              NaN   \n1               NaN          NaN            NaN              NaN   \n2               NaN          NaN            NaN              NaN   \n3               NaN          NaN            NaN              NaN   \n4               NaN          NaN            NaN              NaN   \n\n   Div5WheelsOff Div5TailNum  \n0            NaN         NaN  \n1            NaN         NaN  \n2            NaN         NaN  \n3            NaN         NaN  \n4            NaN         NaN  \n\n[5 rows x 110 columns]\n(27000, 110)\n\n\n\n#randomly subsample 500 datapoints\n#we set the random state to be 42 to always get the same results\ndata = airline_data.sample(n=500, random_state=42)\n\n#control\ndata.shape\n\n(500, 110)\n\n\n\n5.2.1 plotly.graph_objects\n\n5.2.1.1 Scatterplots\nLearn more about usage of scatter plot here\nIdea: How departure time changes with respect to airport distance\n\n# First we create a figure using go.Figure and adding trace to it through go.scatter\nfig = go.Figure(data = go.Scatter(x = data['Distance'], y = data['DepTime'], mode = 'markers', marker = dict(color = 'red')))\n\n# Updating layout through `update_layout`. Here we are adding title to the plot and providing title to x and y axis.\nfig.update_layout(title = 'Distance vs Departure time', xaxis_title = 'Distance', yaxis_title = 'DepTime')\n\n# Display the figure\nfig.show()\n\n\n                                                \n\n\n\n\n5.2.1.2 Lineplots\nLearn more about line plot here\n\n# Group the data by Month and compute average over arrival delay time.\nline_data = data.groupby('Month')['ArrDelay'].mean().reset_index()\nline_data.head(3)\n\n\n\n\n\n  \n    \n      \n      Month\n      ArrDelay\n    \n  \n  \n    \n      0\n      1\n      2.232558\n    \n    \n      1\n      2\n      2.687500\n    \n    \n      2\n      3\n      10.868421\n    \n  \n\n\n\n\n\nCreate a line plot with x-axis being the month and y-axis being computed average delay time. Update plot title, xaxis, and yaxis title.\nScatter and line plot vary by updating mode parameter.\n\n\n#create figure\nfig = go.Figure(data = go.Scatter(x = line_data['Month'], y = line_data['ArrDelay'], mode = 'lines', marker = dict(color='green')))\n\n#update the labels\nfig.update_layout(title = 'Arrival delay by month', xaxis_title = 'Month', yaxis_title = 'Arrival Delay')\n\n#plot\nfig.show()"
  },
  {
    "objectID": "code/4_dashbords.html#plotly.express",
    "href": "code/4_dashbords.html#plotly.express",
    "title": "5  Creating Dashbords with Plotly and Dash",
    "section": "5.3 plotly.express",
    "text": "5.3 plotly.express\n\n5.3.1 Bar chart\nLearn more about bar chart here\nIdea: Extract number of flights from a specific airline that goes to a destination\n\n# Group the data by destination state and reporting airline. Compute total number of flights in each combination\nbar_data = data.groupby(['DestState'])['Flights'].sum().reset_index()\nbar_data.head(3)\n\n\n\n\n\n  \n    \n      \n      DestState\n      Flights\n    \n  \n  \n    \n      0\n      AK\n      4.0\n    \n    \n      1\n      AL\n      3.0\n    \n    \n      2\n      AZ\n      8.0\n    \n  \n\n\n\n\n\nfig = px.bar(bar_data, x = 'DestState', y = 'Flights', title = 'Total number of flights to the destination state split by reporting airline')\nfig.show()\n\n\n                                                \n\n\n\n\n5.3.2 Bubble chart\nLearn more about bubble chart here\nIdea: Get number of flights as per reporting airline\n\n# Group the data by reporting airline and get number of flights\nbub_data = data.groupby('Reporting_Airline')['Flights'].sum().reset_index()\nbub_data.head(3)\n\n\n\n\n\n  \n    \n      \n      Reporting_Airline\n      Flights\n    \n  \n  \n    \n      0\n      9E\n      5.0\n    \n    \n      1\n      AA\n      57.0\n    \n    \n      2\n      AS\n      14.0\n    \n  \n\n\n\n\n\nfig = px.scatter(bub_data, x = 'Reporting_Airline', y = 'Flights', size = 'Flights', hover_name = 'Reporting_Airline', title = 'Total number of flights by reporting airline')\nfig.show()\n\n\n                                                \n\n\n\n5.3.2.1 Histogram\nLearn more about histogram here\nIdea: Get distribution of arrival delay\n\n# Set missing values to 0\ndata['ArrDelay'] = data['ArrDelay'].fillna(0)\n\n\n# Set missing values to 0\nfig = px.histogram(data, x = 'ArrDelay')\nfig.show()\n\n\n                                                \n\n\n\n\n5.3.2.2 Pie Chart\nLearn more about pie chart here\nIdea: Proportion of distance group by month (month indicated by numbers)\n\n# Use px.pie function to create the chart. Input dataset. \n# Values parameter will set values associated to the sector. 'Month' feature is passed to it.\n# labels for the sector are passed to the `names` parameter.\nfig = px.pie(data, values='Month', names='DistanceGroup', title='Distance group proportion by month')\nfig.show()\n\n\n                                                \n\n\n\n\n5.3.2.3 Writing image to file\nSave as static image via kaleido:\nNotice: Doesn’t work in RStudio yet but works via quarto render.\n\nfig.write_image(\"../images/fig1.svg\", engine=\"kaleido\")\n\n\n\n5.3.2.4 Sunburst Charts\nLearn more about sunburst chart here\nIdea: Hierarchical view in order of month and destination state holding value of number of flights\n\nCreate sunburst chart using px.sunburst.\nDefine hierarchy of sectors from root to leaves in path parameter. Here, we go from Month to DestStateName feature.\nSet sector values in values parameter. Here, we can pass in Flights feature.\nShow the figure.\n\n\nfig = px.sunburst(data, path = ['Month', 'DestStateName'], values = 'Flights')\nfig.show()"
  },
  {
    "objectID": "code/4_dashbords.html#dash",
    "href": "code/4_dashbords.html#dash",
    "title": "5  Creating Dashbords with Plotly and Dash",
    "section": "5.4 Dash",
    "text": "5.4 Dash\nDash is an open source framework for building data visualization interfaces.\nIn this lab you will utilize an Integrated Development Environment (IDE) based on Theia (an open source IDE platform similar to VS Code) to develop and run Python code.\nGoal\nCreate a dashboard that displays the percentage of flights running under specific distance group. Distance group is the distance intervals, every 250 miles, for flight segment. If the flight covers to 500 miles, it will be under distance group 2 (250 miles + 250 miles).\nOur dashboard application consists of three components:\n\nTitle of the application\nDescription of the application\nChart conveying the proportion of distance group by month\n\nFor this to work, we need to do the following (plus any libraries we require for plotting): python3 -m pip install pandas dash and pip3 install httpx==0.20 dash plotly.\nFor this to work, we started a new python script with touch dash_basics.py which we opened with VScode typing this into the terminal: code dash_basics.py.\n\n5.4.1 Prep the data\nThe first task is the data preparation (what we have done before) and we:\n\nImporting necessary libraries\nReading and sampling 500 random data points\nGet the chart ready\n\nTo do this, we added the following into our python script\n\n# Import required packages\nimport pandas as pd\nimport plotly.express as px\nimport dash\nimport dash_html_components as html\nimport dash_core_components as dcc\n\n# Read the airline data into pandas dataframe\nairline_data =  pd.read_csv('https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-DV0101EN-SkillsNetwork/Data%20Files/airline_data.csv', \n                            encoding = \"ISO-8859-1\",\n                            dtype={'Div1Airport': str, 'Div1TailNum': str, \n                                   'Div2Airport': str, 'Div2TailNum': str})\n\n# Randomly sample 500 data points. Setting the random state to be 42 so that we get same result.\ndata = airline_data.sample(n=500, random_state=42)\n\n# Pie Chart Creation\nfig = px.pie(data, values='Flights', names='DistanceGroup', title='Distance group proportion by flights')\n\n\n\n5.4.2 Create dash application and get the layout skeleton\nNext, we create a skeleton for our dash application. Our dashboard application has three components as seen before:\n\nTitle of the application\nDescription of the application\nChart conveying the proportion of distance group by month\nMapping to the respective Dash HTML tags:\n\nTo do this a:\n\nTitle is added using html.H1() tag, which holds the application title.\nDescription is added using html.P() tag, which holds the description of the application. In this example, the style parameter provided below to makes the title center aligned, with color code #503D36, and font-size as 40\nChart is added using dcc.Graph() tag to add the fig we generated above/\n\nTo do this, the following was added:\n\n# Create a dash application\napp = dash.Dash(__name__)\n\n# Get the layout of the application and adjust it.\n# Create an outer division using html.Div and add title to the dashboard using html.H1 component\n# Add description about the graph using HTML P (paragraph) component\n# Finally, add graph component.\napp.layout = html.Div(children=[html.H1('Airline Dashboard',style={'textAlign': 'center', 'color': '#503D36', 'font-size': 40}),\n                                html.P('Proportion of distance group (250 mile distance interval group) by flights.', style={'textAlign':'center', 'color': '#F57241'}),\n                                dcc.Graph(figure=fig),\n                                               \n                    ])\n\n# Run the application                   \nif __name__ == '__main__':\n    app.run_server()\n\nA step-by-step guide with pictures is also found here: ../tutorials/4.5_Dash_Basics.md.html\nThe dash script can be run with /opt/anaconda3/bin/python3.7 dash_basics.py and is found at tutorials/dash_basics.py\nOther useful links:\n\nComplete dash user guide\nDash core components\nDash HTML components\nDash community forum\nRelated blogs"
  },
  {
    "objectID": "code/4_dashbords.html#add-interactivity-user-input-and-callbacks",
    "href": "code/4_dashbords.html#add-interactivity-user-input-and-callbacks",
    "title": "5  Creating Dashbords with Plotly and Dash",
    "section": "5.5 Add interactivity: user input and callbacks",
    "text": "5.5 Add interactivity: user input and callbacks\nA callback function is a python function that is automatically called by Dash whenever an input component’s property changes. Callback function is decorated with @app.callback decorator.\nWhenever there is a change in the input component value, callback function wrapped by the decorator is called followed by the update to the output component children in the application layout.\n\nPython decorators reference 1\nPython decorators reference 2\nCallbacks with example\nDash app gallery\nDash community components\n\nThe tutorial for this section can be found in ../tutorials/4.7_Dash_Interactivity.md.html\nThe goal of this exercise is to extract average monthly arrival delay time and see how it changes over the year. Year range is from 2010 to 2020. Our dashboard application will consist of three components:\n\nTitle of the application\nComponent to enter input year\nChart conveying the average monthly arrival delay\n\nTo do this, we create a new python script with touch ../tutorials/dash_interactivity.py and open it with code ../tutorials/dash_interactivity.py\n\n5.5.1 Read in the data\nAdded this:\n\n# Import required libraries\nimport pandas as pd\nimport plotly.graph_objects as go\nimport dash\nimport dash_html_components as html\nimport dash_core_components as dcc\nfrom dash.dependencies import Input, Output\n\n# Read the airline data into pandas dataframe\nairline_data =  pd.read_csv('https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-DV0101EN-SkillsNetwork/Data%20Files/airline_data.csv', \n                            encoding = \"ISO-8859-1\",\n                            dtype={'Div1Airport': str, 'Div1TailNum': str, \n                                   'Div2Airport': str, 'Div2TailNum': str})\n\n\n\n5.5.2 Create dash application and get the layout skeleton\nMapping to the respective Dash HTML tags:\n\nTitle added using html.H1() tag, see more here\nLayout division added using html.Div() and input component added using dcc.Input() tag inside the - layout division.\nLayout division added using html.Div() and chart added using dcc.Graph() tag inside the layout division.\n\nBelow, we:\n\nTitle as Airline Performance Dashboard\nUse style parameter and make the title center aligned, with color code #503D36, and font-size as 40. Check More about HTML section here.\nUpdate dcc.Input component id as input-year, default value as 2010, and type as number. Use style parameter and assign height of the input box to be 50px and font-size to be 35.\nUse style parameter and assign font-size as 40 for the whole division.\nAdd dcc.Graph() component to the second division.\nUpdate dcc.Graph component id as line-plot.\n\n\n# Create a dash application\napp = dash.Dash(__name__)\n\n# Get the layout of the application and adjust it.\n# Create an outer division using html.Div and add title to the dashboard using html.H1 component\n# Add a html.Div and core input text component\n# Finally, add graph component.\napp.layout = html.Div(children=[ html.H1('Airline Performance Dashboard',style={'textAlign': 'center', \n                                'color': '#503D36','font-size': 40}),\n                                html.Div([\"Input Year: \", dcc.Input(id='input-year', value='2010', \n                                type='number', style={'height':'50px', 'font-size': 35}),], \n                                style={'font-size': 40}),\n                                html.Br(),\n                                html.Br(),\n                                html.Div(dcc.Graph(id='line-plot')),\n                                ])\n\n\n\n5.5.3 Add the application callback function\nThe core idea of this application is to get year as user input and update the dashboard in real-time. We will be using callback function for the same.\nSteps:\n\nDefine the callback decorator\nDefine the callback function that uses the input provided to perform the computation\nCreate graph and return it as an output\nRun the application\n\nCallback decorator\n\nRefer examples provided here\nUpdate output component id parameter with the id provided in the dcc.Graph() component and component property as figure.\nUpdate input component id parameter with the id provided in the dcc.Input() component and component property as value.\n\nCallback function\n\nUpdate data parameter of the go.Figure() with the scatter plot.\nRefer here.\nSample syntax below: go.Scatter(x='----', y='----', mode='-----', marker='----)\nUpdate x as line_data[‘Month’], y as line_data[‘ArrDelay’], mode as lines, and marker as dict(color=‘green’).\nUpdate fig.update_layout with title, xaxis_title, and yaxis_title parameters.\nTitle as Month vs Average Flight Delay Time\nxaxis_title as Month\nyaxis_title as ArrDelay\nRefer the update layout function here.\n\n\n# add callback decorator\n@app.callback(Output(component_id='line-plot', component_property='figure'),\n               Input(component_id='input-year', component_property='value'))\n\n# Add computation to callback function and return graph\ndef get_graph(entered_year):\n    # Select data based on the entered year\n    df =  airline_data[airline_data['Year']==int(entered_year)]\n    \n    # Group the data by Month and compute average over arrival delay time.\n    line_data = df.groupby('Month')['ArrDelay'].mean().reset_index()\n    \n    # \n    fig = go.Figure(data=go.Scatter(x=line_data['Month'], y=line_data['ArrDelay'], mode='lines', marker=dict(color='green')))\n    fig.update_layout(title='Month vs Average Flight Delay Time', xaxis_title='Month', yaxis_title='ArrDelay')\n    return fig\n\n# Run the app\nif __name__ == '__main__':\n    app.run_server()\n\nRun with /opt/anaconda3/bin/python3.7 dash_interactivity.py"
  },
  {
    "objectID": "code/4_dashbords.html#flight-delay-time-statistics-dashboard",
    "href": "code/4_dashbords.html#flight-delay-time-statistics-dashboard",
    "title": "5  Creating Dashbords with Plotly and Dash",
    "section": "5.6 Flight Delay Time Statistics Dashboard",
    "text": "5.6 Flight Delay Time Statistics Dashboard\nInside this dashbord, we want to have the following components:\n\nMonthly average carrier delay by reporting airline for the given year.\nMonthly average weather delay by reporting airline for the given year.\nMonthly average national air system delay by reporting airline for the given year.\nMonthly average security delay by reporting airline for the given year.\nMonthly average late aircraft delay by reporting airline for the given year.\nNOTE: Year range should be between 2010 and 2020\n\nThe output should show the following:\n\nTitle of the application\nComponent to enter input year\n5 Charts conveying the different types of flight delay. Chart section is divided into three segments.\n\nCarrier and Weather delay in the first segment\nNational air system and Security delay in the second segment\nLate aircraft delay in the third segment\n\n\nLet’s start out script with code flight_details.py.\n\n5.6.1 Read the data\n\n# Import required libraries\nimport pandas as pd\nimport plotly.graph_objects as go\nimport dash\nimport dash_html_components as html\nimport dash_core_components as dcc\nfrom dash.dependencies import Input, Output\nimport plotly.express as px\n\n# Read the airline data into pandas dataframe\nairline_data =  pd.read_csv('https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-DV0101EN-SkillsNetwork/Data%20Files/airline_data.csv', \n                            encoding = \"ISO-8859-1\",\n                            dtype={'Div1Airport': str, 'Div1TailNum': str, \n                                   'Div2Airport': str, 'Div2TailNum': str})\n\n\n\n5.6.2 Create dash application and get the layout skeleton\nMapping to the respective Dash HTML tags:\n\nTitle added using html.H1() tag\nLayout division added using html.Div() and input component added using dcc.Input() tag inside the layout division.\n5 charts split into three segments. Each segment has a layout division added using html.Div() and chart added using dcc.Graph() tag inside the layout division.\n\nThe raw code looks like this\n\n# Create a dash application\napp = dash.Dash(__name__)\n\n# Build dash app layout\napp.layout = html.Div(children=[ html.H1(),\n                                html.Div([\"Input Year: \", dcc.Input()],\n                                style={'font-size': 30}),\n                                html.Br(),\n                                html.Br(), \n                                html.Div([\n                                        html.Div(),\n                                        html.Div()\n                                ], style={'display': 'flex'}),\n    \n                                html.Div([\n                                        html.Div(),\n                                        html.Div()\n                                ], style={'display': 'flex'}),\n                                \n                                html.Div(, style={'width':'65%'})\n                                ])\n\nFirst, we add the following:\n\nTitle as Flight Delay Time Statistics, align text as center, color as #503D36, and font size as 30.\nUpdate dcc.Input component id as input-year, default value as 2010, and type as number. Use style parameter and assign height of the input box to be 35px and font-size to be 30.\n\nSegment 1 is the first html.Div(). We have two inner division where first two graphs will be placed. The skeleton looks like this:\n\nhtml.Div([\n          html.Div(),\n          html.Div()\n         ], style={'display': 'flex'}),\n\nFirst inner division: - Add dcc.Graph() component. - Update dcc.Graph component id as carrier-plot.\nSecond inner division - Add dcc.Graph() component. - Update dcc.Graph component id as weather-plot.\nSegment 2 is the second html.Div(). We have two inner division where the next two graphs will be placed.\nFirst inner division - Add dcc.Graph() component. - Update dcc.Graph component id as nas-plot.\nSecond inner division - Add dcc.Graph() component. - Update dcc.Graph component id as security-plot.\nSegment 3 is the last html.Div(): html.Div(, style={'width':'65%'})\n- Add dcc.Graph() component to the first inner division.\n- Update dcc.Graph component id as late-plot.\n\n# Build dash app layout\napp.layout = html.Div(children=[ html.H1('Flight delay time statistics', style={'textAlign':'center', 'color':'#503D36', 'font-size':40}),\n                                html.Div([\"Input Year: \", dcc.Input(id='input-year', value='2010', type='number', style={'height':'50px', 'font-size':35})],\n                                style={'font-size': 30}),\n                                html.Br(),\n                                html.Br(), \n                                html.Div([\n                                        html.Div(dcc.Graph(id='carrier-plot')),\n                                        html.Div(dcc.Graph(id='weather-plot'))\n                                ], style={'display': 'flex'}),\n    \n                                html.Div([\n                                        html.Div(dcc.Graph(id='nas-plot')),\n                                        html.Div(dcc.Graph(id='security-plot'))\n                                ], style={'display': 'flex'}),\n                                \n                                html.Div(dcc.Graph(id='late-plot'), style={'width':'65%'})\n                                ])\n\n\n\n5.6.3 Review and add supporting function\nBelow is the function that gets input year and data, perform computation for creating charts and plots.\n\n\"\"\" Compute_info function description\n\nThis function takes in airline data and selected year as an input and performs computation for creating charts and plots.\n\nArguments:\n    airline_data: Input airline data.\n    entered_year: Input year for which computation needs to be performed.\n    \nReturns:\n    Computed average dataframes for carrier delay, weather delay, NAS delay, security delay, and late aircraft delay.\n\n\"\"\"\ndef compute_info(airline_data, entered_year):\n    # Select data\n    df =  airline_data[airline_data['Year']==int(entered_year)]\n    # Compute delay averages\n    avg_car = df.groupby(['Month','Reporting_Airline'])['CarrierDelay'].mean().reset_index()\n    avg_weather = df.groupby(['Month','Reporting_Airline'])['WeatherDelay'].mean().reset_index()\n    avg_NAS = df.groupby(['Month','Reporting_Airline'])['NASDelay'].mean().reset_index()\n    avg_sec = df.groupby(['Month','Reporting_Airline'])['SecurityDelay'].mean().reset_index()\n    avg_late = df.groupby(['Month','Reporting_Airline'])['LateAircraftDelay'].mean().reset_index()\n    return avg_car, avg_weather, avg_NAS, avg_sec, avg_late\n\n\n\n5.6.4 Add the application callback function\nScaffold:\n\n# Callback decorator\n@app.callback( [\n               Output(component_id='carrier-plot', component_property='figure'),\n               ---\n               --- \n               ---\n               ---\n               ],\n               Input(....))\n# Computation to callback function and return graph\ndef get_graph(entered_year):\n    \n    # Compute required information for creating graph from the data\n    avg_car, avg_weather, avg_NAS, avg_sec, avg_late = compute_info(airline_data, entered_year)\n            \n    # Line plot for carrier delay\n    carrier_fig = px.line(avg_car, x='Month', y='CarrierDelay', color='Reporting_Airline', title='Average carrier delay time (minutes) by airline')\n    # Line plot for weather delay\n    weather_fig = ------\n    # Line plot for nas delay\n    nas_fig = ------\n    # Line plot for security delay\n    sec_fig = ------\n    # Line plot for late aircraft delay\n    late_fig = ------\n            \n    return[carrier_fig, weather_fig, nas_fig, sec_fig, late_fig]\n\n# Run the app\nif __name__ == '__main__':\n    app.run_server()\n\nCallback decorator\n\nRefer examples provided here\nWe have 5 output components added in a list. Update output component id parameter with the ids provided in the dcc.Graph() component and set the component property as figure. One sample has been added to the skeleton.\nUpdate input component id parameter with the id provided in the dcc.Input() component and component property as value.\n\nCallback function\nNext is to update the get_graph function. We have already added a function compute_info that will perform computation on the data using the input.\nMapping the returned value from the function compute_info to graph:\n\navg_car - input for carrier delay -avg_weather - input for weather delay -avg_NAS - input for NAS delay -avg_sec - input for security delay -avg_late - input for late aircraft delay -Code has been provided for plotting carrier delay. Follow the same process and use the above mapping to get plots for other 4 delays.\n\n\n# Import required libraries\nimport pandas as pd\nimport plotly.graph_objects as go\nimport dash\nfrom dash import html\nfrom dash import dcc\nfrom dash.dependencies import Input, Output\nimport plotly.express as px\n\n# Read the airline data into pandas dataframe\nairline_data =  pd.read_csv('https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-DV0101EN-SkillsNetwork/Data%20Files/airline_data.csv', \n                            encoding = \"ISO-8859-1\",\n                            dtype={'Div1Airport': str, 'Div1TailNum': str, \n                                   'Div2Airport': str, 'Div2TailNum': str})\n\n\n# Create a dash application\napp = dash.Dash(__name__)\n\n# Build dash app layout\napp.layout = html.Div(children=[ html.H1('Flight delay time statistics', style={'textAlign':'center', 'color':'#503D36', 'font-size':40}),\n                                html.Div([\"Input Year: \", dcc.Input(id='input-year', value='2010', type='number', style={'height':'50px', 'font-size':35})],\n                                style={'font-size': 30}),\n                                html.Br(),\n                                html.Br(), \n                                html.Div([\n                                        html.Div(dcc.Graph(id='carrier-plot')),\n                                        html.Div(dcc.Graph(id='weather-plot'))\n                                ], style={'display': 'flex'}),\n    \n                                html.Div([\n                                        html.Div(dcc.Graph(id='nas-plot')),\n                                        html.Div(dcc.Graph(id='security-plot'))\n                                ], style={'display': 'flex'}),\n                                \n                                html.Div(dcc.Graph(id='late-plot'), style={'width':'65%'})\n                                ])\n\n\n\"\"\" Compute_info function description\n\nThis function takes in airline data and selected year as an input and performs computation for creating charts and plots.\n\nArguments:\n    airline_data: Input airline data.\n    entered_year: Input year for which computation needs to be performed.\n    \nReturns:\n    Computed average dataframes for carrier delay, weather delay, NAS delay, security delay, and late aircraft delay.\n\n\"\"\"\ndef compute_info(airline_data, entered_year):\n    # Select data\n    df =  airline_data[airline_data['Year']==int(entered_year)]\n    # Compute delay averages\n    avg_car = df.groupby(['Month','Reporting_Airline'])['CarrierDelay'].mean().reset_index()\n    avg_weather = df.groupby(['Month','Reporting_Airline'])['WeatherDelay'].mean().reset_index()\n    avg_NAS = df.groupby(['Month','Reporting_Airline'])['NASDelay'].mean().reset_index()\n    avg_sec = df.groupby(['Month','Reporting_Airline'])['SecurityDelay'].mean().reset_index()\n    avg_late = df.groupby(['Month','Reporting_Airline'])['LateAircraftDelay'].mean().reset_index()\n    return avg_car, avg_weather, avg_NAS, avg_sec, avg_late\n\n# Callback decorator\n@app.callback( [\n               Output(component_id='carrier-plot', component_property='figure'),\n               Output(component_id='weather-plot', component_property='figure'),\n               Output(component_id='nas-plot', component_property='figure'), \n               Output(component_id='security-plot', component_property='figure'),\n               Output(component_id='late-plot', component_property='figure'),\n               ],\n               Input(component_id='input-year', component_property='value'))\n\n# Computation to callback function and return graph\ndef get_graph(entered_year):\n    \n    # Compute required information for creating graph from the data\n    avg_car, avg_weather, avg_NAS, avg_sec, avg_late = compute_info(airline_data, entered_year)\n            \n    # Line plot for carrier delay\n    carrier_fig = px.line(avg_car, x='Month', y='CarrierDelay', color='Reporting_Airline', title='Average carrier delay time (minutes) by airline')\n    # Line plot for weather delay\n    weather_fig = px.line(avg_weather, x='Month', y='WeatherDelay', color='Reporting_Airline', title='Average weather delay time (minutes) by airline')\n    # Line plot for nas delay\n    nas_fig = px.line(avg_NAS, x='Month', y='NASDelay', color='Reporting_Airline', title='Average NAS delay time (minutes) by airline')\n    # Line plot for security delay\n    sec_fig = px.line(avg_sec, x='Month', y='SecurityDelay', color='Reporting_Airline', title='Average security delay time (minutes) by airline')\n    # Line plot for late aircraft delay\n    late_fig = px.line(avg_late, x='Month', y='LateAircraftDelay', color='Reporting_Airline', title='Average late aircraft delay time (minutes) by airline')\n            \n    return[carrier_fig, weather_fig, nas_fig, sec_fig, late_fig]\n\n# Run the app\nif __name__ == '__main__':\n    app.run_server()\n\nRun with /opt/anaconda3/bin/python3.7 flight_details.py"
  }
]