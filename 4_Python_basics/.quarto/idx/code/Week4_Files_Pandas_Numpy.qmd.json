{"title":"Working with data in python","markdown":{"headingText":"Working with data in python","containsRefs":false,"markdown":"\n## The open function\n\n### Reading Files with Open\n\n\n\n```{python}\n#|  echo: false\n#|  results: hide\n#|  warning: false\n\n##Download example data.\n\n#import urllib.request\n#url = 'https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%204/data/Example1.txt.txt'\n#filename = 'Example1.txt.txt'\n#urllib.request.urlretrieve(url, filename)\n\n## Download Example file\n# !wget -O data/Example1.txt.txt https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%204/data/Example1.txt.txt\n```\n\n```{python}\n#|  warning: false\n#|  echo: false\n\n#ensure that plots get rendered, will give a warning, but nothing to worry about\n#%matplotlib inline  \n```\n\nOne way to read or write a file in Python is to use the built-in open function. The open function provides a File object that contains the methods and attributes you need in order to read, save, and manipulate the file. In this notebook, we will only cover .txt files. \n\n- The first argument is the filepath and the filename we want to open\n- The second parameter is the mode:\n    - r: open a file for reading\n    - w: open a file for writing\n    - a: open a file for appending\n    - r+ : Reading and writing. Cannot truncate the file.\n    - w+ : Writing and reading. Truncates the file.\n    - a+ : Appending and Reading. Creates a new file, if none exists.\n    \n- We store this in a file object, i.e. File1 and we can use the file object to obtain information about the file\n- You should always close the file object using the method close.\n\nPython file method close() closes the opened file. A closed file cannot be read or written any more. Any operation, which requires that the file be opened will raise a ValueError after the file has been closed. Calling close() more than once is allowed.\n\n```{python}\n#open a file\nFile1 = open(\"../data/Example1.txt\", \"r\")\n\n#get the name of the file\nprint(File1.name)\n\n#see what mode the object is in\nprint(File1.mode)\n\n#get the file contents\nprint(File1.read())\n\n#get they type of the file\ntype(File1.read())\n\n#close the file\nFile1.close()\n```\n\nSince using .close() can be tedious, we can use an alternative, the with statement. This is a better alternative, since the with statement will automatically close the file.\n\n```{python}\nwith open(\"../data/Example1.txt\", \"r\") as File1:\n    #code will be performed in the indented code block\n    #The method \"read\" stores the values of the file in the variable \"file_stuff\" as a string\n    file_stuff = File1.read()\n    print(file_stuff)\n    print(File1.mode)\n```\n\nNotice, that we didn’t have to write “file.close()”. That will automatically be called.\n\nWe can output every line as an element in a list using the method \"readlines.\"\n\n```{python}\nwith open(\"../data/Example1.txt\", \"r\") as File1:\n    file_stuff = File1.readlines()\n    print(file_stuff)\n```\n\nWe don’t have to read the entire file, for example, we can read the first 4 characters by entering three as a parameter to the method .read():\n\n```{python}\n# Read first four characters\nwith open(\"../data/Example1.txt\", \"r\") as file1:\n    print(file1.read(4))\n```\n\n\nUse a loop to print out each line individually\n\n```{python}\nwith open(\"../data/Example1.txt\", \"r\") as File1:\n    for i in File1:\n        print(i)\n```\n\nWe can also read all lines and save them as a list\n\n```{python}\n# Read all lines and save as a list\nwith open(\"../data/Example1.txt\", \"r\") as file1:\n    FileasList = file1.readlines()\n    \n#print the first line    \nFileasList[0]\n```\n\n\n\n### Writting Files with Open\n\nCreate a new, empty example as follows:\n\n**Beware**: If we have a file with that filename in our directory, it will be overwritten!\n\n```{python}\n#create example.txt in the specified dir\nwith open(\"../data/Example2.txt\", \"w\") as File1:\n    #add something into our file\n    File1.write(\"This is line A\\n\")\n    File1.write(\"This is line B\\n\")\n```\n\nWe can also have a list and write this to a file\n\n```{python}\nLines = [\"This is line A\\n\", \"This is line B\\n\", \"This is line C\\n\"]\n\nwith open(\"../data/Example2.txt\", \"w\") as File1:\n    for i in Lines:\n        File1.write(i)\n```\n\n\n### Appending lines to a new file\n\nAppend will not create a new file but append lines to an existing file.\n\n```{python}\nwith open(\"../data/Example2.txt\", \"a\") as File1:\n    File1.write(\"This is line D\\n\")\n```\n\n### Copy one file to a new file\n\n```{python}\nwith open(\"../data/Example1.txt\", \"r\") as readfile:\n    with open(\"../data/Example3.txt\", \"w\") as writefile:\n        for line in readfile:\n            writefile.write(line)\n```\n\n### Other modes\n \n```{python}\nwith open('../data/Example2.txt', 'a+') as testwritefile:\n    testwritefile.write(\"This is line E\\n\")\n    print(testwritefile.read())\n```\n\nOpening the file in w is akin to opening the .txt file, moving your cursor to the beginning of the text file, writing new text and deleting everything that follows. Whereas opening the file in a is similiar to opening the .txt file, moving your cursor to the very end and then adding the new pieces of text. It is often very useful to know where the 'cursor' is in a file and be able to control it. The following methods allow us to do precisely this -\n\n- .tell() - returns the current position in bytes\n- .seek(offset,from) - changes the position by 'offset' bytes with respect to 'from'. From can take the value of 0,1,2 corresponding to beginning, relative to current position and end\n\n\n```{python}\nwith open('../data/Example2.txt', 'a+') as testwritefile:\n    print(\"Initial Location: {}\".format(testwritefile.tell()))\n    data = testwritefile.read()\n    if (not data):  #empty strings return false in python\n            print('Read nothing') \n    else: \n            print(testwritefile.read())\n    \n    testwritefile.seek(0,0) # move 0 bytes from beginning.\n    \n    print(\"\\nNew Location : {}\".format(testwritefile.tell()))\n    data = testwritefile.read()\n    if (not data): \n            print('Read nothing') \n    else: \n            print(data)\n    \n    print(\"Location after read: {}\".format(testwritefile.tell()) )\n```\n\n\nFinally, a note on the difference between w+ and r+. Both of these modes allow access to read and write methods, however, opening a file in w+ overwrites it and deletes all pre-existing data.\n**To work with a file on existing data, use r+ and a+**. While using r+, it can be useful to add a .truncate() method at the end of your data. This will reduce the file to your data and delete everything that follows.\n\n```{python}\nwith open('../data/Example2.txt', 'r+') as testwritefile:\n    data = testwritefile.readlines()\n    testwritefile.seek(0,0) #write at beginning of file\n   \n    testwritefile.write(\"Line 1\" + \"\\n\")\n    testwritefile.write(\"Line 2\" + \"\\n\")\n    testwritefile.write(\"Line 3\" + \"\\n\")\n    testwritefile.write(\"finished\\n\")\n    #Uncomment the line below\n    testwritefile.truncate()\n    testwritefile.seek(0,0)\n    print(testwritefile.read())\n```\n\nAfter reading files, we can also write data into files and save them in different file formats like .txt, .csv, .xls (for excel files) etc. You will come across these in further examples\n\n#### Exercise\n\nYour local university's Raptors fan club maintains a register of its active members on a .txt document. Every month they update the file by removing the members who are not active. You have been tasked with automating this with your Python skills.\n\nGiven the file currentMem, Remove each member with a 'no' in their Active column. Keep track of each of the removed members and append them to the exMem file. Make sure that the format of the original files in preserved. (Hint: Do this by reading/writing whole lines and ensuring the header remains )\n\nRun the code block below prior to starting the exercise. The skeleton code has been provided for you. Edit only the cleanFiles function.\n\n```{python}\n#Run this prior to starting the exercise\nfrom random import randint as rnd\n\nmemReg = '../data/members.txt'\nexReg = '../data/inactive.txt'\nfee =('yes','no')\n\ndef genFiles(current,old):\n    with open(current,'w+') as writefile: \n        writefile.write('Membership No  Date Joined  Active  \\n')\n        data = \"{:^13}  {:<11}  {:<6}\\n\"\n\n        for rowno in range(20):\n            date = str(rnd(2015,2020))+ '-' + str(rnd(1,12))+'-'+str(rnd(1,25))\n            writefile.write(data.format(rnd(10000,99999),date,fee[rnd(0,1)]))\n\n\n    with open(old,'w+') as writefile: \n        writefile.write('Membership No  Date Joined  Active  \\n')\n        data = \"{:^13}  {:<11}  {:<6}\\n\"\n        for rowno in range(3):\n            date = str(rnd(2015,2020))+ '-' + str(rnd(1,12))+'-'+str(rnd(1,25))\n            writefile.write(data.format(rnd(10000,99999),date,fee[1]))\n\n\ngenFiles(memReg,exReg)\n```\n\n```{python}\ndef cleanFiles(currentMem, exMem):\n    with open(currentMem, \"r+\") as writeFile:\n        with open(exMem, \"a+\") as appendFile:\n            #get the data\n            writeFile.seek(0)\n            members = writeFile.readlines()\n            #remove header\n            header = members[0]\n            members.pop(0)\n            inactive=[]\n            for member in members:\n                if 'no' in member:\n                    inactive.append(member)\n            '''\n            inactive = [member for member in members if ('no' in member)]\n            The above is the same as \n            \n            for member in members:\n            if 'no' in member:\n                inactive.append(member)\n            '''\n            #go to the beginning of the write file\n            writeFile.seek(0)\n            writeFile.write(header)\n            for member in members:\n                if (member in inactive):\n                    appendFile.write(member)\n                else:\n                    writeFile.write(member)\n            writeFile.truncate()\n```\n\nTest code:\n\n```{python}\nmemReg = '../data/members.txt'\nexReg = '../data/inactive.txt'\ncleanFiles(memReg,exReg)\n\n# code to help you see the files\nheaders = \"Membership No  Date Joined  Active  \\n\"\n\nwith open(memReg,'r') as readFile:\n    print(\"Active Members: \\n\\n\")\n    print(readFile.read())\n    \nwith open(exReg,'r') as readFile:\n    print(\"Inactive Members: \\n\\n\")\n    print(readFile.read())\n    \n```\n\n\nAutomated test code:\n\n```{python}\ndef testMsg(passed):\n    if passed:\n       return 'Test Passed'\n    else :\n       return 'Test Failed'\n\ntestWrite = \"../data/testWrite.txt\"\ntestAppend = \"../data/testAppend.txt\" \npassed = True\n\ngenFiles(testWrite,testAppend)\n\nwith open(testWrite,'r') as file:\n    ogWrite = file.readlines()\n\nwith open(testAppend,'r') as file:\n    ogAppend = file.readlines()\n\ntry:\n    cleanFiles(testWrite,testAppend)\nexcept:\n    print('Error')\n\nwith open(testWrite,'r') as file:\n    clWrite = file.readlines()\n\nwith open(testAppend,'r') as file:\n    clAppend = file.readlines()\n        \n# checking if total no of rows is same, including headers\n\nif (len(ogWrite) + len(ogAppend) != len(clWrite) + len(clAppend)):\n    print(\"The number of rows do not add up. Make sure your final files have the same header and format.\")\n    passed = False\n    \nfor line in clWrite:\n    if  'no' in line:\n        passed = False\n        print(\"Inactive members in file\")\n        break\n    else:\n        if line not in ogWrite:\n            print(\"../data in file does not match original file\")\n            passed = False\nprint (\"{}\".format(testMsg(passed)))\n```\n\n## Pandas\n\nPandas is a popular library for data analysis built on top of the Python programming language. Pandas generally provide two data structures for manipulating data, They are:\n\n- DataFrame: a two-dimensional data structure, i.e., data is aligned in a tabular fashion in rows and columns.\n- Series: represents a one-dimensional array of indexed data. It has two main components :\n    - An array of actual data.\n    - An associated array of indexes or data labels.\n\nWe input a library, a set of pre-written functions with the import command followed by the name of the library. Since always writing the library name, we can shorten it with the as statement. Pd is the standard abbreviation often used for pandas.\n\n```{python}\nimport pandas as pd\n```\n\nThis gives us access to a number of pre-build classes and functions. \n\n### Loading data with pandas\n\nWe import a table with and store it in a dataframe. A dataframe is comprised of rows and columns. \n\n```{python}\n#read in a dataframe\ndf = pd.read_csv(\"../data/file1.csv\")\n\n#examine the first 5 rows of a dataframe\ndf.head()\n```\n\nWe also can create a dataframe out of a dictionary. The keys correspond to the table headers, the values correspond to the rows.\n\n```{python}\n#Define a dictionary 'x'\nx = {'Name': ['Rose','John', 'Jane', 'Mary'], \n        'ID': [1, 2, 3, 4], \n        'Department': ['Architect Group', 'Software Group', 'Design Team', 'Infrastructure'], \n        'Salary':[100000, 80000, 50000, 60000]}\n\n#casting the dictionary to a DataFrame\ndf = pd.DataFrame(x)\n\n#display the result df\ndf\n```\n\nWe can create a new df consisting of one column.\n\n```{python}\nx = df[[\"ID\"]]\nx\n```\n\nLet's use the <code>type()</code> function and check the type of the variable.\n\n```{python}\n#check the type of x\ntype(x)\n```\n\nWe can also do this for multiple columns:\n\n```{python}\nz = df[['Department','Salary','ID']]\nz\n```\n\nTo view the column as a series, we just use one bracket.\n\n```{python}\nx = df[\"Name\"]\nx\n```\n\n```{python}\n#check the type of x\ntype(x)\n```\n\n### loc() and iloc() functions\n\nloc() is a label-based data selecting method which means that we have to pass the name of the row or column that we want to select. This method includes the last element of the range passed in it.\n\nSimple syntax for your understanding:\n\n`loc[row_label, column_label]`\n\niloc() is an indexed-based selecting method which means that we have to pass integer index in the method to select a specific row/column. This method does not include the last element of the range passed in it.\n\nSimple syntax for your understanding:\n\n`iloc[row_index, column_index]`\n\n\n```{python}\n# Access the value on the first row and the first column\ndf.iloc[0, 0]\n```\n\n```{python}\n# Access the value on the first row and the third column\ndf.iloc[0,2]\n```\n\n```{python}\n# Access the column using the name\ndf.loc[0, 'Salary']\n```\n\nLet us create a new dataframe called 'df1' and assign 'df' to it. Now, let us set the \"Name\" column as an index column using the method set_index().\n\n```{python}\ndf1=df\ndf1=df1.set_index(\"Name\")\n\n#To display the first 5 rows of new dataframe\ndf1.head()\n```\n\n```{python}\n#Now, let us access the column using the name\ndf1.loc['Jane', 'Salary']\n```\n\n### Slicing\n\nSlicing uses the [] operator to select a set of rows and/or columns from a DataFrame.\n\nTo slice out a set of rows, you use this syntax: data[start:stop],\n\nhere the start represents the index from where to consider, and stop represents the index one step BEYOND the row you want to select. You can perform slicing using both the index and the name of the column.\n\n**NOTE: When slicing in pandas, the start bound is included in the output.**\n\nSo if you want to select rows 0, 1, and 2 your code would look like this: df.iloc[0:3].\n\nIt means you are telling Python to start at index 0 and select rows 0, 1, 2 up to but not including 3.\n\n**NOTE: Labels must be found in the DataFrame or you will get a KeyError.**\n\nIndexing by labels(i.e. using loc()) differs from indexing by integers (i.e. using iloc()). With loc(), both the start bound and the stop bound are inclusive. When using loc(), integers can be used, but the integers refer to the index label and not the position.\n\nFor example, using loc() and select 1:4 will get a different result than using iloc() to select rows 1:4.\n\n```{python}\n# let us do the slicing using old dataframe df\ndf.iloc[0:2, 0:3]\n```\n\n```{python}\n#let us do the slicing using loc() function on old dataframe df where index column is having labels as 0,1,2\ndf.loc[0:2,'ID':'Department']\n```\n\n### Working with and Saving Data\n\n#### Make a list of unique elements\n\n```{python}\n# Read data from CSV file\ncsv_path = 'https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%204/data/TopSellingAlbums.csv'\ndf = pd.read_csv(csv_path)\ndf.head()\n```\n\n```{python}\n# Access to the column Released\nx = df[['Released']]\nx\n```\n\n```{python}\n#apply the unique method to remove duplicated years\ndf['Released'].unique()\n```\n\n### Selecting rows by conditions\n\nLets find all the albums released after 1980\n\n```{python}\n#find albums after 1980\n#the results is a list of boolean values\nprint(df[\"Released\"]>=1980)\n\n#select the specified columns from our dataframe\ndf1 = df[df[\"Released\"]>=1980]\ndf1.head()\n```\n\n\n### Save dataframes\n\n```{python}\n#save new df to csv\ndf.to_csv(\"../data/new_songs.csv\")\n```\n\n\n## Numpy\n\nNumpy is a package for scientific computing and has many useful functions.\n\n### Basics\n\nNumPy is a Python library used for working with arrays, linear algebra, fourier transform, and matrices.A numpy array is similar to a list. NumPy stands for Numerical Python and it is an open source project.The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy.\n\nArrays are very frequently used in data science, where speed and resources are very important.\n\nNumPy is usually imported under the np alias.\n\nIt's usually fixed in size and each element is of the same type. We can cast a list to a numpy array by first importing numpy:\n\n```{python}\n#load numpy\nimport numpy as np\n\n#The version string is stored under version attribute.\nprint(np.__version__)\n```\n\n```{python}\n#create an array\na = np.array([0,1,2,3,4])\nprint(a)\n\n#access individual elements\nprint(a[2])\n\n#check the type\nprint(type(a))\n\n#obtain the data type of the array element\nprint(a.dtype)\n\n#check the attribute size, the number of elements in the array\nprint(a.size)\n\n#show the array dimensions\nprint(a.ndim)\n\n#show the size of the array in each dimension\nprint(a.shape)\n```\n\n\n### Indexing and slicing\n\nChange elements of an array:\n\n```{python}\n#define an array\nc = np.array([20,1,2,3,4])\nprint(c)\n\n#change the first element to 100\nc[0]=100\nprint(c)\n\n#change the 5th element\nc[4]=5\nprint(c)\n```\n\nLike lists, we can slice the numpy array. Slicing in python means taking the elements from the given index to another given index.\n\nWe pass slice like this: [start:end].\n\nWe can select the elements from 1 to 3 and assign it to a new numpy array as follows:\n\n```{python}\n#select the elements from 1 to 3\nprint(c[1:4])\n\n## Set the fourth element and fifth element to 300 and 400\nc[3:5] = 300, 400\nprint(c)\n```\n\nWe can also define the steps in slicing, like this: [start:end:step].\n\n```{python}\narr = np.array([1, 2, 3, 4, 5, 6, 7])\nprint(arr[1:5:2])\n```\n\nIf we don't pass start its considered 0\n\n```{python}\nprint(arr[1:5])\n```\n\nIf we don't pass end it considers till the length of array.\n\n```{python}\nprint(arr[3:])\n```\n\nIf we don't pass step its considered 1\n\n```{python}\nprint(arr[1:5:])\n```\n\n\n### Basic operations\n\n#### Vector addition and subtraction\n\n```{python}\n#define some vectors\nu = np.array([1,0])\nv = np.array([0,1])\n\n#add vectors\nz = u+v\nprint(z)\n\n#subtract vectors\nz = u-v\nprint(z)\n```\n\n#### Array multiplication with a scalar\n\n```{python}\ny = np.array([1,2])\n\n#multiply vector\nz= 2*y\nprint(z)\n\n```\n\n#### Product of two numpy arrays\n\n```{python}\nu = np.array([1,2])\nv = np.array([3,2])\n\n#multiply two vectors\nz = u*v\nprint(z)\n```\n\n#### Dot products \n\nThe dot product is a single number given by the following term and represents how similar two vectors are.\n\n```{python}\nu = np.array([1,2])\nv = np.array([3,1])\n\n#dot product\n#1*3 + 2*5\nresult = np.dot(u,v)\nprint(result)\n```\n\n#### Adding constant to a numpy array \n\n```{python}\nu = np.array([1,2,3,-1])\n\n#add a scalar to each element of an array, i.e. broadcasting\nz = u + 1\nprint(z)\n```\n\n\n### Universal functions\n\nA universal function is a function that operates on ND arrays. We can apply a universal function to a numpy array. \n\n#### Calculating the mean of an array\n\n```{python}\na = np.array([1,-1,1,-1])\n\n#calculate the mean\nmean_a = a.mean()\nprint(mean_a)\n```\n\n#### Standard deviation\n\n```{python}\na = np.array([1,-1,1,-1])\n\nsdev = a.std()\nprint(sdev)\n\n```\n\n#### Find the max and min\n\n```{python}\nb = np.array([1,-2,3,4,5])\n\n#calculate the mean\nmax_b = b.max()\nprint(max_b)\n```\n\nWe can use numpy to create functions that map numpy arrays to new numpy arrays.\n\n```{python}\n#access pi with\nprint(np.pi)\n\n# We can create the following numpy array in radians\nx = np.array([0,np.pi/2,np.pi])\n\n#apply the function sin to our array x\n#this way we apply the sin function to each element in the array\ny = np.sin(x)\n\n#the result is a new array, y\nprint(y)\n```\n\n#### Using Linspace\n\nA useful function for plotting mathematical functions is **line space**. Line space returns evenly spaced numbers over specified interval. We specify the starting point of the sequence, the ending point of the sequence. The parameter num indicates the number of samples to generate, in this case five.\n\n```{python}\nprint(np.linspace(-2,2,num=5))\nprint(np.linspace(-2,2,num=9))\n```\n\nPlotting mathematics functions: We can use the function line space to generate 100 evenly spaced samples from the interval zero to two pie. We can use the numpy function sin to map the array x to a new array y. We can import the library pyplot as plt to help us plot the function.\n\n```{python}\n#generate 100 evenly spaced samples from the interval zero to two pie\nx = np.linspace(0,2*np.pi,100)\n\n#use sin to map the array x to a new array y\ny = np.sin(x)\n\n#import the matplot lib to help us plot the function\nimport matplotlib.pyplot as plt\n\n#plot the graph\n#first value = values plotted on x-axis, second input = values plotted on x-axis\nplt.plot(x,y)\nplt.show()\n```\n\n#### Iterating 1-D Arrays\n\nterating means going through elements one by one.\n\nIf we iterate on a 1-D array it will go through each element one by one.\n\n```{python}\narr1 = np.array([1, 2, 3])\n\nfor x in arr1:\n    print(x)\n```\n\n\n#### Plot arrays\n\nGenerate a function for plotting\n\n```{python}\n# | warning: false\n\n# Import the libraries\nimport time \nimport sys\nimport numpy as np \n\nimport matplotlib.pyplot as plt\n\ndef Plotvec2(a,b):\n    ax = plt.axes()# to generate the full window axes\n    ax.arrow(0, 0, *a, head_width=0.05, color ='r', head_length=0.1)#Add an arrow to the  a Axes with arrow head width 0.05, color red and arrow head length 0.1\n    plt.text(*(a + 0.1), 'a')\n    ax.arrow(0, 0, *b, head_width=0.05, color ='b', head_length=0.1)#Add an arrow to the  b Axes with arrow head width 0.05, color blue and arrow head length 0.1\n    plt.text(*(b + 0.1), 'b')\n    plt.ylim(-2, 2)#set the ylim to bottom(-2), top(2)\n    plt.xlim(-2, 2)#set the xlim to left(-2), right(2)\n```\n\n\nPlot:\n\n```{python}\narr1 = np.array([-1,1])\narr2 = np.array([1,1])\n\nPlotvec2(arr1,arr2)\nplt.show()\n```\n\n\n\n### 2D numpy arrays\n\nLet's first create a nested list with 3 lists, each of equal size.\n\n```{python}\na = np.array([[1,3,4],[10,11,12]])\nprint(a)\n\n#cast the list to a numpy array\n# each separate list = 1 row in the matrix\nA = np.array(a)\nprint(A)\n\n#We can use the attribute ndim to obtain the number of axes or dimensions\n#referred to as the rank \nprint(A.ndim)\n```\n\nIt's useful to think of ndim as the number of nested lists. The first list represents the first dimension. This list contains another set of lists. This represents the second dimension or axis. The number of lists the list contains does not have to do with the dimension but the shape of the list.\n\n```{python}\n#Attribute shape returns a tuple corresponding to the size or number of each dimension.\nprint(A.shape)\n```\n\nThe first element in the tuple corresponds to the number of nested lists contained in the original list or the number of rows in the rectangular representation, in this case three. The second element corresponds to the size of each of the nested list or the number of columns in the rectangular array zero.\n\n```{python}\n#The total number of elements in the array is given by the attribute size.\nprint(A.size)\n```\n\nWe see there are three rows and three columns. Multiplying the number of columns and rows together, we get the total number of elements, in this case nine.\n\nWe can use rectangular brackets to access the different elements of the array. The index in the first bracket corresponds to the different nested lists each a different color. The second bracket corresponds to the index of a particular element within the nested list. Using the rectangular representation, the first index corresponds to the row index. The second index corresponds to the column index.\n\n```{python}\n#get the second row and third column\nprint(A[1][2])\n\n#get the first row and first column\nprint(A[0][0])\nprint(A[0,0])\n```\n\nWe can also slice:\n\n```{python}\n#get the first row and the first 2 columns\nprint(A[0,0:2])\n\n#get the first 2 rows and the 3rd column\nprint(A[0:2,2])\n```\n\nWe can also add (or use other mathematical operations) on two arrays:\n\n```{python}\n#define two arrays\nX = np.array([[1,0],[0,1]])\nY = np.array([[2,1],[1,2]])\n\n#view arrays\nprint(X)\nprint(Y)\n\n#combine the arrays\nprint(X+Y)\n\n#perform matrix multiplication on the numpy arrays  A and  B\nprint(np.dot(X,Y))\n```\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"Week4_Files_Pandas_Numpy.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.168","knitr":{"opts_chunk":{"collapse":true}},"space-before-code-block":"10pt","space-after-code-block":"8pt","linespacing":"22pt plus2pt","frontmatter-linespacing":"17pt plus1pt minus1pt","title-size":"22pt","title-size-linespacing":"28pt","gap-before-crest":"25mm","gap-after-crest":"25mm","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"pdflatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","highlight-style":"github","output-file":"Week4_Files_Pandas_Numpy.pdf"},"language":{},"metadata":{"block-headings":true,"knitr":{"opts_chunk":{"collapse":true}},"space-before-code-block":"10pt","space-after-code-block":"8pt","linespacing":"22pt plus2pt","frontmatter-linespacing":"17pt plus1pt minus1pt","title-size":"22pt","title-size-linespacing":"28pt","gap-before-crest":"25mm","gap-after-crest":"25mm","documentclass":"scrreprt","geometry":["heightrounded"],"pandoc_args":"--listings","header-includes":["\\usepackage{fvextra} \\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}"],"colorlinks":true,"code-block-bg":"D3D3D3"},"extensions":{"book":{}}}}}