{
  "hash": "bb6a2880a174355b4c5adb10bce30969",
  "result": {
    "markdown": "# Conditions and branching\n\n## Comparison Operations\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n#test for equality\na = 6\na == 7\n\n#greater than\ni = 6\ni > 5\n\n#greater than or equal to\ni = 5\ni >= 5\n\n#test for inequality\ni = 5\ni != 6\n\n#we can compare strings as well\n\"AC/DC\" == \"Thriller\"\n\"AC/DC\" != \"Thriller\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTrue\n```\n:::\n:::\n\n\n## Branching\n\n-   Branching allows us to run different statements for different input\n\n### The if statement\n\nIf a statement is true, then you can enter the room and run some pre-defined task.\nIf the statement is false, our program will skip the task.\n\nAs an example, make a statement were you only can enter a concert if you are older than 19\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n#define our age\nage = 20\n\n#run the statement\nif (age>18):\n  print(\"you can enter the concert\")\nprint(\"move on\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nyou can enter the concert\nmove on\n```\n:::\n:::\n\n\n### The else statement\n\n-   The else statement will run a different block of code if the same condition is false.\n-   Now lets say that they can not go to ACDC if they are less than 18 but they can go to the meat loaf concert. If they are over 18 they go to the ACDC concert\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n#define our age\nage = 17\n\n#run the statement\nif (age>18):\n  print(\"you can enter the ACDC concert\")\nelse:\n  print(\"go see Meat Loaf\")\nprint(\"move on\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngo see Meat Loaf\nmove on\n```\n:::\n:::\n\n\n### The elif statement\n\n-   The elif statement, short for else-if, allows us to check additional conditions if the preceding condition is false. If the condition is true, the alternate expressions will be run\n-   For example: If we are 18, we will go to Pink Floyd instead of ACDC or Meat Loaf. For less than 18 and older than 18 the old rules apply.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n#define our age\nage = 18\n\n#run the statement\nif (age>18):\n  print(\"you can enter the ACDC concert\")\nelif(age==18):\n  print(\"go see Pink Floyd\")\nelse:\n  print(\"go see Meat Loaf\")\nprint(\"move on\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngo see Pink Floyd\nmove on\n```\n:::\n:::\n\n\n## Logic operators\n\n-   Logic operators take boolean values and produce different boolean values\n\n### The or operator\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nalbum_year = 1981\n\nif(album_year <1980) or (album_year > 1989):\n  print(\"The album was made in the 70s or 90s\")\nelse:\n  print(\"The Album was made in the 80s\")\n\nprint(\"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe Album was made in the 80s\n\n```\n:::\n:::\n\n\n### The and operator\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nalbum_year = 1981\n\nif(album_year > 1979) and (album_year < 1990):\n  print(\"The album was made in the 80s\")\n\nprint(\"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe album was made in the 80s\n\n```\n:::\n:::\n\n\n### The not statement\n\nThe not statement checks if the statement is false:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Condition statement example\nalbum_year = 1984\n\nif not (album_year == 1984):\n    print (\"Album year is not 1984\")\n\nprint(\"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n:::\n\n\n## Loops\n\n### The range function\n\nThe range function outputs and ordered sequence as a list I.\nIf the input is a positive integer, the output is a sequence.\nThe sequence contains the same number of elements as the input but starts at zero.\n\nIn Python 3, range() creates an object of type range..\nAn object of type range does not store values, but creates when needed, so its values are not displayed with print().\nSince it is an iterable object, the value can be printed in the for loop.\n\n### For loops\n\nLoops perform a task over and over again.\n\nLets try to print the values of a range.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfor i in range(3):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nfor i in range(12,15):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12\n13\n14\n```\n:::\n:::\n\n\nFor a list of colors, replace each color value with `white.`\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nsquares = [\"red\", \"yellow\", \"green\"]\n\nfor i in range(0,3):\n    squares[i]=\"white\"\n\nsquares\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n['white', 'white', 'white']\n```\n:::\n:::\n\n\nIterate through a list without a range:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nsquares = [\"red\", \"yellow\", \"green\"]\n\nfor i in squares:\n    i\n\nsquares\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n['red', 'yellow', 'green']\n```\n:::\n:::\n\n\nAnother example: print all years present in a list with dates:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n#define the list\ndates = [1982, 1980, 1973]\n\n#calculate the length of the index\nN = len(dates)\n\n#execute the code N times\nfor i in range(N):\n    print(dates[i])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1982\n1980\n1973\n```\n:::\n:::\n\n\nAlternatively, we can access the elements like this:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n#define the list\ndates = [1982, 1980, 1973]\n\n#execute the code N times\nfor i in dates:\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1982\n1980\n1973\n```\n:::\n:::\n\n\nWe can also recover the index with enumerate().\n\nWhen you use enumerate(), the function gives you back two loop variables:\n\nThe count of the current iteration The value of the item at the current iteration\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nsquares = [\"red\", \"yellow\", \"green\"]\n\nfor index,value in enumerate(squares):\n    value\n    index\n```\n:::\n\n\nWe can also print this in a nicer looking table:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nsquares = [\"red\", \"yellow\", \"green\"]\n\nfor index,value in enumerate(squares):\n    print(index, value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 red\n1 yellow\n2 green\n```\n:::\n:::\n\n\n### While loops\n\nWhile loops are similar to for loops but instead of executing a statement a set number of times, a while loop only runs if a condition is met.\n\nFor example: We have a list of colors and want to copy these into a new list until we encounter a non-orange value.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nsquares = [\"orange\", \"orange\", \"purple\", \"orange\"]\n\n#create an empty list in which we want to store our new list\nNewsquares=[]\n\n#start the index at 0\ni=0\n\n#execute the statement until the condition is false\nwhile(squares[i]==\"orange\"):\n    #append the value of the i-th element of the list squares to the new list\n    Newsquares.append(squares[i])\n    #increase the index value by one to be able to access the 2nd element in the next round\n    i=i+1\n\nNewsquares\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n['orange', 'orange']\n```\n:::\n:::\n\n\nAlternatively, we could do:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nsquares = [\"orange\", \"red\", \"purple\", \"green\"]\n\n#create an empty list in which we want to store our new list\nNewsquares=[]\n\n#start the index at 0\ni=0\n\nwhile(squares[i]!=\"purple\"):\n    Newsquares.append(squares[i])\n    i=i+1\n\nNewsquares\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n['orange', 'red']\n```\n:::\n:::\n\n\nLet's say we would like to iterate through list dates and stop at the year 1973, then print out the number of iterations.\nThis can be done with the following block of code:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndates = [1982 ,1980, 1973, 2000]\n\n#set counter and empty list\ni=0\nyear=dates[0]\n\nwhile(year!=1973):\n    print(year)\n    i = i+1\n    year=dates[i]\n\nprint(\"It took \", i, \"repetitions to get out of the loop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1982\n1980\nIt took  2 repetitions to get out of the loop\n```\n:::\n:::\n\n\n### Exercises Loops\n\nWrite a for loop the prints out all the element between -5 and 5 using the range function.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nfor i in range(-4,5):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-4\n-3\n-2\n-1\n0\n1\n2\n3\n4\n```\n:::\n:::\n\n\nPrint the elements of the following list: Genres=\\[ 'rock', 'R&B', 'Soundtrack', 'R&B', 'soul', 'pop'\\] Make sure you follow Python conventions.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nGenres=[ 'rock', 'R&B', 'Soundtrack', 'R&B', 'soul', 'pop']\n\nfor i in Genres:\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrock\nR&B\nSoundtrack\nR&B\nsoul\npop\n```\n:::\n:::\n\n\nWrite a while loop to display the values of the Rating of an album playlist stored in the list PlayListRatings.\nIf the score is less than 6, exit the loop.\nThe list PlayListRatings is given by: PlayListRatings = \\[10, 9.5, 10, 8, 7.5, 5, 10, 10\\]\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nPlayListRatings = [10, 9.5, 10, 8, 7.5, 5, 10, 10]\n\ni=0\nRating=PlayListRatings[0]\n\nwhile(Rating>6):\n    print(Rating)\n    i=i+1\n    Rating=PlayListRatings[i]\n    #i=i+1 #Try uncommenting the line and comment the previous i = i + 1, and see the difference, 10 value will get printed twice because when the loop starts it will print Rating and then with PlayListRatings[0], it will again assign the value 10 to Ratings.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n9.5\n10\n8\n7.5\n```\n:::\n:::\n\n\n## Functions\n\n-   Functions take some input then produce some output or change. You can use your own functions or use pythons build in functions.\n-   Functions are used to make reusable modules and make the code we run shorter.\n\n### sum()\n\nI.e. the function sum() takes a tuple or list as input and returns the sum of the values\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nratings = [10,8,5]\nS = sum(ratings)\nS\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n23\n```\n:::\n:::\n\n\n### sort()\n\nSort() is a list method.\nMethods are similar to functions.Generally **functions** take an input, i.e. a list, they produce a new output and the original input stays unchanged.\nIf we use the **method** sort, our list will change and no new list will be created.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nratings = [10,8,5]\n\n#apply the function sorted\nsorted_ratings = sorted(ratings)\nsorted_ratings\nratings\n\n#apply the sort method\nratings.sort()\nratings\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n[5, 8, 10]\n```\n:::\n:::\n\n\n### building functions\n\n-   to build a function we start with the key word: def\n-   Follow this by the name of the function, i.e. add1\n-   in brackets we add the functions formal parameters, i.e. the input to our function\n-   After the colon comes the code block with an indent\n-   A variable that is declared inside a function is called a local variable. The parameter only exists within the function (i.e. the point where the function starts and stops).\n-   we then return, our output, something\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n#define a function\ndef add1(a):\n    b=a+1\n    return b\n\n#call a function\nadd1(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n3\n```\n:::\n:::\n\n\nLets now document the function better.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n#define a function with a documenting string\ndef add1(a):\n    \"\"\"\n    add 1 to a\n    \"\"\"\n    b=a+1\n    return b\n\n#display the documentation\nhelp(add1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on function add1 in module __main__:\n\nadd1(a)\n    add 1 to a\n\n```\n:::\n:::\n\n\nA function can have multiple parameters.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n#define the mult function, which multiplies two integers\ndef mult(a,b):\n    c=a*b\n    return c\n\nmult(3,3)\nmult(2,\"hello\")\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n'hellohello'\n```\n:::\n:::\n\n\nFunctions don't need a return statement.\nPractically speaking, if your function has no return statement, you can treat it as if the function returns nothing at all.\nThe function word_return simply prints the name 'hello'.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ndef word_return():\n    print(\"hello\")\n\nword_return()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\n```\n:::\n:::\n\n\nWe can define an empty function like this.\npass is simply used to have a empty code block.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\ndef NoWork():\n    pass\n\nprint(NoWork())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\n```\n:::\n:::\n\n\nFunctions can perform more than one task.\nI.e. the function below prints a statement then returns a value.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ndef add1(a):\n    b = a+1\n    print(a, \"plus 1 equals= \", b)\n    return b\n\nadd1(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 plus 1 equals=  3\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n3\n```\n:::\n:::\n\n\nWe can also use loops in functions.\nI.e. lets define a function that prints out the values and indexes of a list or tuple.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ndef printStuff(stuff):\n    for i,s in enumerate(stuff):\n        print(\"Album\", i, \"rating is \", s)\n        \nalbum_ratings = [10,8,7]\nprintStuff(album_ratings)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAlbum 0 rating is  10\nAlbum 1 rating is  8\nAlbum 2 rating is  7\n```\n:::\n:::\n\n\nWe can also loop through elements in a list.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ndef Print(A):\n    for a in A:\n        print(a+'1')\n        \nPrint(['a','b','c'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na1\nb1\nc1\n```\n:::\n:::\n\n\nVariadic parameters allow us to input a variable number of elements.\nConsider the following function; the function has an asterisk on the parameter names.\nWhen we call the function, three parameters are packed into the tuple names.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\ndef ArtistNames(*names):\n    for i in names:\n        print(i)\n        \nArtists = [\"MJ\", \"AC/DC\"]\nArtistNames(\"MJ\", \"AC/DC\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMJ\nAC/DC\n```\n:::\n:::\n\n\nSimilarly, The arguments can also be packed into a dictionary as shown:\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\ndef printDictionary(**args):\n    for key in args:\n        print(key + \" : \" + args[key])\n\nprintDictionary(Country='Canada',Province='Ontario',City='Toronto')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCountry : Canada\nProvince : Ontario\nCity : Toronto\n```\n:::\n:::\n\n\nThe scope of a variable is the part of the program where that variable is accessible.\nVariables that are defined outside of any function are said to be within the global scope, meaning they can be accessed anywhere after they are defined.\nLocal variables only exist within the scope of a function.\nVariables inside the global scope can have the same name as variables in the local scope with no conflict.\n\nI.e. in the following we can not access the variable internal_var1 outside of the function\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Example of global variable\nartist = \"Michael Jackson\"\n\ndef printer1(artist):\n    internal_var1 = artist\n    print(artist, \"is an artist\")\n    \nprinter1(artist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMichael Jackson\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n is an artist\n```\n:::\n:::\n\n\nBut we can if we set a variable in a function to a global variable:\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nartist = \"Michael Jackson\"\n\ndef printer(artist):\n    global internal_var \n    internal_var= \"Whitney Houston\"\n    print(artist,\"is an artist\")\n\nprinter(artist) \nprinter(internal_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMichael Jackson is an artist\nWhitney Houston is an artist\n```\n:::\n:::\n\n\nThe return() function is particularly useful if you have any IF statements in the function, when you want your output to be dependent on some condition:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Function example\ndef type_of_album(artist, album, year_released):\n    #print(artist, album, year_released)\n    if year_released > 1980:\n        return \"Modern\"\n    else:\n        return \"Oldie\"\n    \nx = type_of_album(\"Michael Jackson\", \"Thriller\", 1980)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOldie\n```\n:::\n:::\n\n\nYou can set a **default value for arguments** in your function.\nFor example, in the isGoodRating() function, what if we wanted to create a threshold for what we consider to be a good rating?\nPerhaps by default, we should have a default rating of 4:\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Example for setting param with default value\ndef isGoodRating(rating=4): \n    if(rating < 7):\n        print(\"this album sucks it's rating is\",rating)      \n    else:\n        print(\"this album is good its rating is\",rating)\n\nisGoodRating()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthis album sucks it's rating is 4\n```\n:::\n:::\n\n\n### Exercises functions\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\ndef Equation(a,b):\n    c = a + b + 2 * a * b - 1\n    if(c < 0):\n        c = 0 \n    else:\n        c = 5\n    return(c) \n\nEquation(0,0)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n0\n```\n:::\n:::\n\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nL=[1,3,2]\nsorted(L)\nL\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n[1, 3, 2]\n```\n:::\n:::\n\n\n## Exception handling\n\n-   Make error messages appear when performing \"wrong\" operations. I.e. if you only can input letters, not numbers.\n\n### The try...except statement\n\nThis statement will first attempt to excecute the statement in a try code block but if an error occurs it will kick out and start searching for the except statement that matches the error.\nOnce it finds the correct except statement to handle the error it will execute that line of code.\n\nLet's try to write an example of code to open a file, however, if the file can not be opened, give an error.\n\nIOError = an error related to a file\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\ntry:\n    getfile=open(\"myfile\", \"r\")\n    getfile.write(\"File for exception handling\")\n    except IOError:\n        print(\"Unable to open or read the data in the file\")\n```\n:::\n\n\nNow, what to do when we encounter another error?\nIn the example below we catch an error but the type is not specified.\nWhile this may seem a logical step so the program will catch all errors and not terminate this is not a best practice.\nBecause this error had no details you might end up spending hours trying to pinpoint and fix the error.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\ntry:\n    getfile=open(\"myfile\", \"r\")\n    getfile.write(\"File for exception handling\")\n    except IOError:\n        print(\"Unable to open or read the data in the file\")\n    except:\n        print(\"Some other error occurred\")\n```\n:::\n\n\nWe can also add an else statement to show that our prgram run successfully.\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\ntry:\n    getfile=open(\"myfile\", \"r\")\n    getfile.write(\"File for exception handling\")\n    except IOError:\n        print(\"Unable to open or read the data in the file\")\n    except:\n        print(\"Some other error occurred\")\n    else:\n        print(\"The file was written successfully\")\n```\n:::\n\n\nThe last thing to do is close the file by adding the finally statement.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\ntry:\n    getfile=open(\"myfile\", \"r\")\n    getfile.write(\"File for exception handling\")\n    except IOError:\n        print(\"Unable to open or read the data in the file\")\n    except:\n        print(\"Some other error occurred\")\n    else:\n        print(\"The file was written successfully\")\n    finally:\n        getfile.close()\n        print(\"File is now closed\")\n```\n:::\n\n\n### Exercise exceptions\n\nIn this example we are trying to divide a number given by the user, save the outcome in the variable a, and then we would like to print the result of the operation.\nWhen taking user input and dividing a number by it there are a couple of exceptions that can be raised.\nFor example if we divide by zero.\nTry running the following block of code with b as a number.\nAn exception will only be raised if b is zero.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\na = 1\n\ntry:\n    b = int(input(\"Please enter a number to divide a\"))\n    a=a/b\n    print(\"Success a=\", a)\nexcept:\n    print(\"There was an error\")\n```\n:::\n\n\nNow, lets add a more specific error message:\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\na = 1\n\ntry:\n    b = int(input(\"Please enter a number to divide a\"))\n    a = a/b\n    print(\"Success a=\",a)\nexcept ZeroDivisionError:\n    print(\"The number you provided cant divide 1 because it is 0\")\nexcept ValueError:\n    print(\"You did not provide a number\")\nexcept:\n    print(\"Something went wrong\")\n```\n:::\n\n\n## Objects and classes\n\nPython has many different data types, such as integers, floats, strings, lists, dictionaries, booleanes.\nIn python , each of these is an object.\nAn object consists of the following:\n\n-   a type\n-   an internal data representation (a blueprint)\n-   a set of procedures for interacting with an object (methods)\n\nAn Object is an instance of a particular type.\nI.e. every time we create an integer, we are creating an instance of type integer, or we are creating an integer object.\n\nWe can find out the type of an object by using the `type()` command.\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\ntype([\"a\"])\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\nlist\n```\n:::\n:::\n\n\n### Types methods\n\nTypes methods are functions that every instance of a class or type provides.\nIts how we interact with an object.\nFor example sorting is a method that interacts with the data of an object.\n\nI.e. Consider the list ratings, the data is a series of numbers contained within the list.\nThe method sort will change the data within the object.\nWe call the method by adding a period at the end of an object followed by the methods name\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nRatings = [10,9,6,4,5,8]\nRatings.sort()\nRatings\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n[4, 5, 6, 8, 9, 10]\n```\n:::\n:::\n\n\nLet's also import a library to plot data:\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# Import the library\nimport matplotlib.pyplot as plt\n%matplotlib inline  \n```\n:::\n\n\n#code below doesn't work in r bc specific language #%matplotlib inline\n\n### Creating your own types\n\nFor example, lets create a class type, which has data attributes and methods.\nI.e. the \\*class circle\\*\\* contains the data attributed radius and color while the *class rectangle* contains the attributed width, height and color.\n\nLet's create the class Circle by using the class definition, followed by the name of the class (here: circle) and the class parent.\nNext, we initialize each instance of the class with data attributes.\n\nThe function **init** is a constructor used to initialize data attributes, its a special function that tells python that we are making a new class.\nThe radius and color parameters are used to initialize the radius and color data attributes of the class instance.\nThe self parameter refers to the newly created instance of the class.\nThe parameters, radius, and color can be used in the constructors body to access the values passed to the class constructor when the class is constructed.\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n#define the class Circle\nclass Circle(object):\n    #initialize each class with data attributes\n    def __init__(self, radius, color):\n        self.radius=radius;\n        self.color=color;\n```\n:::\n\n\nAfter we have created the class, we can create an object of the class circle:\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n#create a circle object\nRedCircle = Circle(10,\"red\")\n\n#we can check the color attribute with\nRedCircle.color\n\n#change the color attribute\nRedCircle.color=\"blue\"\nRedCircle.color\n\n#return a dict of the attributes in an object\nRedCircle.__dict__\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n{'radius': 10, 'color': 'blue'}\n```\n:::\n:::\n\n\n### Create Methods for our own functions\n\nMethods give you a way to change or interact with the object; they are functions that interact with objects.\nFor example, let's say we would like to increase the radius of a circle by a specified amount.\nFor this, we add a method, add_radius, to our class.\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n#define the class\nclass Circle(object):\n    #initialize each class with data attributes\n    def __init__(self, radius, color):\n        self.radius=radius;\n        self.color=color;\n    def add_radius(self,r):\n        self.radius=self.radius + r\n```\n:::\n\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n#create a new object\nC1 = Circle(2,\"red\")\n\n#check the radius\nC1.radius\n\n#change the radius\nC1.add_radius(8)\nC1.radius\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\n10\n```\n:::\n:::\n\n\n### The dir function\n\nThe dir function is useful for obtaining the list of data attributes and methods associated with a class.\nThe object you're interested in is passed as an argument.\nThe return value is a list of the objects data attributes.\nThe attribute surrounded by underscores are for internal use, and you shouldn't have to worry about them.\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\ndir(Circle)\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n 'add_radius']\n```\n:::\n:::\n\n\n### Exercises objects and classes\n\n### Create a class circle with a method to draw the circle\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\nclass Circle(object):\n    #Instructor, including defaults\n    def __init__(self, radius=3, color=\"blue\"):\n        self.radius=radius\n        self.color=color\n    #add method1\n    def add_radius(self,r):\n        self.radius=self.radius+r\n        return(self.radius)\n    #add method2\n    def drawCircle(self):\n        plt.gca().add_patch(plt.Circle((0, 0), radius=self.radius, fc=self.color))\n        plt.axis('scaled')\n        plt.show()  \n```\n:::\n\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\n#create an object of the class circle\nRedCircle = Circle(10, \"red\")\n\n#find out the methods we can use with the object redcircle\ndir(RedCircle)\n\n# Print the object attribute radius\nRedCircle.radius\n\n# Set the object attribute radius\nRedCircle.radius = 1\nRedCircle.radius\n\n# Call the method drawCircle\nRedCircle.drawCircle()\n```\n\n::: {.cell-output .cell-output-display}\n![](Week3_Conditions_a_branching_files/figure-html/cell-56-output-1.png){width=439 height=411}\n:::\n:::\n\n\n### Text analysis\n\nYou have been recruited by your friend, a linguistics enthusiast, to create a utility tool that can perform analysis on a given piece of text.\nComplete the class 'analysedText' with the following methods -\n\n-   Constructor (**init**) - This method should take the argument text, make it lower case, and remove all punctuation. Assume only the following punctuation is used: period (.), exclamation mark (!), comma (,) and question mark (?). Assign this newly formatted text to a new attribute called fmtText.\n-   freqAll - This method should create and return dictionary of all unique words in the text, along with the number of times they occur in the text. Each key in the dictionary should be the unique word appearing in the text and the associated value should be the number of times it occurs in the text. Create this dictionary from the fmtText attribute.\n-   freqOf - This method should take a word as an argument and return the number of occurrences of that word in fmtText.\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\nclass analysedText(object):\n    \n    def __init__ (self, text):\n        # remove punctuation and make lower case\n        self.fmtText = text.replace('.','').replace('!','').replace('?','').replace(',','').lower()\n    def freqAll(self):        \n        # split text into words\n        wordList = self.fmtText.split(' ')\n        # Create dictionary\n        freqMap = {}\n        for word in set(wordList): # use set to remove duplicates in list\n            freqMap[word] = wordList.count(word)\n        return freqMap\n    \n    def freqOf(self,word):\n        # get frequency map\n        freqDict = self.freqAll()\n        if word in freqDict:\n            return freqDict[word]\n        else:\n            return 0\n```\n:::\n\n\nTest function individually:\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\nsamplePassage = analysedText(\"Lorem ipsum dolor! diam amet, consetetur Lorem magna. sed diam nonumy eirmod tempor. diam et labore? et diam magna. et diam amet.\")\n\n#edit text\nsamplePassage.fmtText\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\n'lorem ipsum dolor diam amet consetetur lorem magna sed diam nonumy eirmod tempor diam et labore et diam magna et diam amet'\n```\n:::\n:::\n\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n#count occurrence of words\nwordMap = samplePassage.freqAll()\nwordMap\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\n{'amet': 2,\n 'ipsum': 1,\n 'consetetur': 1,\n 'tempor': 1,\n 'lorem': 2,\n 'sed': 1,\n 'nonumy': 1,\n 'eirmod': 1,\n 'et': 3,\n 'dolor': 1,\n 'diam': 5,\n 'labore': 1,\n 'magna': 2}\n```\n:::\n:::\n\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\n#count frequency of individual word\nsamplePassage.freqOf(\"dolor\")\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\n1\n```\n:::\n:::\n\n\ntest run:\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\nimport sys\n\nsampleMap = {'eirmod': 1,'sed': 1, 'amet': 2, 'diam': 5, 'consetetur': 1, 'labore': 1, 'tempor': 1, 'dolor': 1, 'magna': 2, 'et': 3, 'nonumy': 1, 'ipsum': 1, 'lorem': 2}\n\ndef testMsg(passed):\n    if passed:\n       return 'Test Passed'\n    else :\n       return 'Test Failed'\n\nprint(\"Constructor: \")\ntry:\n    samplePassage = analysedText(\"Lorem ipsum dolor! diam amet, consetetur Lorem magna. sed diam nonumy eirmod tempor. diam et labore? et diam magna. et diam amet.\")\n    print(testMsg(samplePassage.fmtText == \"lorem ipsum dolor diam amet consetetur lorem magna sed diam nonumy eirmod tempor diam et labore et diam magna et diam amet\"))\nexcept:\n    print(\"Error detected. Recheck your function \" )\nprint(\"freqAll: \")\ntry:\n    wordMap = samplePassage.freqAll()\n    print(testMsg(wordMap==sampleMap))\nexcept:\n    print(\"Error detected. Recheck your function \" )\nprint(\"freqOf: \")\ntry:\n    passed = True\n    for word in sampleMap:\n        if samplePassage.freqOf(word) != sampleMap[word]:\n            passed = False\n            break\n    print(testMsg(passed))\n    \nexcept:\n    print(\"Error detected. Recheck your function  \" )\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConstructor: \nTest Passed\nfreqAll: \nTest Passed\nfreqOf: \nTest Passed\n```\n:::\n:::\n\n\n",
    "supporting": [
      "Week3_Conditions_a_branching_files"
    ],
    "filters": [],
    "includes": {}
  }
}