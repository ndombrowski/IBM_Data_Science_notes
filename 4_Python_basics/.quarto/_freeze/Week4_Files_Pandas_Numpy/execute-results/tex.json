{
  "hash": "0691afd4c1620e86453422259970c7df",
  "result": {
    "markdown": "# Working with data in python\n\n## The open function\n\n### Reading Files with Open\n\n\n\n\n\nOne way to read or write a file in Python is to use the built-in open function. The open function provides a File object that contains the methods and attributes you need in order to read, save, and manipulate the file. In this notebook, we will only cover .txt files. \n\n- The first argument is the filepath and the filename we want to open\n- The second parameter is the mode:\n    - r: open a file for reading\n    - w: open a file for writing\n    - a: open a file for appending\n    - r+ : Reading and writing. Cannot truncate the file.\n    - w+ : Writing and reading. Truncates the file.\n    - a+ : Appending and Reading. Creates a new file, if none exists.\n    \n- We store this in a file object, i.e. File1 and we can use the file object to obtain information about the file\n- You should always close the file object using the method close.\n\nPython file method close() closes the opened file. A closed file cannot be read or written any more. Any operation, which requires that the file be opened will raise a ValueError after the file has been closed. Calling close() more than once is allowed.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n#open a file\nFile1 = open(\"data/Example1.txt\", \"r\")\n\n#get the name of the file\nprint(File1.name)\n\n#see what mode the object is in\nprint(File1.mode)\n\n#get the file contents\nprint(File1.read())\n\n#get they type of the file\ntype(File1.read())\n\n#close the file\nFile1.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata/Example1.txt\nr\nThis is line 1 \nThis is line 2\nThis is line 3\n```\n:::\n:::\n\n\nSince using .close() can be tedious, we can use an alternative, the with statement. This is a better alternative, since the with statement will automatically close the file.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nwith open(\"data/Example1.txt\", \"r\") as File1:\n    #code will be performed in the indented code block\n    #The method \"read\" stores the values of the file in the variable \"file_stuff\" as a string\n    file_stuff = File1.read()\n    print(file_stuff)\n    print(File1.mode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is line 1 \nThis is line 2\nThis is line 3\nr\n```\n:::\n:::\n\n\nNotice, that we didn’t have to write “file.close()”. That will automatically be called.\n\nWe can output every line as an element in a list using the method \"readlines.\"\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nwith open(\"data/Example1.txt\", \"r\") as File1:\n    file_stuff = File1.readlines()\n    print(file_stuff)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['This is line 1 \\n', 'This is line 2\\n', 'This is line 3']\n```\n:::\n:::\n\n\nWe don’t have to read the entire file, for example, we can read the first 4 characters by entering three as a parameter to the method .read():\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Read first four characters\nwith open(\"data/Example1.txt\", \"r\") as file1:\n    print(file1.read(4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis\n```\n:::\n:::\n\n\nUse a loop to print out each line individually\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nwith open(\"data/Example1.txt\", \"r\") as File1:\n    for i in File1:\n        print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is line 1 \n\nThis is line 2\n\nThis is line 3\n```\n:::\n:::\n\n\nWe can also read all lines and save them as a list\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Read all lines and save as a list\nwith open(\"data/Example1.txt\", \"r\") as file1:\n    FileasList = file1.readlines()\n    \n#print the first line    \nFileasList[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n'This is line 1 \\n'\n```\n:::\n:::\n\n\n### Writting Files with Open\n\nCreate a new, empty example as follows:\n\n**Beware**: If we have a file with that filename in our directory, it will be overwritten!\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n#create example.txt in the specified dir\nwith open(\"data/Example2.txt\", \"w\") as File1:\n    #add something into our file\n    File1.write(\"This is line A\\n\")\n    File1.write(\"This is line B\\n\")\n```\n:::\n\n\nWe can also have a list and write this to a file\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nLines = [\"This is line A\\n\", \"This is line B\\n\", \"This is line C\\n\"]\n\nwith open(\"data/Example2.txt\", \"w\") as File1:\n    for i in Lines:\n        File1.write(i)\n```\n:::\n\n\n### Appending lines to a new file\n\nAppend will not create a new file but append lines to an existing file.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nwith open(\"data/Example2.txt\", \"a\") as File1:\n    File1.write(\"This is line D\\n\")\n```\n:::\n\n\n### Copy one file to a new file\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nwith open(\"data/Example1.txt\", \"r\") as readfile:\n    with open(\"data/Example3.txt\", \"w\") as writefile:\n        for line in readfile:\n            writefile.write(line)\n```\n:::\n\n\n### Other modes\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nwith open('data/Example2.txt', 'a+') as testwritefile:\n    testwritefile.write(\"This is line E\\n\")\n    print(testwritefile.read())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n:::\n\n\nOpening the file in w is akin to opening the .txt file, moving your cursor to the beginning of the text file, writing new text and deleting everything that follows. Whereas opening the file in a is similiar to opening the .txt file, moving your cursor to the very end and then adding the new pieces of text. It is often very useful to know where the 'cursor' is in a file and be able to control it. The following methods allow us to do precisely this -\n\n- .tell() - returns the current position in bytes\n- .seek(offset,from) - changes the position by 'offset' bytes with respect to 'from'. From can take the value of 0,1,2 corresponding to beginning, relative to current position and end\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nwith open('data/Example2.txt', 'a+') as testwritefile:\n    print(\"Initial Location: {}\".format(testwritefile.tell()))\n    data = testwritefile.read()\n    if (not data):  #empty strings return false in python\n            print('Read nothing') \n    else: \n            print(testwritefile.read())\n    \n    testwritefile.seek(0,0) # move 0 bytes from beginning.\n    \n    print(\"\\nNew Location : {}\".format(testwritefile.tell()))\n    data = testwritefile.read()\n    if (not data): \n            print('Read nothing') \n    else: \n            print(data)\n    \n    print(\"Location after read: {}\".format(testwritefile.tell()) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInitial Location: 75\nRead nothing\n\nNew Location : 0\nThis is line A\nThis is line B\nThis is line C\nThis is line D\nThis is line E\n\nLocation after read: 75\n```\n:::\n:::\n\n\nFinally, a note on the difference between w+ and r+. Both of these modes allow access to read and write methods, however, opening a file in w+ overwrites it and deletes all pre-existing data.\n**To work with a file on existing data, use r+ and a+**. While using r+, it can be useful to add a .truncate() method at the end of your data. This will reduce the file to your data and delete everything that follows.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nwith open('data/Example2.txt', 'r+') as testwritefile:\n    data = testwritefile.readlines()\n    testwritefile.seek(0,0) #write at beginning of file\n   \n    testwritefile.write(\"Line 1\" + \"\\n\")\n    testwritefile.write(\"Line 2\" + \"\\n\")\n    testwritefile.write(\"Line 3\" + \"\\n\")\n    testwritefile.write(\"finished\\n\")\n    #Uncomment the line below\n    testwritefile.truncate()\n    testwritefile.seek(0,0)\n    print(testwritefile.read())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLine 1\nLine 2\nLine 3\nfinished\n\n```\n:::\n:::\n\n\nAfter reading files, we can also write data into files and save them in different file formats like .txt, .csv, .xls (for excel files) etc. You will come across these in further examples\n\n#### Exercise\n\nYour local university's Raptors fan club maintains a register of its active members on a .txt document. Every month they update the file by removing the members who are not active. You have been tasked with automating this with your Python skills.\n\nGiven the file currentMem, Remove each member with a 'no' in their Active column. Keep track of each of the removed members and append them to the exMem file. Make sure that the format of the original files in preserved. (Hint: Do this by reading/writing whole lines and ensuring the header remains )\n\nRun the code block below prior to starting the exercise. The skeleton code has been provided for you. Edit only the cleanFiles function.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n#Run this prior to starting the exercise\nfrom random import randint as rnd\n\nmemReg = 'data/members.txt'\nexReg = 'data/inactive.txt'\nfee =('yes','no')\n\ndef genFiles(current,old):\n    with open(current,'w+') as writefile: \n        writefile.write('Membership No  Date Joined  Active  \\n')\n        data = \"{:^13}  {:<11}  {:<6}\\n\"\n\n        for rowno in range(20):\n            date = str(rnd(2015,2020))+ '-' + str(rnd(1,12))+'-'+str(rnd(1,25))\n            writefile.write(data.format(rnd(10000,99999),date,fee[rnd(0,1)]))\n\n\n    with open(old,'w+') as writefile: \n        writefile.write('Membership No  Date Joined  Active  \\n')\n        data = \"{:^13}  {:<11}  {:<6}\\n\"\n        for rowno in range(3):\n            date = str(rnd(2015,2020))+ '-' + str(rnd(1,12))+'-'+str(rnd(1,25))\n            writefile.write(data.format(rnd(10000,99999),date,fee[1]))\n\n\ngenFiles(memReg,exReg)\n```\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ndef cleanFiles(currentMem, exMem):\n    with open(currentMem, \"r+\") as writeFile:\n        with open(exMem, \"a+\") as appendFile:\n            #get the data\n            writeFile.seek(0)\n            members = writeFile.readlines()\n            #remove header\n            header = members[0]\n            members.pop(0)\n            inactive=[]\n            for member in members:\n                if 'no' in member:\n                    inactive.append(member)\n            '''\n            inactive = [member for member in members if ('no' in member)]\n            The above is the same as \n            \n            for member in members:\n            if 'no' in member:\n                inactive.append(member)\n            '''\n            #go to the beginning of the write file\n            writeFile.seek(0)\n            writeFile.write(header)\n            for member in members:\n                if (member in inactive):\n                    appendFile.write(member)\n                else:\n                    writeFile.write(member)\n            writeFile.truncate()\n```\n:::\n\n\nTest code:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nmemReg = 'data/members.txt'\nexReg = 'data/inactive.txt'\ncleanFiles(memReg,exReg)\n\n# code to help you see the files\nheaders = \"Membership No  Date Joined  Active  \\n\"\n\nwith open(memReg,'r') as readFile:\n    print(\"Active Members: \\n\\n\")\n    print(readFile.read())\n    \nwith open(exReg,'r') as readFile:\n    print(\"Inactive Members: \\n\\n\")\n    print(readFile.read())\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nActive Members: \n\n\nMembership No  Date Joined  Active  \n    41235      2018-6-11    yes   \n    20985      2018-3-8     yes   \n    62723      2015-2-22    yes   \n    69524      2015-11-12   yes   \n    70516      2018-7-11    yes   \n    81242      2016-4-5     yes   \n    41007      2018-12-15   yes   \n    56311      2018-3-20    yes   \n    50450      2016-10-6    yes   \n    67536      2018-2-4     yes   \n\nInactive Members: \n\n\nMembership No  Date Joined  Active  \n    43356      2016-12-4    no    \n    53369      2016-3-4     no    \n    74502      2016-7-20    no    \n    90400      2018-4-19    no    \n    47242      2019-9-11    no    \n    12587      2015-12-10   no    \n    41128      2017-5-15    no    \n    84168      2019-8-24    no    \n    47387      2018-11-24   no    \n    81065      2018-4-9     no    \n    49774      2020-8-23    no    \n    64207      2015-3-11    no    \n    33967      2019-11-3    no    \n\n```\n:::\n:::\n\n\nAutomated test code:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndef testMsg(passed):\n    if passed:\n       return 'Test Passed'\n    else :\n       return 'Test Failed'\n\ntestWrite = \"data/testWrite.txt\"\ntestAppend = \"data/testAppend.txt\" \npassed = True\n\ngenFiles(testWrite,testAppend)\n\nwith open(testWrite,'r') as file:\n    ogWrite = file.readlines()\n\nwith open(testAppend,'r') as file:\n    ogAppend = file.readlines()\n\ntry:\n    cleanFiles(testWrite,testAppend)\nexcept:\n    print('Error')\n\nwith open(testWrite,'r') as file:\n    clWrite = file.readlines()\n\nwith open(testAppend,'r') as file:\n    clAppend = file.readlines()\n        \n# checking if total no of rows is same, including headers\n\nif (len(ogWrite) + len(ogAppend) != len(clWrite) + len(clAppend)):\n    print(\"The number of rows do not add up. Make sure your final files have the same header and format.\")\n    passed = False\n    \nfor line in clWrite:\n    if  'no' in line:\n        passed = False\n        print(\"Inactive members in file\")\n        break\n    else:\n        if line not in ogWrite:\n            print(\"Data in file does not match original file\")\n            passed = False\nprint (\"{}\".format(testMsg(passed)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest Passed\n```\n:::\n:::\n\n\n## Pandas\n\nPandas is a popular library for data analysis built on top of the Python programming language. Pandas generally provide two data structures for manipulating data, They are:\n\n- DataFrame: a two-dimensional data structure, i.e., data is aligned in a tabular fashion in rows and columns.\n- Series: represents a one-dimensional array of indexed data. It has two main components :\n    - An array of actual data.\n    - An associated array of indexes or data labels.\n\nWe input a library, a set of pre-written functions with the import command followed by the name of the library. Since always writing the library name, we can shorten it with the as statement. Pd is the standard abbreviation often used for pandas.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nimport pandas as pd\n```\n:::\n\n\nThis gives us access to a number of pre-build classes and functions. \n\n### Loading data with pandas\n\nWe import a table with and store it in a dataframe. A dataframe is comprised of rows and columns. \n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n#read in a dataframe\ndf = pd.read_csv(\"data/file1.csv\")\n\n#examine the first 5 rows of a dataframe\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=tex}\n\\begin{tabular}{llr}\n\\toprule\n{} & Sample &  Value \\\\\n\\midrule\n0 &     S1 &    0.4 \\\\\n1 &     S2 &    0.5 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nWe also can create a dataframe out of a dictionary. The keys correspond to the table headers, the values correspond to the rows.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n#Define a dictionary 'x'\nx = {'Name': ['Rose','John', 'Jane', 'Mary'], \n        'ID': [1, 2, 3, 4], \n        'Department': ['Architect Group', 'Software Group', 'Design Team', 'Infrastructure'], \n        'Salary':[100000, 80000, 50000, 60000]}\n\n#casting the dictionary to a DataFrame\ndf = pd.DataFrame(x)\n\n#display the result df\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=tex}\n\\begin{tabular}{llrlr}\n\\toprule\n{} &  Name &  ID &       Department &  Salary \\\\\n\\midrule\n0 &  Rose &   1 &  Architect Group &  100000 \\\\\n1 &  John &   2 &   Software Group &   80000 \\\\\n2 &  Jane &   3 &      Design Team &   50000 \\\\\n3 &  Mary &   4 &   Infrastructure &   60000 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nWe can create a new df consisting of one column.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nx = df[[\"ID\"]]\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  ID \\\\\n\\midrule\n0 &   1 \\\\\n1 &   2 \\\\\n2 &   3 \\\\\n3 &   4 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nLet's use the <code>type()</code> function and check the type of the variable.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n#check the type of x\ntype(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\npandas.core.frame.DataFrame\n```\n:::\n:::\n\n\nWe can also do this for multiple columns:\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nz = df[['Department','Salary','ID']]\nz\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=tex}\n\\begin{tabular}{llrr}\n\\toprule\n{} &       Department &  Salary &  ID \\\\\n\\midrule\n0 &  Architect Group &  100000 &   1 \\\\\n1 &   Software Group &   80000 &   2 \\\\\n2 &      Design Team &   50000 &   3 \\\\\n3 &   Infrastructure &   60000 &   4 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nTo view the column as a series, we just use one bracket.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nx = df[\"Name\"]\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &  Name \\\\\n\\midrule\n0 &  Rose \\\\\n1 &  John \\\\\n2 &  Jane \\\\\n3 &  Mary \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n#check the type of x\ntype(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\npandas.core.series.Series\n```\n:::\n:::\n\n\n### loc() and iloc() functions\n\nloc() is a label-based data selecting method which means that we have to pass the name of the row or column that we want to select. This method includes the last element of the range passed in it.\n\nSimple syntax for your understanding:\n\n`loc[row_label, column_label]`\n\niloc() is an indexed-based selecting method which means that we have to pass integer index in the method to select a specific row/column. This method does not include the last element of the range passed in it.\n\nSimple syntax for your understanding:\n\n`iloc[row_index, column_index]`\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Access the value on the first row and the first column\ndf.iloc[0, 0]\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n'Rose'\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Access the value on the first row and the third column\ndf.iloc[0,2]\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n'Architect Group'\n```\n:::\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# Access the column using the name\ndf.loc[0, 'Salary']\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n100000\n```\n:::\n:::\n\n\nLet us create a new dataframe called 'df1' and assign 'df' to it. Now, let us set the \"Name\" column as an index column using the method set_index().\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ndf1=df\ndf1=df1.set_index(\"Name\")\n\n#To display the first 5 rows of new dataframe\ndf1.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```{=tex}\n\\begin{tabular}{lrlr}\n\\toprule\n{} &  ID &       Department &  Salary \\\\\nName &     &                  &         \\\\\n\\midrule\nRose &   1 &  Architect Group &  100000 \\\\\nJohn &   2 &   Software Group &   80000 \\\\\nJane &   3 &      Design Team &   50000 \\\\\nMary &   4 &   Infrastructure &   60000 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n#Now, let us access the column using the name\ndf1.loc['Jane', 'Salary']\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n50000\n```\n:::\n:::\n\n\n### Slicing\n\nSlicing uses the [] operator to select a set of rows and/or columns from a DataFrame.\n\nTo slice out a set of rows, you use this syntax: data[start:stop],\n\nhere the start represents the index from where to consider, and stop represents the index one step BEYOND the row you want to select. You can perform slicing using both the index and the name of the column.\n\n**NOTE: When slicing in pandas, the start bound is included in the output.**\n\nSo if you want to select rows 0, 1, and 2 your code would look like this: df.iloc[0:3].\n\nIt means you are telling Python to start at index 0 and select rows 0, 1, 2 up to but not including 3.\n\n**NOTE: Labels must be found in the DataFrame or you will get a KeyError.**\n\nIndexing by labels(i.e. using loc()) differs from indexing by integers (i.e. using iloc()). With loc(), both the start bound and the stop bound are inclusive. When using loc(), integers can be used, but the integers refer to the index label and not the position.\n\nFor example, using loc() and select 1:4 will get a different result than using iloc() to select rows 1:4.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# let us do the slicing using old dataframe df\ndf.iloc[0:2, 0:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```{=tex}\n\\begin{tabular}{llrl}\n\\toprule\n{} &  Name &  ID &       Department \\\\\n\\midrule\n0 &  Rose &   1 &  Architect Group \\\\\n1 &  John &   2 &   Software Group \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n#let us do the slicing using loc() function on old dataframe df where index column is having labels as 0,1,2\ndf.loc[0:2,'ID':'Department']\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```{=tex}\n\\begin{tabular}{lrl}\n\\toprule\n{} &  ID &       Department \\\\\n\\midrule\n0 &   1 &  Architect Group \\\\\n1 &   2 &   Software Group \\\\\n2 &   3 &      Design Team \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n### Working with and Saving Data\n\n#### Make a list of unique elements\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Read data from CSV file\ncsv_path = 'https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%204/data/TopSellingAlbums.csv'\ndf = pd.read_csv(csv_path)\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=tex}\n\\begin{tabular}{lllrllrrllr}\n\\toprule\n{} &           Artist &                      Album &  Released &   Length &                        Genre &  Music Recording Sales (millions) &  Claimed Sales (millions) & Released.1 & Soundtrack &  Rating \\\\\n\\midrule\n0 &  Michael Jackson &                   Thriller &      1982 &  0:42:19 &               pop, rock, R\\&B &                              46.0 &                        65 &  30-Nov-82 &        NaN &    10.0 \\\\\n1 &            AC/DC &              Back in Black &      1980 &  0:42:11 &                    hard rock &                              26.1 &                        50 &  25-Jul-80 &        NaN &     9.5 \\\\\n2 &       Pink Floyd &  The Dark Side of the Moon &      1973 &  0:42:49 &             progressive rock &                              24.2 &                        45 &  01-Mar-73 &        NaN &     9.0 \\\\\n3 &  Whitney Houston &              The Bodyguard &      1992 &  0:57:44 &               R\\&B, soul, pop &                              27.4 &                        44 &  17-Nov-92 &          Y &     8.5 \\\\\n4 &        Meat Loaf &            Bat Out of Hell &      1977 &  0:46:33 &  hard rock, progressive rock &                              20.6 &                        43 &  21-Oct-77 &        NaN &     8.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Access to the column Released\nx = df[['Released']]\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  Released \\\\\n\\midrule\n0 &      1982 \\\\\n1 &      1980 \\\\\n2 &      1973 \\\\\n3 &      1992 \\\\\n4 &      1977 \\\\\n5 &      1976 \\\\\n6 &      1977 \\\\\n7 &      1977 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n#apply the unique method to remove duplicated years\ndf['Released'].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\narray([1982, 1980, 1973, 1992, 1977, 1976])\n```\n:::\n:::\n\n\n### Selecting rows by conditions\n\nLets find all the albums released after 1980\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n#find albums after 1980\n#the results is a list of boolean values\nprint(df[\"Released\"]>=1980)\n\n#select the specified columns from our dataframe\ndf1 = df[df[\"Released\"]>=1980]\ndf1.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0     True\n1     True\n2    False\n3     True\n4    False\n5    False\n6    False\n7    False\nName: Released, dtype: bool\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=38}\n```{=tex}\n\\begin{tabular}{lllrllrrllr}\n\\toprule\n{} &           Artist &          Album &  Released &   Length &           Genre &  Music Recording Sales (millions) &  Claimed Sales (millions) & Released.1 & Soundtrack &  Rating \\\\\n\\midrule\n0 &  Michael Jackson &       Thriller &      1982 &  0:42:19 &  pop, rock, R\\&B &                              46.0 &                        65 &  30-Nov-82 &        NaN &    10.0 \\\\\n1 &            AC/DC &  Back in Black &      1980 &  0:42:11 &       hard rock &                              26.1 &                        50 &  25-Jul-80 &        NaN &     9.5 \\\\\n3 &  Whitney Houston &  The Bodyguard &      1992 &  0:57:44 &  R\\&B, soul, pop &                              27.4 &                        44 &  17-Nov-92 &          Y &     8.5 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n### Save dataframes\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n#save new df to csv\ndf.to_csv(\"data/new_songs.csv\")\n```\n:::\n\n\n## Numpy\n\nNumpy is a package for scientific computing and has many useful functions.\n\n### Basics\n\nNumPy is a Python library used for working with arrays, linear algebra, fourier transform, and matrices.A numpy array is similar to a list. NumPy stands for Numerical Python and it is an open source project.The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy.\n\nArrays are very frequently used in data science, where speed and resources are very important.\n\nNumPy is usually imported under the np alias.\n\nIt's usually fixed in size and each element is of the same type. We can cast a list to a numpy array by first importing numpy:\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n#load numpy\nimport numpy as np\n\n#The version string is stored under version attribute.\nprint(np.__version__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.18.1\n```\n:::\n:::\n\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n#create an array\na = np.array([0,1,2,3,4])\nprint(a)\n\n#access individual elements\nprint(a[2])\n\n#check the type\nprint(type(a))\n\n#obtain the data type of the array element\nprint(a.dtype)\n\n#check the attribute size, the number of elements in the array\nprint(a.size)\n\n#show the array dimensions\nprint(a.ndim)\n\n#show the size of the array in each dimension\nprint(a.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4]\n2\n<class 'numpy.ndarray'>\nint64\n5\n1\n(5,)\n```\n:::\n:::\n\n\n### Indexing and slicing\n\nChange elements of an array:\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n#define an array\nc = np.array([20,1,2,3,4])\nprint(c)\n\n#change the first element to 100\nc[0]=100\nprint(c)\n\n#change the 5th element\nc[4]=5\nprint(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[20  1  2  3  4]\n[100   1   2   3   4]\n[100   1   2   3   5]\n```\n:::\n:::\n\n\nLike lists, we can slice the numpy array. Slicing in python means taking the elements from the given index to another given index.\n\nWe pass slice like this: [start:end].\n\nWe can select the elements from 1 to 3 and assign it to a new numpy array as follows:\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n#select the elements from 1 to 3\nprint(c[1:4])\n\n## Set the fourth element and fifth element to 300 and 400\nc[3:5] = 300, 400\nprint(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3]\n[100   1   2 300 400]\n```\n:::\n:::\n\n\nWe can also define the steps in slicing, like this: [start:end:step].\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\narr = np.array([1, 2, 3, 4, 5, 6, 7])\nprint(arr[1:5:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 4]\n```\n:::\n:::\n\n\nIf we don't pass start its considered 0\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nprint(arr[1:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 3 4 5]\n```\n:::\n:::\n\n\nIf we don't pass end it considers till the length of array.\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\nprint(arr[3:])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4 5 6 7]\n```\n:::\n:::\n\n\nIf we don't pass step its considered 1\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nprint(arr[1:5:])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 3 4 5]\n```\n:::\n:::\n\n\n### Basic operations\n\n#### Vector addition and subtraction\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n#define some vectors\nu = np.array([1,0])\nv = np.array([0,1])\n\n#add vectors\nz = u+v\nprint(z)\n\n#subtract vectors\nz = u-v\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 1]\n[ 1 -1]\n```\n:::\n:::\n\n\n#### Array multiplication with a scalar\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\ny = np.array([1,2])\n\n#multiply vector\nz= 2*y\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 4]\n```\n:::\n:::\n\n\n#### Product of two numpy arrays\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\nu = np.array([1,2])\nv = np.array([3,2])\n\n#multiply two vectors\nz = u*v\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3 4]\n```\n:::\n:::\n\n\n#### Dot products \n\nThe dot product is a single number given by the following term and represents how similar two vectors are.\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\nu = np.array([1,2])\nv = np.array([3,1])\n\n#dot product\n#1*3 + 2*5\nresult = np.dot(u,v)\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\n#### Adding constant to a numpy array \n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\nu = np.array([1,2,3,-1])\n\n#add a scalar to each element of an array, i.e. broadcasting\nz = u + 1\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 3 4 0]\n```\n:::\n:::\n\n\n### Universal functions\n\nA universal function is a function that operates on ND arrays. We can apply a universal function to a numpy array. \n\n#### Calculating the mean of an array\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\na = np.array([1,-1,1,-1])\n\n#calculate the mean\nmean_a = a.mean()\nprint(mean_a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.0\n```\n:::\n:::\n\n\n#### Standard deviation\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\na = np.array([1,-1,1,-1])\n\nsdev = a.std()\nprint(sdev)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.0\n```\n:::\n:::\n\n\n#### Find the max and min\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\nb = np.array([1,-2,3,4,5])\n\n#calculate the mean\nmax_b = b.max()\nprint(max_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\nWe can use numpy to create functions that map numpy arrays to new numpy arrays.\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n#access pi with\nprint(np.pi)\n\n# We can create the following numpy array in radians\nx = np.array([0,np.pi/2,np.pi])\n\n#apply the function sin to our array x\n#this way we apply the sin function to each element in the array\ny = np.sin(x)\n\n#the result is a new array, y\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.141592653589793\n[0.0000000e+00 1.0000000e+00 1.2246468e-16]\n```\n:::\n:::\n\n\n#### Using Linspace\n\nA useful function for plotting mathematical functions is **line space**. Line space returns evenly spaced numbers over specified interval. We specify the starting point of the sequence, the ending point of the sequence. The parameter num indicates the number of samples to generate, in this case five.\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\nprint(np.linspace(-2,2,num=5))\nprint(np.linspace(-2,2,num=9))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[-2. -1.  0.  1.  2.]\n[-2.  -1.5 -1.  -0.5  0.   0.5  1.   1.5  2. ]\n```\n:::\n:::\n\n\nPlotting mathematics functions: We can use the function line space to generate 100 evenly spaced samples from the interval zero to two pie. We can use the numpy function sin to map the array x to a new array y. We can import the library pyplot as plt to help us plot the function.\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n#generate 100 evenly spaced samples from the interval zero to two pie\nx = np.linspace(0,2*np.pi,100)\n\n#use sin to map the array x to a new array y\ny = np.sin(x)\n\n#import the matplot lib to help us plot the function\nimport matplotlib.pyplot as plt\n\n#plot the graph\n#first value = values plotted on x-axis, second input = values plotted on x-axis\nplt.plot(x,y)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Week4_Files_Pandas_Numpy_files/figure-pdf/cell-59-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n#### Iterating 1-D Arrays\n\nterating means going through elements one by one.\n\nIf we iterate on a 1-D array it will go through each element one by one.\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\narr1 = np.array([1, 2, 3])\n\nfor x in arr1:\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n```\n:::\n:::\n\n\n#### Plot arrays\n\nGenerate a function for plotting\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\n# Import the libraries\nimport time \nimport sys\nimport numpy as np \n\nimport matplotlib.pyplot as plt\n\ndef Plotvec2(a,b):\n    ax = plt.axes()# to generate the full window axes\n    ax.arrow(0, 0, *a, head_width=0.05, color ='r', head_length=0.1)#Add an arrow to the  a Axes with arrow head width 0.05, color red and arrow head length 0.1\n    plt.text(*(a + 0.1), 'a')\n    ax.arrow(0, 0, *b, head_width=0.05, color ='b', head_length=0.1)#Add an arrow to the  b Axes with arrow head width 0.05, color blue and arrow head length 0.1\n    plt.text(*(b + 0.1), 'b')\n    plt.ylim(-2, 2)#set the ylim to bottom(-2), top(2)\n    plt.xlim(-2, 2)#set the xlim to left(-2), right(2)\n```\n:::\n\n\nPlot:\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\narr1 = np.array([-1,1])\narr2 = np.array([1,1])\n\nPlotvec2(arr1,arr2)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Week4_Files_Pandas_Numpy_files/figure-pdf/cell-62-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n### 2D numpy arrays\n\nLet's first create a nested list with 3 lists, each of equal size.\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\na = np.array([[1,3,4],[10,11,12]])\nprint(a)\n\n#cast the list to a numpy array\n# each separate list = 1 row in the matrix\nA = np.array(a)\nprint(A)\n\n#We can use the attribute ndim to obtain the number of axes or dimensions\n#referred to as the rank \nprint(A.ndim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 1  3  4]\n [10 11 12]]\n[[ 1  3  4]\n [10 11 12]]\n2\n```\n:::\n:::\n\n\nIt's useful to think of ndim as the number of nested lists. The first list represents the first dimension. This list contains another set of lists. This represents the second dimension or axis. The number of lists the list contains does not have to do with the dimension but the shape of the list.\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\n#Attribute shape returns a tuple corresponding to the size or number of each dimension.\nprint(A.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(2, 3)\n```\n:::\n:::\n\n\nThe first element in the tuple corresponds to the number of nested lists contained in the original list or the number of rows in the rectangular representation, in this case three. The second element corresponds to the size of each of the nested list or the number of columns in the rectangular array zero.\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\n#The total number of elements in the array is given by the attribute size.\nprint(A.size)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n```\n:::\n:::\n\n\nWe see there are three rows and three columns. Multiplying the number of columns and rows together, we get the total number of elements, in this case nine.\n\nWe can use rectangular brackets to access the different elements of the array. The index in the first bracket corresponds to the different nested lists each a different color. The second bracket corresponds to the index of a particular element within the nested list. Using the rectangular representation, the first index corresponds to the row index. The second index corresponds to the column index.\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\n#get the second row and third column\nprint(A[1][2])\n\n#get the first row and first column\nprint(A[0][0])\nprint(A[0,0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12\n1\n1\n```\n:::\n:::\n\n\nWe can also slice:\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\n#get the first row and the first 2 columns\nprint(A[0,0:2])\n\n#get the first 2 rows and the 3rd column\nprint(A[0:2,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 3]\n[ 4 12]\n```\n:::\n:::\n\n\nWe can also add (or use other mathematical operations) on two arrays:\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\n#define two arrays\nX = np.array([[1,0],[0,1]])\nY = np.array([[2,1],[1,2]])\n\n#view arrays\nprint(X)\nprint(Y)\n\n#combine the arrays\nprint(X+Y)\n\n#perform matrix multiplication on the numpy arrays  A and  B\nprint(np.dot(X,Y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 0]\n [0 1]]\n[[2 1]\n [1 2]]\n[[3 1]\n [1 3]]\n[[2 1]\n [1 2]]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "Week4_Files_Pandas_Numpy_files/figure-pdf"
    ],
    "filters": []
  }
}