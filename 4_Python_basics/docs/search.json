[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python basics",
    "section": "",
    "text": "This is a python basics tutorial"
  },
  {
    "objectID": "code/Week1-Basics.html",
    "href": "code/Week1-Basics.html",
    "title": "2  Python Basics",
    "section": "",
    "text": "A type is how Python represents different types of data\nTypes can be types of the following.:\n\nIntegers, like 11 (an example of the datatype int, integer)\nReal numbers, like 21.21 (an example of the datatype float)\nWords, like “Hello, world” (an example of the datatype str, string)\n\nWe can identify the type of our data with the type() command\n\ntype(11)\ntype(2.1)\ntype(\"Hello\")\n\n\n\nint, i.e. 1,2,3\ncan be negative or positive\nthere is a finite, but large range of integers\n\n\n\n\n\nInclude integers but also numbers in between integers, i.e. 0.3 or 0.33\nThere is limit, but it is quite small\n\n\n\n\n\nBoolean can take on two values: True and False (beware, first letter is upper case)\nint(True) gives 1\nint(False) gives 0\n\n\n\n\n\nWe can change the type of our data\nthis is also called type casting\nConvert an int to a float: float(2) gives 2.0\nConvert an integer to a float:\n\nint(1.1) gives 1\nHowever, beware we loose some information here\nalso int(3.99) gives 3 , so , the conversion truncates towards zero, i.e.you just get rid of the numbers after the decimal place\n\nconvert an int to a string: str(1) becomes “1”"
  },
  {
    "objectID": "code/Week1-Basics.html#expressions-and-variables",
    "href": "code/Week1-Basics.html#expressions-and-variables",
    "title": "2  Python Basics",
    "section": "2.2 Expressions and variables",
    "text": "2.2 Expressions and variables\n\n2.2.1 Expressions\n\nExpressions: a type of operation the computers perform & operations that python performs, i.e. 32 + 10 results in 42. The numbers in the expression are called operands and the math symbols are called operators.\nThe symbol \\\\ means integer symbol and results in results being rounded down. I.e. 11\\\\2 becomes 5\n\n\n\n2.2.2 Variables\n\nWe use variables to store values, i.e. my_variable=1. Here, the value of 1 is assigned to the variable my_variable. By typing the exact name of the variable, we can use it elsewhere in the code.\nIf we do my_variable=10, then we assign a new value to my_variable and the old value is lost\nWe can store also the results of expressions in a value and perform operations on variables\nUse meaningful variable names\n\ncommonly an underscore is used to mark the beginning of a new word, i.e. total_min"
  },
  {
    "objectID": "code/Week1-Basics.html#exercise",
    "href": "code/Week1-Basics.html#exercise",
    "title": "2  Python Basics",
    "section": "2.3 Exercise:",
    "text": "2.3 Exercise:\nCheck the lab PY0101EN-1-1-Write_your_first_python_code.ipynb\nIn addition to writing code, note that it’s always a good idea to add comments to your code. It will help others understand what you were trying to accomplish (the reason why you wrote a given snippet of code). Not only does this help other people understand your code, it can also serve as a reminder to you when you come back to it weeks or months later.\nTo write comments in Python, use the number symbol # before writing your comment. When you run your code, Python will ignore everything past the # on a given line. After executing the cell above, you should notice that Try your first Python output a string did not appear in the output, because it was a comment (and thus ignored by Python).\n\n# Try your first Python output\nprint('Hello, Python!')\n\nHello, Python!\n\n\n\n2.3.1 What version of Python are we using?\nThere are two popular versions of the Python programming language in use today: Python 2 and Python 3. The Python community has decided to move on from Python 2 to Python 3, and many popular libraries have announced that they will no longer support Python 2.\nSince Python 3 is the future, in this course we will be using it exclusively. How do we know that our notebook is executed by a Python 3 runtime? We can look in the top-right hand corner of this notebook and see “Python 3”.\nWe can also ask Python directly and obtain a detailed answer. Try executing the following code:\n\n# Check the Python Version\nimport sys\nprint(sys.version)\n\n3.7.6 (default, Jan  8 2020, 13:42:34) \n[Clang 4.0.1 (tags/RELEASE_401/final)]\n\n\nsys is a built-in module that contains many system-specific parameters and functions, including the Python version in use. Before using it, we must explictly import it.\n\n\n2.3.2 Errors in Python\nEveryone makes mistakes. For many types of mistakes, Python will tell you that you have made a mistake by giving you an error message. It is important to read error messages carefully to really understand where you made a mistake and how you may go about correcting it.\nFor example, if you spell print as frint, Python will display an error message. Give it a try:\n# Try your first Python output\nfrint('Hello, Python!')\nThe error message tells you:\nwhere the error occurred (more useful in large notebook cells or scripts), and what kind of error it was (NameError) Here, Python attempted to run the function frint, but could not determine what frint is since it’s not a built-in function and it has not been previously defined by us either.\nYou’ll notice that if we make a different type of mistake, by forgetting to close the string, we’ll obtain a different error (i.e., a SyntaxError). Try it below:\n# Try your first Python output\nprint(\"Hello, Python!)\n\n\n2.3.3 Does Python know about your error before it runs your code?\nPython is what is called an interpreted language. Compiled languages examine your entire program at compile time, and are able to warn you about a whole class of errors prior to execution. In contrast, Python interprets your script line by line as it executes it. Python will stop executing the entire program when it encounters an error (unless the error is expected and handled by the programmer, a more advanced subject that we’ll cover later on in this course).\nTry to run the code in the cell below and see what happens:\nprint(\"This will be printed\")\nfrint(\"This will cause an error\")\nprint(\"This will NOT be printed\")\n\n\n2.3.4 learn more about the specifics of floats for your runtime environment\n\nsys.float_info\n\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)"
  },
  {
    "objectID": "code/Week1-Basics.html#string-operations",
    "href": "code/Week1-Basics.html#string-operations",
    "title": "2  Python Basics",
    "section": "2.4 String operations",
    "text": "2.4 String operations\n\nA sequence of characters, which are contained withing two quotes. I.e. “Hello world” or ‘Hello world’\nA string can be spaces or digits, i.e. “1 2 3”\nA string can also be special characters\nA string can be bound in a variable and each part can be accessed by its index, i.e. “Hello world” would have the indexes 012345(space)678910. We can for example access the H with variable[0]\nWe can also use negative indexing and the last index is given with negative 1, i.e. -11-10-9-8-7-6(space)-5-4-3-2-1. Here, variable[-1]0 gives d\nWe can also perform a sequence operation”\n\nvariable[0-3] gives Hell\nvariable[::2] gives every 2nd variable\nvariable[0:5:2]: we perform slicing and return every 2nd variable up to index 4\nlen(variable) gives the length of the string\nWe can concatenate or combine strings, i.e. variable + \"everyone\"\nWe can replicate values of a string, i.e. 3* variable\n\nString are immutable, i.e this does not work\nTip]: When taking the slice, the first number means the index (start at 0), and the second number means the length from the index to the last element you want (start at 1)\n\nname = \"hello world\"\nname[0] = \"J\"\nbut we can create a new string like this:\nname = name + \"everyone\"\n\nBackslashes, ’' indicate the beginning of escape sequences.\n\nEscape sequences = strings that might be difficult to input\ni.e. print(\"Hello \\n world\"), here \\n represents a new line\n’ represents a tab\nIf we want to use an actual backslash in the string we do it like this Hello \\\\ world\nprint(r\"Hello \\ World\") is an alternative way to use the literal backslash"
  },
  {
    "objectID": "code/Week1-Basics.html#string-methods",
    "href": "code/Week1-Basics.html#string-methods",
    "title": "2  Python Basics",
    "section": "2.5 String methods",
    "text": "2.5 String methods\n\nStrings are sequences and as such have apply methods that work on list and tubles = Sequence methods\nStrings also have a set of methods that just work on strings: String methods\nWhen we apply a method to a string A, we get a new string B\nLets start with defining a string with mixed cases\n\nA = \"Hello World\"\n\nthe method ‘upper()’ converts lower case to upper case characters, HELLO WORLD\n\nB = A.upper()\n\nthe method ‘replace()’ changes part of the string to another ; Hello People\n\nB = A.replace(\"World\", \"People\")\n\nthe ‘find()’ method finds substrings and uses the argument which substring we want to find; i.e. the output is the first index of the sequence; i.e. 2. If the sub-string is not in the string then the output is a negative one. For example, the string ‘Jasdfasdasdf’ is not a substring:\n\nB = A.find(ll)\n\n2.5.1 Excercise\n\nx=1/1\ntype(x)\n\nfloat"
  },
  {
    "objectID": "code/Week2-Lists_Tuples.html",
    "href": "code/Week2-Lists_Tuples.html",
    "title": "3  Python: Lists and Tuples",
    "section": "",
    "text": "= Compound data types"
  },
  {
    "objectID": "code/Week2-Lists_Tuples.html#tuples",
    "href": "code/Week2-Lists_Tuples.html#tuples",
    "title": "3  Python: Lists and Tuples",
    "section": "3.1 Tuples",
    "text": "3.1 Tuples\n\nAn ordered sequence\nComma separated elements within parentheses\n\n\nRatings = (10,9,6,4,10,8,8,6)\nRatings\n\n(10, 9, 6, 4, 10, 8, 8, 6)\n\n\n\nStrings, integers and floats can all be contained in a tuple\n\n\ntuple1 = ('disco', 10, 1.2)\ntuple1\n\n('disco', 10, 1.2)\n\n\n\nWe can access each element of a tuple via an index\n\n\n3.1.1 Indexing tuples\n\n#access the first element\ntuple1[0]\n\n#access the third element\ntuple1[2]\n\n#access the last element\ntuple1[-1]\n\n1.2\n\n\n\n\n3.1.2 Adding tuples\n\nWe can combine tuples, by adding them\n\n\ntuple2 =  tuple1 + (\"hard rock\", 10)\ntuple2\n\n('disco', 10, 1.2, 'hard rock', 10)\n\n\n\n\n3.1.3 Slice tuples\n\nIf we want multiple elements from a tuple, we can slice tuples\n\n\n#get the first 3 elements, the last index is on larger than the index we want\ntuple2[0:3]\n\n('disco', 10, 1.2)\n\n\n\n\n3.1.4 Get the length of tuples\n\nWe get the length of a tuple with the len() command\n\n\nlen(tuple2)\n\n5\n\n\n\n\n3.1.5 Tuples are immutable\n\nTuples are immutable = we can not change them but we can assign a different tuple to the ratings variable. So if we want to manipulate a tuple we have to create a new tuple instead\n\n\n#store ratings in a new variable\nRatings1 = Ratings\n\n#we can not use Ratings[2]=2 to change the 2nd element of a tuple\n#but we can change the contents of our variable with:\nRatings = (1,4,2)\n\n#we can also sort a tuple and store it in a new variable\nRatings_sorted = sorted(Ratings)\nRatings_sorted\n\n[1, 2, 4]\n\n\n\n\n3.1.6 Nesting tuples\n\nA tuple can be nested = i.e. contain other tuples\n\n\nNT = (1,2,(\"pop\", \"rock\"), (3,4), (\"disco\",(1,2)))\nNT\n\n#access the second element\nNT[2]\n\n#access the 2nd element inside it\nNT[2][1]\n\n'rock'"
  },
  {
    "objectID": "code/Week2-Lists_Tuples.html#lists",
    "href": "code/Week2-Lists_Tuples.html#lists",
    "title": "3  Python: Lists and Tuples",
    "section": "3.2 Lists",
    "text": "3.2 Lists\n\nOrdered sequences\nRepresented by square brackets\nLists are mutable\nOtherwise shares similar respects than tuples (i.e. using an index, slicing, nesting, combining them by adding)\n\n\nL = [\"Michael Jackson\", 10.1, 1982]\nL\n\n['Michael Jackson', 10.1, 1982]\n\n\n\n3.2.1 Extending lists\n\nWe can extend list, i.e. modify it, using the extend() function\n\n\nL = [\"Michael Jackson\", 10.1, 1982]\nL.extend([\"pop\",10])\nL\n\n['Michael Jackson', 10.1, 1982, 'pop', 10]\n\n\n\n\n3.2.2 Appending lists\n\nWe can also append a list, i.e. we add only one element to a list\n\n\nL = [\"Michael Jackson\", 10.1, 1982]\nL.append([\"pop\",10])\nL\n\n['Michael Jackson', 10.1, 1982, ['pop', 10]]\n\n\n\n\n3.2.3 Extending lists\n\nextend() adds two new elements to the list\n\n\nL = [\"Michael Jackson\", 10.1, 1982]\nL.extend([\"pop\",10])\nL\n\n['Michael Jackson', 10.1, 1982, 'pop', 10]\n\n\n\n\n3.2.4 Lists are mutable\n\nWe can change elements in lists\n\n\n#change the first element in the list\nL = [\"Michael Jackson\", 10.1, 1982]\nL[0] = \"hard rock\"\nL\n\n['hard rock', 10.1, 1982]\n\n\n\n\n3.2.5 Delete elements in lists\n\nWe can delete an element in a list with the del() command\n\n\n#delete the first element in the list\nL = [\"Michael Jackson\", 10.1, 1982]\ndel(L[0])\nL\n\n[10.1, 1982]\n\n\n\n\n3.2.6 Converting strings to lists\n\nWe can convert a string to a list using split()\n\n\n#normally split, splits strings by the space\n\"hard rock\".split()\n\n#we can also use a specific character, i.e. a delimiter, which we add as an argument\n\"A,B,C,D\".split(\",\")\n\n['A', 'B', 'C', 'D']\n\n\n\n\n3.2.7 Aliasing\n\nAliasing = Multiple names referring to the same object\n\n\n#make an alias\nA = [\"hard rock\", 10, 1.2]\nB = A\n\n#if we now change A, B change as well!\nA[0] = \"banana\"\nA\nB\n\n['banana', 10, 1.2]\n\n\n\n\n3.2.8 Cloning\n\nWe can clone list A using the following syntax\n\n\n#clone a list\nA = [\"hard rock\", 10, 1.2]\nB = A[:]\n\n#if we now change A, B will not change\nA[0] = \"banana\"\nA\nB\n\n['hard rock', 10, 1.2]"
  },
  {
    "objectID": "code/Week2-Lists_Tuples.html#exercise-a",
    "href": "code/Week2-Lists_Tuples.html#exercise-a",
    "title": "3  Python: Lists and Tuples",
    "section": "3.3 Exercise A",
    "text": "3.3 Exercise A\nSee Module 2_PY0101EN-2-2-Lists.ipynb"
  },
  {
    "objectID": "code/Week2-Lists_Tuples.html#dictionaries",
    "href": "code/Week2-Lists_Tuples.html#dictionaries",
    "title": "3  Python: Lists and Tuples",
    "section": "3.4 Dictionaries",
    "text": "3.4 Dictionaries\n\nDictionaries = A type of collection in python\nConsists of keys and values\n\nKey = analogous to the index. They are like addresses but don’t have to be integers and usually are characters. The are immutable and unique\nValues are similar to the element in a list and contain information. The values can be immutable, mutable and duplicates.\n\nDictionaries are generated using curly brackets and the keys are the first elements. Each key is followed by a value followed by a colon. Each key/value pair is separated by a comma\n\n\n3.4.1 Generating a dictionary\n\ndic1 = {\"key1\":1, \"key2\":\"2\", \"key3\":[3,3,3], \"key4\":(4,4,4), \"key5\":5}\ndic1\n\n{'key1': 1, 'key2': '2', 'key3': [3, 3, 3], 'key4': (4, 4, 4), 'key5': 5}\n\n\n\nThe key is used to look up the value\n\n\ndic1[\"key2\"]\n\n'2'\n\n\n\n\n3.4.2 Adding new elements to dictionaries\n\ndic1[\"key6\"]=\"hello\"\ndic1\n\n{'key1': 1,\n 'key2': '2',\n 'key3': [3, 3, 3],\n 'key4': (4, 4, 4),\n 'key5': 5,\n 'key6': 'hello'}\n\n\n\n\n3.4.3 Delete an entry in a dictionary\n\ndel(dic1[\"key6\"])\ndic1\n\n{'key1': 1, 'key2': '2', 'key3': [3, 3, 3], 'key4': (4, 4, 4), 'key5': 5}\n\n\n\n\n3.4.4 Verify if an element is in the dictionary using the in command\n\n\"key2\" in dic1\n\"key12\" in dic1\n\nFalse\n\n\n\n\n3.4.5 Print all the keys in a dictionary via the keys() command\n\ndic1.keys()\n\ndict_keys(['key1', 'key2', 'key3', 'key4', 'key5'])\n\n\n\n\n3.4.6 Print all the values in a dictionary via the values() command\n\ndic1.values()\n\ndict_values([1, '2', [3, 3, 3], (4, 4, 4), 5])\n\n\n\n\n3.4.7 Exercise\nSee: Module 2_PY0101EN-2-4-Dictionaries.ipynb"
  },
  {
    "objectID": "code/Week2-Lists_Tuples.html#sets",
    "href": "code/Week2-Lists_Tuples.html#sets",
    "title": "3  Python: Lists and Tuples",
    "section": "3.5 Sets",
    "text": "3.5 Sets\n\nA type of collection: like with lists and tuples, we can input different python types\nUnlike lists and tuples they are unordered, this means that sets do not record element positions\nSets only have unique elements: there is only one of a particular element in a set\nTo define a set, we use curly brackets and place the elements of a set inside\n\n\n3.5.1 Making a set\n\n#generate a set with duplicate items\nset1 = {\"pop\", \"rock\", \"soul\", \"hard rock\", \"rock\"}\n\n#view set: duplicate items are not present when the set is created\nset1\n\n{'hard rock', 'pop', 'rock', 'soul'}\n\n\n\n\n3.5.2 Converting a list to a set with the function set()\n\nThis process is called type casting\n\n\n#create a list\nalbum_list = [\"Jackson\", \"Thriller\", \"Thriller\", 1982]\nalbum_list\n\n#convert to a set (notice the lack of duplicated elements)\nalbum_set = set(album_list)\nalbum_set\n\n{1982, 'Jackson', 'Thriller'}\n\n\n\n\n3.5.3 Set Operations\n\nSet operations can be used to change the set\n\n\n\n3.5.4 Add items with the add() method\n\n#create a set\nA = {\"Thriller\", \"Back in black\", \"AC/DC\"}\n\n#add an item\nA.add(\"NSYNC\")\nA\n\n#add the same item twice (and nothing will happen)\nA.add(\"NSYNC\")\nA\n\n{'AC/DC', 'Back in black', 'NSYNC', 'Thriller'}\n\n\n\n\n3.5.5 Remove items from a set\n\n#remove an item\nA.remove(\"NSYNC\")\nA\n\n{'AC/DC', 'Back in black', 'Thriller'}\n\n\n\n\n3.5.6 Check if elements are in a set\n\n\"AC/DC\" in A\n\"Who\" in A\n\nFalse\n\n\n\n\n3.5.7 Mathematical operations\n\n#define two sets\nset1 = {\"Back in black\", \"AC/DC\", \"Thriller\"}\nset2 = {\"AC/DC\", \"Back in black\", \"Dark side of the moon\"}\nset3 = {\"Back in black\", \"AC/DC\"}\n\n#define the intersection with `&`\nset3 = set1 & set2\nset3\n\n#create the union of both sets, ie. all the elements found in both sets\nset1.union(set2)\n\n#check if a set is a subset of another\nset3.issubset(set1)\n\n#find all the elements that are only contained in a set using the difference method\nset1.difference(set3)\n\n# check if a set is a superset or subset of another set\nset1.issuperset(set3)\nset3.issuperset(set1)\n\nFalse\n\n\n\n#define two sets with numbers\nA = [1, 2, 2, 1]\nA\n\nB = set([1, 2, 2, 1])\nB\n\n#compare the two sets\nsum(A) == sum(B)\n\n#to explain the result:\nprint(\"the sum of A is:\", sum(A))\nprint(\"the sum of B is:\", sum(B))\n\nthe sum of A is: 6\nthe sum of B is: 3"
  },
  {
    "objectID": "code/Week2-Lists_Tuples.html#exercise-1",
    "href": "code/Week2-Lists_Tuples.html#exercise-1",
    "title": "3  Python: Lists and Tuples",
    "section": "3.6 Exercise",
    "text": "3.6 Exercise"
  },
  {
    "objectID": "code/Week3_Conditions_a_branching.html",
    "href": "code/Week3_Conditions_a_branching.html",
    "title": "4  Conditions and branching",
    "section": "",
    "text": "#test for equality\na = 6\na == 7\n\n#greater than\ni = 6\ni > 5\n\n#greater than or equal to\ni = 5\ni >= 5\n\n#test for inequality\ni = 5\ni != 6\n\n#we can compare strings as well\n\"AC/DC\" == \"Thriller\"\n\"AC/DC\" != \"Thriller\"\n\nTrue"
  },
  {
    "objectID": "code/Week3_Conditions_a_branching.html#branching",
    "href": "code/Week3_Conditions_a_branching.html#branching",
    "title": "4  Conditions and branching",
    "section": "4.2 Branching",
    "text": "4.2 Branching\n\nBranching allows us to run different statements for different input\n\n\n4.2.1 The if statement\nIf a statement is true, then you can enter the room and run some pre-defined task. If the statement is false, our program will skip the task.\nAs an example, make a statement were you only can enter a concert if you are older than 19\n\n#define our age\nage = 20\n\n#run the statement\nif (age>18):\n  print(\"you can enter the concert\")\nprint(\"move on\")\n\nyou can enter the concert\nmove on\n\n\n\n\n4.2.2 The else statement\n\nThe else statement will run a different block of code if the same condition is false.\nNow lets say that they can not go to ACDC if they are less than 18 but they can go to the meat loaf concert. If they are over 18 they go to the ACDC concert\n\n\n#define our age\nage = 17\n\n#run the statement\nif (age>18):\n  print(\"you can enter the ACDC concert\")\nelse:\n  print(\"go see Meat Loaf\")\nprint(\"move on\")\n\ngo see Meat Loaf\nmove on\n\n\n\n\n4.2.3 The elif statement\n\nThe elif statement, short for else-if, allows us to check additional conditions if the preceding condition is false. If the condition is true, the alternate expressions will be run\nFor example: If we are 18, we will go to Pink Floyd instead of ACDC or Meat Loaf. For less than 18 and older than 18 the old rules apply.\n\n\n#define our age\nage = 18\n\n#run the statement\nif (age>18):\n  print(\"you can enter the ACDC concert\")\nelif(age==18):\n  print(\"go see Pink Floyd\")\nelse:\n  print(\"go see Meat Loaf\")\nprint(\"move on\")\n\ngo see Pink Floyd\nmove on"
  },
  {
    "objectID": "code/Week3_Conditions_a_branching.html#logic-operators",
    "href": "code/Week3_Conditions_a_branching.html#logic-operators",
    "title": "4  Conditions and branching",
    "section": "4.3 Logic operators",
    "text": "4.3 Logic operators\n\nLogic operators take boolean values and produce different boolean values\n\n\n4.3.1 The or operator\n\nalbum_year = 1981\n\nif(album_year <1980) or (album_year > 1989):\n  print(\"The album was made in the 70s or 90s\")\nelse:\n  print(\"The Album was made in the 80s\")\n\nprint(\"\")\n\nThe Album was made in the 80s\n\n\n\n\n\n4.3.2 The and operator\n\nalbum_year = 1981\n\nif(album_year > 1979) and (album_year < 1990):\n  print(\"The album was made in the 80s\")\n\nprint(\"\")\n\nThe album was made in the 80s\n\n\n\n\n\n4.3.3 The not statement\nThe not statement checks if the statement is false:\n\n# Condition statement example\nalbum_year = 1984\n\nif not (album_year == 1984):\n    print (\"Album year is not 1984\")\n\nprint(\"\")"
  },
  {
    "objectID": "code/Week3_Conditions_a_branching.html#loops",
    "href": "code/Week3_Conditions_a_branching.html#loops",
    "title": "4  Conditions and branching",
    "section": "4.4 Loops",
    "text": "4.4 Loops\n\n4.4.1 The range function\nThe range function outputs and ordered sequence as a list I. If the input is a positive integer, the output is a sequence. The sequence contains the same number of elements as the input but starts at zero.\nIn Python 3, range() creates an object of type range.. An object of type range does not store values, but creates when needed, so its values are not displayed with print(). Since it is an iterable object, the value can be printed in the for loop.\n\n\n4.4.2 For loops\nLoops perform a task over and over again.\nLets try to print the values of a range.\n\nfor i in range(3):\n    print(i)\n\n0\n1\n2\n\n\n\nfor i in range(12,15):\n    print(i)\n\n12\n13\n14\n\n\nFor a list of colors, replace each color value with white.\n\nsquares = [\"red\", \"yellow\", \"green\"]\n\nfor i in range(0,3):\n    squares[i]=\"white\"\n\nsquares\n\n['white', 'white', 'white']\n\n\nIterate through a list without a range:\n\nsquares = [\"red\", \"yellow\", \"green\"]\n\nfor i in squares:\n    i\n\nsquares\n\n['red', 'yellow', 'green']\n\n\nAnother example: print all years present in a list with dates:\n\n#define the list\ndates = [1982, 1980, 1973]\n\n#calculate the length of the index\nN = len(dates)\n\n#execute the code N times\nfor i in range(N):\n    print(dates[i])\n\n1982\n1980\n1973\n\n\nAlternatively, we can access the elements like this:\n\n#define the list\ndates = [1982, 1980, 1973]\n\n#execute the code N times\nfor i in dates:\n    print(i)\n\n1982\n1980\n1973\n\n\nWe can also recover the index with enumerate().\nWhen you use enumerate(), the function gives you back two loop variables:\nThe count of the current iteration The value of the item at the current iteration\n\nsquares = [\"red\", \"yellow\", \"green\"]\n\nfor index,value in enumerate(squares):\n    value\n    index\n\nWe can also print this in a nicer looking table:\n\nsquares = [\"red\", \"yellow\", \"green\"]\n\nfor index,value in enumerate(squares):\n    print(index, value)\n\n0 red\n1 yellow\n2 green\n\n\n\n\n4.4.3 While loops\nWhile loops are similar to for loops but instead of executing a statement a set number of times, a while loop only runs if a condition is met.\nFor example: We have a list of colors and want to copy these into a new list until we encounter a non-orange value.\n\nsquares = [\"orange\", \"orange\", \"purple\", \"orange\"]\n\n#create an empty list in which we want to store our new list\nNewsquares=[]\n\n#start the index at 0\ni=0\n\n#execute the statement until the condition is false\nwhile(squares[i]==\"orange\"):\n    #append the value of the i-th element of the list squares to the new list\n    Newsquares.append(squares[i])\n    #increase the index value by one to be able to access the 2nd element in the next round\n    i=i+1\n\nNewsquares\n\n['orange', 'orange']\n\n\nAlternatively, we could do:\n\nsquares = [\"orange\", \"red\", \"purple\", \"green\"]\n\n#create an empty list in which we want to store our new list\nNewsquares=[]\n\n#start the index at 0\ni=0\n\nwhile(squares[i]!=\"purple\"):\n    Newsquares.append(squares[i])\n    i=i+1\n\nNewsquares\n\n['orange', 'red']\n\n\nLet’s say we would like to iterate through list dates and stop at the year 1973, then print out the number of iterations. This can be done with the following block of code:\n\ndates = [1982 ,1980, 1973, 2000]\n\n#set counter and empty list\ni=0\nyear=dates[0]\n\nwhile(year!=1973):\n    print(year)\n    i = i+1\n    year=dates[i]\n\nprint(\"It took \", i, \"repetitions to get out of the loop\")\n\n1982\n1980\nIt took  2 repetitions to get out of the loop\n\n\n\n\n4.4.4 Exercises Loops\nWrite a for loop the prints out all the element between -5 and 5 using the range function.\n\nfor i in range(-4,5):\n    print(i)\n\n-4\n-3\n-2\n-1\n0\n1\n2\n3\n4\n\n\nPrint the elements of the following list: Genres=[ ‘rock’, ‘R&B’, ‘Soundtrack’, ‘R&B’, ‘soul’, ‘pop’] Make sure you follow Python conventions.\n\nGenres=[ 'rock', 'R&B', 'Soundtrack', 'R&B', 'soul', 'pop']\n\nfor i in Genres:\n    print(i)\n\nrock\nR&B\nSoundtrack\nR&B\nsoul\npop\n\n\nWrite a while loop to display the values of the Rating of an album playlist stored in the list PlayListRatings. If the score is less than 6, exit the loop. The list PlayListRatings is given by: PlayListRatings = [10, 9.5, 10, 8, 7.5, 5, 10, 10]\n\nPlayListRatings = [10, 9.5, 10, 8, 7.5, 5, 10, 10]\n\ni=0\nRating=PlayListRatings[0]\n\nwhile(Rating>6):\n    print(Rating)\n    i=i+1\n    Rating=PlayListRatings[i]\n    #i=i+1 #Try uncommenting the line and comment the previous i = i + 1, and see the difference, 10 value will get printed twice because when the loop starts it will print Rating and then with PlayListRatings[0], it will again assign the value 10 to Ratings.\n\n10\n9.5\n10\n8\n7.5"
  },
  {
    "objectID": "code/Week3_Conditions_a_branching.html#functions",
    "href": "code/Week3_Conditions_a_branching.html#functions",
    "title": "4  Conditions and branching",
    "section": "4.5 Functions",
    "text": "4.5 Functions\n\nFunctions take some input then produce some output or change. You can use your own functions or use pythons build in functions.\nFunctions are used to make reusable modules and make the code we run shorter.\n\n\n4.5.1 sum()\nI.e. the function sum() takes a tuple or list as input and returns the sum of the values\n\nratings = [10,8,5]\nS = sum(ratings)\nS\n\n23\n\n\n\n\n4.5.2 sort()\nSort() is a list method. Methods are similar to functions.Generally functions take an input, i.e. a list, they produce a new output and the original input stays unchanged. If we use the method sort, our list will change and no new list will be created.\n\nratings = [10,8,5]\n\n#apply the function sorted\nsorted_ratings = sorted(ratings)\nsorted_ratings\nratings\n\n#apply the sort method\nratings.sort()\nratings\n\n[5, 8, 10]\n\n\n\n\n4.5.3 building functions\n\nto build a function we start with the key word: def\nFollow this by the name of the function, i.e. add1\nin brackets we add the functions formal parameters, i.e. the input to our function\nAfter the colon comes the code block with an indent\nA variable that is declared inside a function is called a local variable. The parameter only exists within the function (i.e. the point where the function starts and stops).\nwe then return, our output, something\n\n\n#define a function\ndef add1(a):\n    b=a+1\n    return b\n\n#call a function\nadd1(2)\n\n3\n\n\nLets now document the function better.\n\n#define a function with a documenting string\ndef add1(a):\n    \"\"\"\n    add 1 to a\n    \"\"\"\n    b=a+1\n    return b\n\n#display the documentation\nhelp(add1)\n\nHelp on function add1 in module __main__:\n\nadd1(a)\n    add 1 to a\n\n\n\nA function can have multiple parameters.\n\n#define the mult function, which multiplies two integers\ndef mult(a,b):\n    c=a*b\n    return c\n\nmult(3,3)\nmult(2,\"hello\")\n\n'hellohello'\n\n\nFunctions don’t need a return statement. Practically speaking, if your function has no return statement, you can treat it as if the function returns nothing at all. The function word_return simply prints the name ‘hello’.\n\ndef word_return():\n    print(\"hello\")\n\nword_return()\n\nhello\n\n\nWe can define an empty function like this. pass is simply used to have a empty code block.\n\ndef NoWork():\n    pass\n\nprint(NoWork())\n\nNone\n\n\nFunctions can perform more than one task. I.e. the function below prints a statement then returns a value.\n\ndef add1(a):\n    b = a+1\n    print(a, \"plus 1 equals= \", b)\n    return b\n\nadd1(2)\n\n2 plus 1 equals=  3\n\n\n3\n\n\nWe can also use loops in functions. I.e. lets define a function that prints out the values and indexes of a list or tuple.\n\ndef printStuff(stuff):\n    for i,s in enumerate(stuff):\n        print(\"Album\", i, \"rating is \", s)\n        \nalbum_ratings = [10,8,7]\nprintStuff(album_ratings)\n\nAlbum 0 rating is  10\nAlbum 1 rating is  8\nAlbum 2 rating is  7\n\n\nWe can also loop through elements in a list.\n\ndef Print(A):\n    for a in A:\n        print(a+'1')\n        \nPrint(['a','b','c'])\n\na1\nb1\nc1\n\n\nVariadic parameters allow us to input a variable number of elements. Consider the following function; the function has an asterisk on the parameter names. When we call the function, three parameters are packed into the tuple names.\n\ndef ArtistNames(*names):\n    for i in names:\n        print(i)\n        \nArtists = [\"MJ\", \"AC/DC\"]\nArtistNames(\"MJ\", \"AC/DC\")\n\nMJ\nAC/DC\n\n\nSimilarly, The arguments can also be packed into a dictionary as shown:\n\ndef printDictionary(**args):\n    for key in args:\n        print(key + \" : \" + args[key])\n\nprintDictionary(Country='Canada',Province='Ontario',City='Toronto')\n\nCountry : Canada\nProvince : Ontario\nCity : Toronto\n\n\nThe scope of a variable is the part of the program where that variable is accessible. Variables that are defined outside of any function are said to be within the global scope, meaning they can be accessed anywhere after they are defined. Local variables only exist within the scope of a function. Variables inside the global scope can have the same name as variables in the local scope with no conflict.\nI.e. in the following we can not access the variable internal_var1 outside of the function\n\n# Example of global variable\nartist = \"Michael Jackson\"\n\ndef printer1(artist):\n    internal_var1 = artist\n    print(artist, \"is an artist\")\n    \nprinter1(artist)\n\nMichael Jackson is an artist\n\n\nBut we can if we set a variable in a function to a global variable:\n\nartist = \"Michael Jackson\"\n\ndef printer(artist):\n    global internal_var \n    internal_var= \"Whitney Houston\"\n    print(artist,\"is an artist\")\n\nprinter(artist) \nprinter(internal_var)\n\nMichael Jackson is an artist\nWhitney Houston is an artist\n\n\nThe return() function is particularly useful if you have any IF statements in the function, when you want your output to be dependent on some condition:\n\n# Function example\ndef type_of_album(artist, album, year_released):\n    #print(artist, album, year_released)\n    if year_released > 1980:\n        return \"Modern\"\n    else:\n        return \"Oldie\"\n    \nx = type_of_album(\"Michael Jackson\", \"Thriller\", 1980)\nprint(x)\n\nOldie\n\n\nYou can set a default value for arguments in your function. For example, in the isGoodRating() function, what if we wanted to create a threshold for what we consider to be a good rating? Perhaps by default, we should have a default rating of 4:\n\n# Example for setting param with default value\ndef isGoodRating(rating=4): \n    if(rating < 7):\n        print(\"this album sucks it's rating is\",rating)      \n    else:\n        print(\"this album is good its rating is\",rating)\n\nisGoodRating()\n\nthis album sucks it's rating is 4\n\n\n\n\n4.5.4 Exercises functions\n\ndef Equation(a,b):\n    c = a + b + 2 * a * b - 1\n    if(c < 0):\n        c = 0 \n    else:\n        c = 5\n    return(c) \n\nEquation(0,0)\n\n0\n\n\n\nL=[1,3,2]\nsorted(L)\nL\n\n[1, 3, 2]"
  },
  {
    "objectID": "code/Week3_Conditions_a_branching.html#exception-handling",
    "href": "code/Week3_Conditions_a_branching.html#exception-handling",
    "title": "4  Conditions and branching",
    "section": "4.6 Exception handling",
    "text": "4.6 Exception handling\n\nMake error messages appear when performing “wrong” operations. I.e. if you only can input letters, not numbers.\n\n\n4.6.1 The try…except statement\nThis statement will first attempt to excecute the statement in a try code block but if an error occurs it will kick out and start searching for the except statement that matches the error. Once it finds the correct except statement to handle the error it will execute that line of code.\nLet’s try to write an example of code to open a file, however, if the file can not be opened, give an error.\nIOError = an error related to a file\n\ntry:\n    getfile=open(\"myfile\", \"r\")\n    getfile.write(\"File for exception handling\")\n    except IOError:\n        print(\"Unable to open or read the data in the file\")\n\nNow, what to do when we encounter another error? In the example below we catch an error but the type is not specified. While this may seem a logical step so the program will catch all errors and not terminate this is not a best practice. Because this error had no details you might end up spending hours trying to pinpoint and fix the error.\n\ntry:\n    getfile=open(\"myfile\", \"r\")\n    getfile.write(\"File for exception handling\")\n    except IOError:\n        print(\"Unable to open or read the data in the file\")\n    except:\n        print(\"Some other error occurred\")\n\nWe can also add an else statement to show that our prgram run successfully.\n\ntry:\n    getfile=open(\"myfile\", \"r\")\n    getfile.write(\"File for exception handling\")\n    except IOError:\n        print(\"Unable to open or read the data in the file\")\n    except:\n        print(\"Some other error occurred\")\n    else:\n        print(\"The file was written successfully\")\n\nThe last thing to do is close the file by adding the finally statement.\n\ntry:\n    getfile=open(\"myfile\", \"r\")\n    getfile.write(\"File for exception handling\")\n    except IOError:\n        print(\"Unable to open or read the data in the file\")\n    except:\n        print(\"Some other error occurred\")\n    else:\n        print(\"The file was written successfully\")\n    finally:\n        getfile.close()\n        print(\"File is now closed\")\n\n\n\n4.6.2 Exercise exceptions\nIn this example we are trying to divide a number given by the user, save the outcome in the variable a, and then we would like to print the result of the operation. When taking user input and dividing a number by it there are a couple of exceptions that can be raised. For example if we divide by zero. Try running the following block of code with b as a number. An exception will only be raised if b is zero.\n\na = 1\n\ntry:\n    b = int(input(\"Please enter a number to divide a\"))\n    a=a/b\n    print(\"Success a=\", a)\nexcept:\n    print(\"There was an error\")\n\nNow, lets add a more specific error message:\n\na = 1\n\ntry:\n    b = int(input(\"Please enter a number to divide a\"))\n    a = a/b\n    print(\"Success a=\",a)\nexcept ZeroDivisionError:\n    print(\"The number you provided cant divide 1 because it is 0\")\nexcept ValueError:\n    print(\"You did not provide a number\")\nexcept:\n    print(\"Something went wrong\")"
  },
  {
    "objectID": "code/Week3_Conditions_a_branching.html#objects-and-classes",
    "href": "code/Week3_Conditions_a_branching.html#objects-and-classes",
    "title": "4  Conditions and branching",
    "section": "4.7 Objects and classes",
    "text": "4.7 Objects and classes\nPython has many different data types, such as integers, floats, strings, lists, dictionaries, booleanes. In python , each of these is an object. An object consists of the following:\n\na type\nan internal data representation (a blueprint)\na set of procedures for interacting with an object (methods)\n\nAn Object is an instance of a particular type. I.e. every time we create an integer, we are creating an instance of type integer, or we are creating an integer object.\nWe can find out the type of an object by using the type() command.\n\ntype([\"a\"])\n\nlist\n\n\n\n4.7.1 Types methods\nTypes methods are functions that every instance of a class or type provides. Its how we interact with an object. For example sorting is a method that interacts with the data of an object.\nI.e. Consider the list ratings, the data is a series of numbers contained within the list. The method sort will change the data within the object. We call the method by adding a period at the end of an object followed by the methods name\n\nRatings = [10,9,6,4,5,8]\nRatings.sort()\nRatings\n\n[4, 5, 6, 8, 9, 10]\n\n\nLet’s also import a library to plot data:\n\n# Import the library\nimport matplotlib.pyplot as plt\n%matplotlib inline  \n\n#code below doesn’t work in r bc specific language #%matplotlib inline\n\n\n4.7.2 Creating your own types\nFor example, lets create a class type, which has data attributes and methods. I.e. the *class circle** contains the data attributed radius and color while the class rectangle contains the attributed width, height and color.\nLet’s create the class Circle by using the class definition, followed by the name of the class (here: circle) and the class parent. Next, we initialize each instance of the class with data attributes.\nThe function init is a constructor used to initialize data attributes, its a special function that tells python that we are making a new class. The radius and color parameters are used to initialize the radius and color data attributes of the class instance. The self parameter refers to the newly created instance of the class. The parameters, radius, and color can be used in the constructors body to access the values passed to the class constructor when the class is constructed.\n\n#define the class Circle\nclass Circle(object):\n    #initialize each class with data attributes\n    def __init__(self, radius, color):\n        self.radius=radius;\n        self.color=color;\n\nAfter we have created the class, we can create an object of the class circle:\n\n#create a circle object\nRedCircle = Circle(10,\"red\")\n\n#we can check the color attribute with\nRedCircle.color\n\n#change the color attribute\nRedCircle.color=\"blue\"\nRedCircle.color\n\n#return a dict of the attributes in an object\nRedCircle.__dict__\n\n{'radius': 10, 'color': 'blue'}\n\n\n\n\n4.7.3 Create Methods for our own functions\nMethods give you a way to change or interact with the object; they are functions that interact with objects. For example, let’s say we would like to increase the radius of a circle by a specified amount. For this, we add a method, add_radius, to our class.\n\n#define the class\nclass Circle(object):\n    #initialize each class with data attributes\n    def __init__(self, radius, color):\n        self.radius=radius;\n        self.color=color;\n    def add_radius(self,r):\n        self.radius=self.radius + r\n\n\n#create a new object\nC1 = Circle(2,\"red\")\n\n#check the radius\nC1.radius\n\n#change the radius\nC1.add_radius(8)\nC1.radius\n\n10\n\n\n\n\n4.7.4 The dir function\nThe dir function is useful for obtaining the list of data attributes and methods associated with a class. The object you’re interested in is passed as an argument. The return value is a list of the objects data attributes. The attribute surrounded by underscores are for internal use, and you shouldn’t have to worry about them.\n\ndir(Circle)\n\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n 'add_radius']\n\n\n\n\n4.7.5 Exercises objects and classes\n\n\n4.7.6 Create a class circle with a method to draw the circle\n\nclass Circle(object):\n    #Instructor, including defaults\n    def __init__(self, radius=3, color=\"blue\"):\n        self.radius=radius\n        self.color=color\n    #add method1\n    def add_radius(self,r):\n        self.radius=self.radius+r\n        return(self.radius)\n    #add method2\n    def drawCircle(self):\n        plt.gca().add_patch(plt.Circle((0, 0), radius=self.radius, fc=self.color))\n        plt.axis('scaled')\n        plt.show()  \n\n\n#create an object of the class circle\nRedCircle = Circle(10, \"red\")\n\n#find out the methods we can use with the object redcircle\ndir(RedCircle)\n\n# Print the object attribute radius\nRedCircle.radius\n\n# Set the object attribute radius\nRedCircle.radius = 1\nRedCircle.radius\n\n# Call the method drawCircle\nRedCircle.drawCircle()\n\n\n\n\n\n\n4.7.7 Text analysis\nYou have been recruited by your friend, a linguistics enthusiast, to create a utility tool that can perform analysis on a given piece of text. Complete the class ‘analysedText’ with the following methods -\n\nConstructor (init) - This method should take the argument text, make it lower case, and remove all punctuation. Assume only the following punctuation is used: period (.), exclamation mark (!), comma (,) and question mark (?). Assign this newly formatted text to a new attribute called fmtText.\nfreqAll - This method should create and return dictionary of all unique words in the text, along with the number of times they occur in the text. Each key in the dictionary should be the unique word appearing in the text and the associated value should be the number of times it occurs in the text. Create this dictionary from the fmtText attribute.\nfreqOf - This method should take a word as an argument and return the number of occurrences of that word in fmtText.\n\n\nclass analysedText(object):\n    \n    def __init__ (self, text):\n        # remove punctuation and make lower case\n        self.fmtText = text.replace('.','').replace('!','').replace('?','').replace(',','').lower()\n    def freqAll(self):        \n        # split text into words\n        wordList = self.fmtText.split(' ')\n        # Create dictionary\n        freqMap = {}\n        for word in set(wordList): # use set to remove duplicates in list\n            freqMap[word] = wordList.count(word)\n        return freqMap\n    \n    def freqOf(self,word):\n        # get frequency map\n        freqDict = self.freqAll()\n        if word in freqDict:\n            return freqDict[word]\n        else:\n            return 0\n\nTest function individually:\n\nsamplePassage = analysedText(\"Lorem ipsum dolor! diam amet, consetetur Lorem magna. sed diam nonumy eirmod tempor. diam et labore? et diam magna. et diam amet.\")\n\n#edit text\nsamplePassage.fmtText\n\n'lorem ipsum dolor diam amet consetetur lorem magna sed diam nonumy eirmod tempor diam et labore et diam magna et diam amet'\n\n\n\n#count occurrence of words\nwordMap = samplePassage.freqAll()\nwordMap\n\n{'consetetur': 1,\n 'eirmod': 1,\n 'sed': 1,\n 'amet': 2,\n 'nonumy': 1,\n 'tempor': 1,\n 'labore': 1,\n 'et': 3,\n 'ipsum': 1,\n 'dolor': 1,\n 'magna': 2,\n 'lorem': 2,\n 'diam': 5}\n\n\n\n#count frequency of individual word\nsamplePassage.freqOf(\"dolor\")\n\n1\n\n\ntest run:\n\nimport sys\n\nsampleMap = {'eirmod': 1,'sed': 1, 'amet': 2, 'diam': 5, 'consetetur': 1, 'labore': 1, 'tempor': 1, 'dolor': 1, 'magna': 2, 'et': 3, 'nonumy': 1, 'ipsum': 1, 'lorem': 2}\n\ndef testMsg(passed):\n    if passed:\n       return 'Test Passed'\n    else :\n       return 'Test Failed'\n\nprint(\"Constructor: \")\ntry:\n    samplePassage = analysedText(\"Lorem ipsum dolor! diam amet, consetetur Lorem magna. sed diam nonumy eirmod tempor. diam et labore? et diam magna. et diam amet.\")\n    print(testMsg(samplePassage.fmtText == \"lorem ipsum dolor diam amet consetetur lorem magna sed diam nonumy eirmod tempor diam et labore et diam magna et diam amet\"))\nexcept:\n    print(\"Error detected. Recheck your function \" )\nprint(\"freqAll: \")\ntry:\n    wordMap = samplePassage.freqAll()\n    print(testMsg(wordMap==sampleMap))\nexcept:\n    print(\"Error detected. Recheck your function \" )\nprint(\"freqOf: \")\ntry:\n    passed = True\n    for word in sampleMap:\n        if samplePassage.freqOf(word) != sampleMap[word]:\n            passed = False\n            break\n    print(testMsg(passed))\n    \nexcept:\n    print(\"Error detected. Recheck your function  \" )\n\nConstructor: \nTest Passed\nfreqAll: \nTest Passed\nfreqOf: \nTest Passed"
  },
  {
    "objectID": "code/Week4_Files_Pandas_Numpy.html",
    "href": "code/Week4_Files_Pandas_Numpy.html",
    "title": "5  Working with data in python",
    "section": "",
    "text": "One way to read or write a file in Python is to use the built-in open function. The open function provides a File object that contains the methods and attributes you need in order to read, save, and manipulate the file. In this notebook, we will only cover .txt files.\n\nThe first argument is the filepath and the filename we want to open\nThe second parameter is the mode:\n\nr: open a file for reading\nw: open a file for writing\na: open a file for appending\nr+ : Reading and writing. Cannot truncate the file.\nw+ : Writing and reading. Truncates the file.\na+ : Appending and Reading. Creates a new file, if none exists.\n\nWe store this in a file object, i.e. File1 and we can use the file object to obtain information about the file\nYou should always close the file object using the method close.\n\nPython file method close() closes the opened file. A closed file cannot be read or written any more. Any operation, which requires that the file be opened will raise a ValueError after the file has been closed. Calling close() more than once is allowed.\n\n#open a file\nFile1 = open(\"../data/Example1.txt\", \"r\")\n\n#get the name of the file\nprint(File1.name)\n\n#see what mode the object is in\nprint(File1.mode)\n\n#get the file contents\nprint(File1.read())\n\n#get they type of the file\ntype(File1.read())\n\n#close the file\nFile1.close()\n\nSince using .close() can be tedious, we can use an alternative, the with statement. This is a better alternative, since the with statement will automatically close the file.\n\nwith open(\"../data/Example1.txt\", \"r\") as File1:\n    #code will be performed in the indented code block\n    #The method \"read\" stores the values of the file in the variable \"file_stuff\" as a string\n    file_stuff = File1.read()\n    print(file_stuff)\n    print(File1.mode)\n\nNotice, that we didn’t have to write “file.close()”. That will automatically be called.\nWe can output every line as an element in a list using the method “readlines.”\n\nwith open(\"../data/Example1.txt\", \"r\") as File1:\n    file_stuff = File1.readlines()\n    print(file_stuff)\n\nWe don’t have to read the entire file, for example, we can read the first 4 characters by entering three as a parameter to the method .read():\n\n# Read first four characters\nwith open(\"../data/Example1.txt\", \"r\") as file1:\n    print(file1.read(4))\n\nUse a loop to print out each line individually\n\nwith open(\"../data/Example1.txt\", \"r\") as File1:\n    for i in File1:\n        print(i)\n\nWe can also read all lines and save them as a list\n\n# Read all lines and save as a list\nwith open(\"../data/Example1.txt\", \"r\") as file1:\n    FileasList = file1.readlines()\n    \n#print the first line    \nFileasList[0]\n\n\n\n\nCreate a new, empty example as follows:\nBeware: If we have a file with that filename in our directory, it will be overwritten!\n\n#create example.txt in the specified dir\nwith open(\"../data/Example2.txt\", \"w\") as File1:\n    #add something into our file\n    File1.write(\"This is line A\\n\")\n    File1.write(\"This is line B\\n\")\n\nWe can also have a list and write this to a file\n\nLines = [\"This is line A\\n\", \"This is line B\\n\", \"This is line C\\n\"]\n\nwith open(\"../data/Example2.txt\", \"w\") as File1:\n    for i in Lines:\n        File1.write(i)\n\n\n\n\nAppend will not create a new file but append lines to an existing file.\n\nwith open(\"../data/Example2.txt\", \"a\") as File1:\n    File1.write(\"This is line D\\n\")\n\n\n\n\n\nwith open(\"../data/Example1.txt\", \"r\") as readfile:\n    with open(\"../data/Example3.txt\", \"w\") as writefile:\n        for line in readfile:\n            writefile.write(line)\n\n\n\n\n\nwith open('../data/Example2.txt', 'a+') as testwritefile:\n    testwritefile.write(\"This is line E\\n\")\n    print(testwritefile.read())\n\nOpening the file in w is akin to opening the .txt file, moving your cursor to the beginning of the text file, writing new text and deleting everything that follows. Whereas opening the file in a is similiar to opening the .txt file, moving your cursor to the very end and then adding the new pieces of text. It is often very useful to know where the ‘cursor’ is in a file and be able to control it. The following methods allow us to do precisely this -\n\n.tell() - returns the current position in bytes\n.seek(offset,from) - changes the position by ‘offset’ bytes with respect to ‘from’. From can take the value of 0,1,2 corresponding to beginning, relative to current position and end\n\n\nwith open('../data/Example2.txt', 'a+') as testwritefile:\n    print(\"Initial Location: {}\".format(testwritefile.tell()))\n    data = testwritefile.read()\n    if (not data):  #empty strings return false in python\n            print('Read nothing') \n    else: \n            print(testwritefile.read())\n    \n    testwritefile.seek(0,0) # move 0 bytes from beginning.\n    \n    print(\"\\nNew Location : {}\".format(testwritefile.tell()))\n    data = testwritefile.read()\n    if (not data): \n            print('Read nothing') \n    else: \n            print(data)\n    \n    print(\"Location after read: {}\".format(testwritefile.tell()) )\n\nFinally, a note on the difference between w+ and r+. Both of these modes allow access to read and write methods, however, opening a file in w+ overwrites it and deletes all pre-existing data. To work with a file on existing data, use r+ and a+. While using r+, it can be useful to add a .truncate() method at the end of your data. This will reduce the file to your data and delete everything that follows.\n\nwith open('../data/Example2.txt', 'r+') as testwritefile:\n    data = testwritefile.readlines()\n    testwritefile.seek(0,0) #write at beginning of file\n   \n    testwritefile.write(\"Line 1\" + \"\\n\")\n    testwritefile.write(\"Line 2\" + \"\\n\")\n    testwritefile.write(\"Line 3\" + \"\\n\")\n    testwritefile.write(\"finished\\n\")\n    #Uncomment the line below\n    testwritefile.truncate()\n    testwritefile.seek(0,0)\n    print(testwritefile.read())\n\nAfter reading files, we can also write data into files and save them in different file formats like .txt, .csv, .xls (for excel files) etc. You will come across these in further examples\n\n\nYour local university’s Raptors fan club maintains a register of its active members on a .txt document. Every month they update the file by removing the members who are not active. You have been tasked with automating this with your Python skills.\nGiven the file currentMem, Remove each member with a ‘no’ in their Active column. Keep track of each of the removed members and append them to the exMem file. Make sure that the format of the original files in preserved. (Hint: Do this by reading/writing whole lines and ensuring the header remains )\nRun the code block below prior to starting the exercise. The skeleton code has been provided for you. Edit only the cleanFiles function.\n\n#Run this prior to starting the exercise\nfrom random import randint as rnd\n\nmemReg = '../data/members.txt'\nexReg = '../data/inactive.txt'\nfee =('yes','no')\n\ndef genFiles(current,old):\n    with open(current,'w+') as writefile: \n        writefile.write('Membership No  Date Joined  Active  \\n')\n        data = \"{:^13}  {:<11}  {:<6}\\n\"\n\n        for rowno in range(20):\n            date = str(rnd(2015,2020))+ '-' + str(rnd(1,12))+'-'+str(rnd(1,25))\n            writefile.write(data.format(rnd(10000,99999),date,fee[rnd(0,1)]))\n\n\n    with open(old,'w+') as writefile: \n        writefile.write('Membership No  Date Joined  Active  \\n')\n        data = \"{:^13}  {:<11}  {:<6}\\n\"\n        for rowno in range(3):\n            date = str(rnd(2015,2020))+ '-' + str(rnd(1,12))+'-'+str(rnd(1,25))\n            writefile.write(data.format(rnd(10000,99999),date,fee[1]))\n\n\ngenFiles(memReg,exReg)\n\n\ndef cleanFiles(currentMem, exMem):\n    with open(currentMem, \"r+\") as writeFile:\n        with open(exMem, \"a+\") as appendFile:\n            #get the data\n            writeFile.seek(0)\n            members = writeFile.readlines()\n            #remove header\n            header = members[0]\n            members.pop(0)\n            inactive=[]\n            for member in members:\n                if 'no' in member:\n                    inactive.append(member)\n            '''\n            inactive = [member for member in members if ('no' in member)]\n            The above is the same as \n            \n            for member in members:\n            if 'no' in member:\n                inactive.append(member)\n            '''\n            #go to the beginning of the write file\n            writeFile.seek(0)\n            writeFile.write(header)\n            for member in members:\n                if (member in inactive):\n                    appendFile.write(member)\n                else:\n                    writeFile.write(member)\n            writeFile.truncate()\n\nTest code:\n\nmemReg = '../data/members.txt'\nexReg = '../data/inactive.txt'\ncleanFiles(memReg,exReg)\n\n# code to help you see the files\nheaders = \"Membership No  Date Joined  Active  \\n\"\n\nwith open(memReg,'r') as readFile:\n    print(\"Active Members: \\n\\n\")\n    print(readFile.read())\n    \nwith open(exReg,'r') as readFile:\n    print(\"Inactive Members: \\n\\n\")\n    print(readFile.read())\n\nAutomated test code:\n\ndef testMsg(passed):\n    if passed:\n       return 'Test Passed'\n    else :\n       return 'Test Failed'\n\ntestWrite = \"../data/testWrite.txt\"\ntestAppend = \"../data/testAppend.txt\" \npassed = True\n\ngenFiles(testWrite,testAppend)\n\nwith open(testWrite,'r') as file:\n    ogWrite = file.readlines()\n\nwith open(testAppend,'r') as file:\n    ogAppend = file.readlines()\n\ntry:\n    cleanFiles(testWrite,testAppend)\nexcept:\n    print('Error')\n\nwith open(testWrite,'r') as file:\n    clWrite = file.readlines()\n\nwith open(testAppend,'r') as file:\n    clAppend = file.readlines()\n        \n# checking if total no of rows is same, including headers\n\nif (len(ogWrite) + len(ogAppend) != len(clWrite) + len(clAppend)):\n    print(\"The number of rows do not add up. Make sure your final files have the same header and format.\")\n    passed = False\n    \nfor line in clWrite:\n    if  'no' in line:\n        passed = False\n        print(\"Inactive members in file\")\n        break\n    else:\n        if line not in ogWrite:\n            print(\"../data in file does not match original file\")\n            passed = False\nprint (\"{}\".format(testMsg(passed)))"
  },
  {
    "objectID": "code/Week4_Files_Pandas_Numpy.html#pandas",
    "href": "code/Week4_Files_Pandas_Numpy.html#pandas",
    "title": "5  Working with data in python",
    "section": "5.2 Pandas",
    "text": "5.2 Pandas\nPandas is a popular library for data analysis built on top of the Python programming language. Pandas generally provide two data structures for manipulating data, They are:\n\nDataFrame: a two-dimensional data structure, i.e., data is aligned in a tabular fashion in rows and columns.\nSeries: represents a one-dimensional array of indexed data. It has two main components :\n\nAn array of actual data.\nAn associated array of indexes or data labels.\n\n\nWe input a library, a set of pre-written functions with the import command followed by the name of the library. Since always writing the library name, we can shorten it with the as statement. Pd is the standard abbreviation often used for pandas.\n\nimport pandas as pd\n\nThis gives us access to a number of pre-build classes and functions.\n\n5.2.1 Loading data with pandas\nWe import a table with and store it in a dataframe. A dataframe is comprised of rows and columns.\n\n#read in a dataframe\ndf = pd.read_csv(\"../data/file1.csv\")\n\n#examine the first 5 rows of a dataframe\ndf.head()\n\nWe also can create a dataframe out of a dictionary. The keys correspond to the table headers, the values correspond to the rows.\n\n#Define a dictionary 'x'\nx = {'Name': ['Rose','John', 'Jane', 'Mary'], \n        'ID': [1, 2, 3, 4], \n        'Department': ['Architect Group', 'Software Group', 'Design Team', 'Infrastructure'], \n        'Salary':[100000, 80000, 50000, 60000]}\n\n#casting the dictionary to a DataFrame\ndf = pd.DataFrame(x)\n\n#display the result df\ndf\n\nWe can create a new df consisting of one column.\n\nx = df[[\"ID\"]]\nx\n\nLet’s use the type() function and check the type of the variable.\n\n#check the type of x\ntype(x)\n\nWe can also do this for multiple columns:\n\nz = df[['Department','Salary','ID']]\nz\n\nTo view the column as a series, we just use one bracket.\n\nx = df[\"Name\"]\nx\n\n\n#check the type of x\ntype(x)\n\n\n\n5.2.2 loc() and iloc() functions\nloc() is a label-based data selecting method which means that we have to pass the name of the row or column that we want to select. This method includes the last element of the range passed in it.\nSimple syntax for your understanding:\nloc[row_label, column_label]\niloc() is an indexed-based selecting method which means that we have to pass integer index in the method to select a specific row/column. This method does not include the last element of the range passed in it.\nSimple syntax for your understanding:\niloc[row_index, column_index]\n\n# Access the value on the first row and the first column\ndf.iloc[0, 0]\n\n\n# Access the value on the first row and the third column\ndf.iloc[0,2]\n\n\n# Access the column using the name\ndf.loc[0, 'Salary']\n\nLet us create a new dataframe called ‘df1’ and assign ‘df’ to it. Now, let us set the “Name” column as an index column using the method set_index().\n\ndf1=df\ndf1=df1.set_index(\"Name\")\n\n#To display the first 5 rows of new dataframe\ndf1.head()\n\n\n#Now, let us access the column using the name\ndf1.loc['Jane', 'Salary']\n\n\n\n5.2.3 Slicing\nSlicing uses the [] operator to select a set of rows and/or columns from a DataFrame.\nTo slice out a set of rows, you use this syntax: data[start:stop],\nhere the start represents the index from where to consider, and stop represents the index one step BEYOND the row you want to select. You can perform slicing using both the index and the name of the column.\nNOTE: When slicing in pandas, the start bound is included in the output.\nSo if you want to select rows 0, 1, and 2 your code would look like this: df.iloc[0:3].\nIt means you are telling Python to start at index 0 and select rows 0, 1, 2 up to but not including 3.\nNOTE: Labels must be found in the DataFrame or you will get a KeyError.\nIndexing by labels(i.e. using loc()) differs from indexing by integers (i.e. using iloc()). With loc(), both the start bound and the stop bound are inclusive. When using loc(), integers can be used, but the integers refer to the index label and not the position.\nFor example, using loc() and select 1:4 will get a different result than using iloc() to select rows 1:4.\n\n# let us do the slicing using old dataframe df\ndf.iloc[0:2, 0:3]\n\n\n#let us do the slicing using loc() function on old dataframe df where index column is having labels as 0,1,2\ndf.loc[0:2,'ID':'Department']\n\n\n\n5.2.4 Working with and Saving Data\n\n5.2.4.1 Make a list of unique elements\n\n# Read data from CSV file\ncsv_path = 'https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%204/data/TopSellingAlbums.csv'\ndf = pd.read_csv(csv_path)\ndf.head()\n\n\n# Access to the column Released\nx = df[['Released']]\nx\n\n\n#apply the unique method to remove duplicated years\ndf['Released'].unique()\n\n\n\n\n5.2.5 Selecting rows by conditions\nLets find all the albums released after 1980\n\n#find albums after 1980\n#the results is a list of boolean values\nprint(df[\"Released\"]>=1980)\n\n#select the specified columns from our dataframe\ndf1 = df[df[\"Released\"]>=1980]\ndf1.head()\n\n\n\n5.2.6 Save dataframes\n\n#save new df to csv\ndf.to_csv(\"../data/new_songs.csv\")"
  },
  {
    "objectID": "code/Week4_Files_Pandas_Numpy.html#numpy",
    "href": "code/Week4_Files_Pandas_Numpy.html#numpy",
    "title": "5  Working with data in python",
    "section": "5.3 Numpy",
    "text": "5.3 Numpy\nNumpy is a package for scientific computing and has many useful functions.\n\n5.3.1 Basics\nNumPy is a Python library used for working with arrays, linear algebra, fourier transform, and matrices.A numpy array is similar to a list. NumPy stands for Numerical Python and it is an open source project.The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy.\nArrays are very frequently used in data science, where speed and resources are very important.\nNumPy is usually imported under the np alias.\nIt’s usually fixed in size and each element is of the same type. We can cast a list to a numpy array by first importing numpy:\n\n#load numpy\nimport numpy as np\n\n#The version string is stored under version attribute.\nprint(np.__version__)\n\n\n#create an array\na = np.array([0,1,2,3,4])\nprint(a)\n\n#access individual elements\nprint(a[2])\n\n#check the type\nprint(type(a))\n\n#obtain the data type of the array element\nprint(a.dtype)\n\n#check the attribute size, the number of elements in the array\nprint(a.size)\n\n#show the array dimensions\nprint(a.ndim)\n\n#show the size of the array in each dimension\nprint(a.shape)\n\n\n\n5.3.2 Indexing and slicing\nChange elements of an array:\n\n#define an array\nc = np.array([20,1,2,3,4])\nprint(c)\n\n#change the first element to 100\nc[0]=100\nprint(c)\n\n#change the 5th element\nc[4]=5\nprint(c)\n\nLike lists, we can slice the numpy array. Slicing in python means taking the elements from the given index to another given index.\nWe pass slice like this: [start:end].\nWe can select the elements from 1 to 3 and assign it to a new numpy array as follows:\n\n#select the elements from 1 to 3\nprint(c[1:4])\n\n## Set the fourth element and fifth element to 300 and 400\nc[3:5] = 300, 400\nprint(c)\n\nWe can also define the steps in slicing, like this: [start:end:step].\n\narr = np.array([1, 2, 3, 4, 5, 6, 7])\nprint(arr[1:5:2])\n\nIf we don’t pass start its considered 0\n\nprint(arr[1:5])\n\nIf we don’t pass end it considers till the length of array.\n\nprint(arr[3:])\n\nIf we don’t pass step its considered 1\n\nprint(arr[1:5:])\n\n\n\n5.3.3 Basic operations\n\n5.3.3.1 Vector addition and subtraction\n\n#define some vectors\nu = np.array([1,0])\nv = np.array([0,1])\n\n#add vectors\nz = u+v\nprint(z)\n\n#subtract vectors\nz = u-v\nprint(z)\n\n\n\n5.3.3.2 Array multiplication with a scalar\n\ny = np.array([1,2])\n\n#multiply vector\nz= 2*y\nprint(z)\n\n\n\n5.3.3.3 Product of two numpy arrays\n\nu = np.array([1,2])\nv = np.array([3,2])\n\n#multiply two vectors\nz = u*v\nprint(z)\n\n\n\n5.3.3.4 Dot products\nThe dot product is a single number given by the following term and represents how similar two vectors are.\n\nu = np.array([1,2])\nv = np.array([3,1])\n\n#dot product\n#1*3 + 2*5\nresult = np.dot(u,v)\nprint(result)\n\n\n\n5.3.3.5 Adding constant to a numpy array\n\nu = np.array([1,2,3,-1])\n\n#add a scalar to each element of an array, i.e. broadcasting\nz = u + 1\nprint(z)\n\n\n\n\n5.3.4 Universal functions\nA universal function is a function that operates on ND arrays. We can apply a universal function to a numpy array.\n\n5.3.4.1 Calculating the mean of an array\n\na = np.array([1,-1,1,-1])\n\n#calculate the mean\nmean_a = a.mean()\nprint(mean_a)\n\n\n\n5.3.4.2 Standard deviation\n\na = np.array([1,-1,1,-1])\n\nsdev = a.std()\nprint(sdev)\n\n\n\n5.3.4.3 Find the max and min\n\nb = np.array([1,-2,3,4,5])\n\n#calculate the mean\nmax_b = b.max()\nprint(max_b)\n\nWe can use numpy to create functions that map numpy arrays to new numpy arrays.\n\n#access pi with\nprint(np.pi)\n\n# We can create the following numpy array in radians\nx = np.array([0,np.pi/2,np.pi])\n\n#apply the function sin to our array x\n#this way we apply the sin function to each element in the array\ny = np.sin(x)\n\n#the result is a new array, y\nprint(y)\n\n\n\n5.3.4.4 Using Linspace\nA useful function for plotting mathematical functions is line space. Line space returns evenly spaced numbers over specified interval. We specify the starting point of the sequence, the ending point of the sequence. The parameter num indicates the number of samples to generate, in this case five.\n\nprint(np.linspace(-2,2,num=5))\nprint(np.linspace(-2,2,num=9))\n\nPlotting mathematics functions: We can use the function line space to generate 100 evenly spaced samples from the interval zero to two pie. We can use the numpy function sin to map the array x to a new array y. We can import the library pyplot as plt to help us plot the function.\n\n#generate 100 evenly spaced samples from the interval zero to two pie\nx = np.linspace(0,2*np.pi,100)\n\n#use sin to map the array x to a new array y\ny = np.sin(x)\n\n#import the matplot lib to help us plot the function\nimport matplotlib.pyplot as plt\n\n#plot the graph\n#first value = values plotted on x-axis, second input = values plotted on x-axis\nplt.plot(x,y)\nplt.show()\n\n\n\n5.3.4.5 Iterating 1-D Arrays\nterating means going through elements one by one.\nIf we iterate on a 1-D array it will go through each element one by one.\n\narr1 = np.array([1, 2, 3])\n\nfor x in arr1:\n    print(x)\n\n\n\n5.3.4.6 Plot arrays\nGenerate a function for plotting\n\n# Import the libraries\nimport time \nimport sys\nimport numpy as np \n\nimport matplotlib.pyplot as plt\n\ndef Plotvec2(a,b):\n    ax = plt.axes()# to generate the full window axes\n    ax.arrow(0, 0, *a, head_width=0.05, color ='r', head_length=0.1)#Add an arrow to the  a Axes with arrow head width 0.05, color red and arrow head length 0.1\n    plt.text(*(a + 0.1), 'a')\n    ax.arrow(0, 0, *b, head_width=0.05, color ='b', head_length=0.1)#Add an arrow to the  b Axes with arrow head width 0.05, color blue and arrow head length 0.1\n    plt.text(*(b + 0.1), 'b')\n    plt.ylim(-2, 2)#set the ylim to bottom(-2), top(2)\n    plt.xlim(-2, 2)#set the xlim to left(-2), right(2)\n\nPlot:\n\narr1 = np.array([-1,1])\narr2 = np.array([1,1])\n\nPlotvec2(arr1,arr2)\nplt.show()\n\n\n\n\n5.3.5 2D numpy arrays\nLet’s first create a nested list with 3 lists, each of equal size.\n\na = np.array([[1,3,4],[10,11,12]])\nprint(a)\n\n#cast the list to a numpy array\n# each separate list = 1 row in the matrix\nA = np.array(a)\nprint(A)\n\n#We can use the attribute ndim to obtain the number of axes or dimensions\n#referred to as the rank \nprint(A.ndim)\n\nIt’s useful to think of ndim as the number of nested lists. The first list represents the first dimension. This list contains another set of lists. This represents the second dimension or axis. The number of lists the list contains does not have to do with the dimension but the shape of the list.\n\n#Attribute shape returns a tuple corresponding to the size or number of each dimension.\nprint(A.shape)\n\nThe first element in the tuple corresponds to the number of nested lists contained in the original list or the number of rows in the rectangular representation, in this case three. The second element corresponds to the size of each of the nested list or the number of columns in the rectangular array zero.\n\n#The total number of elements in the array is given by the attribute size.\nprint(A.size)\n\nWe see there are three rows and three columns. Multiplying the number of columns and rows together, we get the total number of elements, in this case nine.\nWe can use rectangular brackets to access the different elements of the array. The index in the first bracket corresponds to the different nested lists each a different color. The second bracket corresponds to the index of a particular element within the nested list. Using the rectangular representation, the first index corresponds to the row index. The second index corresponds to the column index.\n\n#get the second row and third column\nprint(A[1][2])\n\n#get the first row and first column\nprint(A[0][0])\nprint(A[0,0])\n\nWe can also slice:\n\n#get the first row and the first 2 columns\nprint(A[0,0:2])\n\n#get the first 2 rows and the 3rd column\nprint(A[0:2,2])\n\nWe can also add (or use other mathematical operations) on two arrays:\n\n#define two arrays\nX = np.array([[1,0],[0,1]])\nY = np.array([[2,1],[1,2]])\n\n#view arrays\nprint(X)\nprint(Y)\n\n#combine the arrays\nprint(X+Y)\n\n#perform matrix multiplication on the numpy arrays  A and  B\nprint(np.dot(X,Y))"
  },
  {
    "objectID": "code/Week5_API_and_Data_collection.html",
    "href": "code/Week5_API_and_Data_collection.html",
    "title": "6  APIs and Data collection",
    "section": "",
    "text": "pwd"
  },
  {
    "objectID": "code/Week5_API_and_Data_collection.html#simple-application-programmming-interaces-apis",
    "href": "code/Week5_API_and_Data_collection.html#simple-application-programmming-interaces-apis",
    "title": "6  APIs and Data collection",
    "section": "6.1 Simple Application Programmming Interaces (APIs)",
    "text": "6.1 Simple Application Programmming Interaces (APIs)\nAn API lets two pieces of software talk to each other For example you have your program, you have some data, you have other software components. You use the api to communicate with the api via inputs and outputs.\nJust like a function, you don’t have to know how the API works, but just its inputs and outputs. Pandas is actually a set of software components, much of which are not even written in Python. You have some data. You have a set of software components. We use the pandas api to process the data by communicating with the other Software Components.\nAn example:\n\ndict_ = {\"a\":[11,21,31], \"b\":[12,22,23]}\ndf = pd.DataFrame(dict_)\nprint(df.head())\n\nWhen you create a dictionary, and then create a pandas object with the Dataframe constructor, in API lingo, this is an “instance.” The data in the dictionary is passed along to the pandas API. You then use the dataframe to communicate with the API. When you call the method head, the dataframe communicates with the API displaying the first few rows of the dataframe."
  },
  {
    "objectID": "code/Week5_API_and_Data_collection.html#rest-apis",
    "href": "code/Week5_API_and_Data_collection.html#rest-apis",
    "title": "6  APIs and Data collection",
    "section": "6.2 REST APIs",
    "text": "6.2 REST APIs\nREST APIs are another popular type of API; they allow you to communicate through the internet allowing you to take advantage of resources like storage, access more data, artificial intelligent algorithms, and much more.\nThe RE stands for Representational, the S stands for State, the T stand for Transfer.\nIn rest API’s your program is called the client. The API communicates with a web service you call through the internet. There is a set of rules regarding Communication, Input or Request, and Output or Response.\nYou or your code can be thought of as a client. The web service is referred to as a resource. The client finds the service via an endpoint. The client sends requests to the resource and the response to the client.\nHTTP methods are a way of transmitting data over the internet We tell the Rest API’s what to do by sending a request. The request is usually communicated via an HTTP message. The HTTP message usually contains a JSON file. This contains instructions for what operation we would like the service to perform. This operation is transmitted to the webservice via the internet. The service performs the operation.In the similar manner, the webservice returns a response via an HTTP message, where the information is usually returned via a JSON file. This information is transmitted back to the client."
  },
  {
    "objectID": "code/Week5_API_and_Data_collection.html#pycoingeckp",
    "href": "code/Week5_API_and_Data_collection.html#pycoingeckp",
    "title": "6  APIs and Data collection",
    "section": "6.3 Pycoingeckp",
    "text": "6.3 Pycoingeckp\nCrypto Currency data is excellent to be used in an API because it is being constantly updated and it is vital to CryptoCurrency Trading We will use the Py-Coin-Gecko Python Client/Wrapper for the Coin Gecko API, updated every minute by Coin-Gecko We use the Wrapper/Client because it is easy to use so you can focus on the task of collecting data, we will also introduce pandas time series functions for dealing with time series data\n\n#import software\nfrom pycoingecko import CoinGeckoAPI\n\n#create a client\ncg = CoinGeckoAPI()\n\n#use a fct to request data\n#getting data on bitcoin, in U.S. Dollars, for the past 30 days\n#we get a JSON expressed as a python dictionary of nested lists\nbitcoin_data = cg.get_coin_market_chart_by_id(id=\"bitcoin\", vs_currency=\"usd\",days=30)\n\n#select only the prices\nbitcoin_price_data = bitcoin_data['prices']\n\nbitcoin_price_data = pd.DataFrame(bitcoin_price_data, columns=[\"TimeStamp\", \"Price\"])\nbitcoin_price_data.head()\n\nConvert the timestamp to a more readable format usign the pythin function to_datetime\n\n#convert the timestamp\nbitcoin_price_data['Date'] = pd.to_datetime(bitcoin_price_data['TimeStamp'], unit = 'ms')\nbitcoin_price_data.head()\n\n#an alternative way to do this\n#data['date'] = data['TimeStamp'].apply(lambda d: datetime.date.fromtimestamp(d/1000.0))\n\nNow, we want to create a candlestick plot. To get the data for the daily candlesticks we will group by the date to find the minimum, maximum, first, and last price of each day Finally we will use plotly to create the candlestick chart and plot it.\nThe plotly Python package exists to create, manipulate and render graphical figures (i.e. charts, plots, maps and diagrams) represented by data structures also referred to as figures.\n\n#convert the timestamp\ncandlestick_data = bitcoin_price_data.groupby(bitcoin_price_data.Date.dt.date).agg({'Price': ['min', 'max', 'first', 'last']})\ncandlestick_data.head()\n\n\nfig = go.Figure(data=[go.Candlestick(x=candlestick_data.index,\n        open=candlestick_data['Price']['first'],\n        high=candlestick_data['Price']['max'],\n        low=candlestick_data['Price']['min'],\n        close=candlestick_data['Price']['last'])\n        ])\n\nfig.update_layout(xaxis_rangeslider_visible=False, xaxis_title=\"Date\",yaxis_title=\"Price in USD\", title='Bitcoin Candlestick Chart over Past 30 days')\n\nfig.show()"
  },
  {
    "objectID": "code/Week5_API_and_Data_collection.html#watson-text-to-speech-api",
    "href": "code/Week5_API_and_Data_collection.html#watson-text-to-speech-api",
    "title": "6  APIs and Data collection",
    "section": "6.4 Watson Text to Speech API",
    "text": "6.4 Watson Text to Speech API\nWe will transcribe an audio file using the Watson Text to Speech API. We will then translate the text to a new language using the Watson Language Translator API. In the API call, you will send a copy of the audio file to the API. This is sometimes called a POST request. Then the API will send the text transcription of what the individual is saying. Under the hood, the API is making a GET request. We then send the text we would like to translate into a second language to a second API. The API will translate the text and send the translation back to you. In this case, we translate English to Spanish. We then provide an overview of API keys and endpoints, Watson Speech to Text, and Watson Translate. First, we will review API keys and endpoints. They will give you access to the API."
  },
  {
    "objectID": "code/Week5_API_and_Data_collection.html#rest-apis-http-requests",
    "href": "code/Week5_API_and_Data_collection.html#rest-apis-http-requests",
    "title": "6  APIs and Data collection",
    "section": "6.5 REST APIs & HTTP Requests",
    "text": "6.5 REST APIs & HTTP Requests\nThe HTTP protocol can be thought of as a general protocol of transferring information through the web.\nREST API’s function by sending a request, and the request is communicated via HTTP message. The HTTP message usually contains a JSON file.\nWhen you, the client, use a web page your browser sends an  HTTP request to the server where the page is hosted. The server tries to find the desired resource by default “index.html”. If your request is successful, the server will send the object to the client in an HTTP response; this includes information like the type of the resource, the length of the resource, and other information.\nA Uniform Resource Locator (URL) is the most popular way to find resources on the web.\nWe can break the URL into three parts.\n\nThe scheme, i.e. the protocol, for this lab it will always be http://\nThe Internet address or Base URL which is used to find the location. I.e. www.gitlab.com\nThe route, the location on the webserver, i.e. /images/images.png\n\nTogether this gives something like: http://www.gitlab.com//images/images.png\n\n6.5.1 Status codes\nThe prefix indicates the class; for example, the 100s are informational responses; 100 indicates that everything is OK so far. The 200s are Successful responses: For example, 200 The request has succeeded. Anything in the 400s is bad news. 401 means the request is unauthorized. 500’s stands for server errors, like 501 for not Implemented.\n\n\n6.5.2 Requests\nThe process can be broken into the request and response process. The request using the get method is partially illustrated below. In the start line we have the GET method, this is an HTTP method. Also the location of the resource /index.html and the HTTP version. The Request header passes additional information with an HTTP request:\n\n\n6.5.3 HTTP methods\nWhen an HTTP request is made, an  HTTP method is sent. This tells the server what action to perform. A list of several HTTP methods is shown below:\n\nGET: Retrieve data from the server\nPOST: submits data to the server\nPUT: Updates data already on the server\nDELETE: Deletes data from the server\n\n\n\n6.5.4 Response\nThe response start line contains the version number HTTP/1.0, a status code (200) meaning success, followed by a descriptive phrase (OK). The response header contains useful information. Finally, we have the response body containing the requested file, an HTML document. It should be noted that some requests have headers.\n\n\n6.5.5 The python requests library\n\n6.5.5.1 Basics\nThe Requests Library a popular method for dealing with the HTTP protocol in Python. Requests is a python Library that allows you to send HTTP/1.1 requests easily.\n\n#import the library \nimport requests\n\n#make a get request via the method get\nurl=\"https://www.ibm.com/\"\nr = requests.get(url)\n\nWe have the response object ’r’ , this has information about the request, like the status of the request. We can view the status code using the attribute status_code, which is 200 for OK\n\n#view status of the request\nr.status_code\n\n\n#view the request headers\nr.request.headers\n\nWe can view the request body in the following line. As there is no body for a GET request, we get a None or empty field.\n\n#view the request body\nr.request.body\n\n\n#check the encoding of the data\nr.encoding\n\n\n#view the request header\nheader = r.headers\nheader\n\nAs shown above, we can view the HTTP response header using the attribute headers. This returns a python dictionary of HTTP response headers. We can look at the dictionary values. We can obtain the date the request was sent by using the key Date.\n\n#obtain the date a request was send\nprint(header['date'])\n\n#print the type of data obtained\nprint(header['Content-Type'])\n\nAs the Content-Type is text/html, we can use the attribute text to display the HTML in the body. We can review the first 100 characters.\n\nr.text[0:100]\n\nYou can load other types of data for non-text requests, like images. Consider the URL of the following image:\n\nurl='https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/IDSNlogo.png'\n\n#make a request\nr=requests.get(url)\n\n#look at the response header \nprint(r.headers)\n\n#look at the content type\nprint(r.headers['Content-Type'])\n\nAn image is a response object that contains the image as a bytes-like object. As a result, we must save it using a file object. First, we specify the file path and name\n\n#load some libraries\nimport os \nfrom PIL import Image\n\n#specify the file path and name\npath=os.path.join(os.getcwd() + '/data/image.png')\npath\n\nWe save the file, in order to access the body of the response we use the attribute content then save it using the open function and write method\n\nwith open(\"/Users/ninadombrowski/Desktop/WorkingDir/Notebooks/IBM_Data_Science/4_Python_basics/data/image.png\",'wb') as f:\n    f.write(r.content)\n\n#view image\nImage.open(\"/Users/ninadombrowski/Desktop/WorkingDir/Notebooks/IBM_Data_Science/4_Python_basics/data/image.png\")  \n\n\n\n6.5.5.2 GET request with URL parameters\nYou can use the GET method to modify the results of your query. For example, retrieving data from an API.\nWe send a GET request to the server. Like before, we have the Base URL in the Route and to this we append /get to indicate that we want to perform a get request: http://httpbin.org/get\nAfter GET is requested we have the query string. This is a part of a uniform resource locator (URL) and this sends other information to the web server. The start of the query is a ?, followed by a series of parameter and value pairs: http://httpbin.org/get?Name=Joseph&ID=123\nHere, Name and ID are parameters and Joseph and 123 the search value pair.\n\n#set the base url with appending get\nurl_get=\"http://httpbin.org/get\"\n\n#create a query string via a dictionary\n#the keys = parameter names\n#the values = the value of the query string\npayload={\"name\":\"Joseph\", \"ID\": \"123\"}\n\nr = requests.get(url_get, params = payload)\n\n#check response\nprint(r.status_code)\n\n#check the url\nprint(r.url)\n\n#view the response as text\nprint(r.text)\n\n#look at the content type\nprint(r.headers[\"Content-Type\"])\n\nAs the content ‘Content-Type’ is in the JSON, we format it using the method json() . It returns a Python dict: The key ‘args’ has the name and values for the  query string.\n\nr.json()\n\n\n\n6.5.5.3 POST request\nLike a GET request a POST request is used to send data to a server, but the POST request sends the data in a request body, not the url.\n\n#prepare to send a post request\n#this endpoint will expect data \n#and as such is an easy way to configure an http request to send data to a server\nurl_post = \"http://httpbin.org/post\"\n\n#define our dictionary\npayload={\"name\":\"Joseph\",\n            \"ID\": \"123\"}\n\n#make a post request\nr_post = requests.post(url_post, data = payload)\n\n#compare the requests\nprint(\"Post request URL: \", r_post.url)\nprint(\"Get request URL: \", r.url)\n\nWe can compare the POST and GET request body, we see only the POST request has a body:\n\nprint(\"POST request body:\",r_post.request.body)\nprint(\"GET request body:\",r.request.body)\n\nWe see the POST request has no name or value pairs in it’s url. We can compare the POST and GET request body. We see only the POST request has a body.\n\n#view the key form to get the payload\nr_post.json()[\"form\"]"
  },
  {
    "objectID": "code/Week5_API_and_Data_collection.html#html-for-webscraping",
    "href": "code/Week5_API_and_Data_collection.html#html-for-webscraping",
    "title": "6  APIs and Data collection",
    "section": "6.6 HTML for webscraping",
    "text": "6.6 HTML for webscraping\nLet’s say you were asked to find the name and salary of players in a National Basketball League from a web page.\n\n\n\nThe web page is comprised of HTML that consists of text surrounded by a series of blue text elements enclosed in angle brackets called tags. The tags tells the browser how to display the content.\nThe first portion contains the “DOCTYPE html” which declares this document is an HTML document.\n\n element is the root element of an HTML page\n\n element contains meta information about the HTML page.\nNext, we have the body, this is what’s displayed on the web page. This is usually the data we are interested in, we see the elements with an “h3”, this means type 3 heading, makes the text larger and bold. These tags have the names of the players, notice the data is enclosed in the elements.It starts with a h3 in brackets and ends in a slash h3 in brackets.\nThere is also a different tag “p”, this means paragraph, each p tag contains a player’s salary.\nEach HTML document can actually be referred to as a document tree. The tag HTML tag contains the head and body tag. The Head and body tag are the descendants of the html tag. In particular they are the children of the HTML tag. HTML tag is their parent.The head and body tag are siblings as they are on the same level. Title tag is the child of the head tag and its parent is the head tag. The title tag is a descendant of the HTML tag but not its child."
  },
  {
    "objectID": "code/Week5_API_and_Data_collection.html#webscraping",
    "href": "code/Week5_API_and_Data_collection.html#webscraping",
    "title": "6  APIs and Data collection",
    "section": "6.7 Webscraping",
    "text": "6.7 Webscraping\nWebscraping is a process that can be used to automatically extract information from a website, and can easily be accomplished within a matter of minutes and not hours.\nTo get started we just need a little Python code and the help of two modules named Requests and Beautiful Soup and the method find_all\nThe requests method is used to download the webpage\nBeautifulSoup represents HTML as a set of Tree like objects with methods used to parse the HTML.\nFind_all is a filter, you can use filters to filter based on a tag’s name, it’s attributes, the text of a string, or on some combination of these.\nLet’s say we were asked to find the name and salary of players in a National Basketball League:\n\n#import libs for the webscraping and downloading the web page\nfrom bs4 import BeautifulSoup \nimport requests \n\nBeautiful Soup is a Python library for pulling data out of HTML and XML files, we will focus on HTML files. This is accomplished by representing the HTML as a set of objects with methods used to parse the HTML. We can navigate the HTML as a tree and/or filter out what we are looking for.\nConsider the following HTML:\n<!DOCTYPE html>\n<html>\n<head>\n<title>Page Title</title>\n</head>\n<body>\n<h3><b id='boldest'>Lebron James</b></h3>\n<p> Salary: $ 92,000,000 </p>\n<h3> Stephen Curry</h3>\n<p> Salary: $85,000, 000 </p>\n<h3> Kevin Durant </h3>\n<p> Salary: $73,200, 000</p>\n</body>\n</html>\nRenders to:\n<!DOCTYPE html>\n\n\n\nPage Title\n\n\n\n\nLebron James\n\n\nSalary: $ 92,000,000\n\n\nStephen Curry\n\n\nSalary: $85,000, 000\n\n\nKevin Durant\n\n\nSalary: $73,200, 000\n\n\n\nWe can store this html as a string varialbe:\n\nhtml=\"<!DOCTYPE html><html><head><title>Page Title</title></head><body><h3><b id='boldest'>Lebron James</b></h3><p> Salary: $ 92,000,000 </p><h3> Stephen Curry</h3><p> Salary: $85,000, 000 </p><h3> Kevin Durant </h3><p> Salary: $73,200, 000</p></body></html>\"\n\nTo parse a document, pass it into the BeautifulSoup constructor, the BeautifulSoup object, which represents the document as a nested data structure:\n\nsoup = BeautifulSoup(html, \"html.parser\")\n\nFirst, the document is converted to Unicode, (similar to ASCII), and HTML entities are converted to Unicode characters. Beautiful Soup transforms a complex HTML document into a complex tree of Python objects. The BeautifulSoup object can create other types of objects. In this lab, we will cover BeautifulSoup and Tag objects that for the purposes of this lab are identical, and NavigableString objects.\nWe can use the method prettify() to display the HTML in the nested structure:\n\nprint(soup.prettify())\n\n\n6.7.1 Tags\nLet’s say we want the title of the page and the name of the top paid player we can use the Tag. The Tag object corresponds to an HTML tag in the original document, for example, the tag title.\n\ntag_object = soup.title\nprint(\"tag object:\", tag_object)\n\nWe can extract the tag type like this:\n\ntag_object = soup.title\nprint(\"tag object type:\", type(tag_object))\n\nIf there is more than one Tag with the same name, the first element with that Tag name is called, here, this corresponds to the most paid player:\n\ntag_object=soup.h3\ntag_object\n\n\n\n6.7.2 Children, Parents and Sibilings\nAs stated above the Tag object is a tree of objects we can access the child of the tag or navigate down the branch as follows:\n\ntag_child =tag_object.b\ntag_child\n\nYou can access the parent with the parent\n\nparent_tag = tag_child.parent\nparent_tag\n\ntag_object parent is the body element.\n\ntag_object.parent\n\ntag_object sibling is the paragraph element\n\nsibling_1=tag_object.next_sibling\nsibling_1\n\nsibling_2 is the header element which is also a sibling of both sibling_1 and tag_object\n\nsibling_2=sibling_1.next_sibling\nsibling_2\n\n\n\n6.7.3 HTML attributes\nIf the tag has attributes, the tag id=“boldest” has an attribute id whose value is boldest. You can access a tag’s attributes by treating the tag like a dictionary:\n\ntag_child['id']\n\nYou can access that dictionary directly as attrs:\n\ntag_child.attrs\n\nYou can also work with Multi-valued attribute check out this page for more.\nWe can also obtain the content if the attribute of the tag using the Python get() method.\n\ntag_child.get('id')\n\n\n\n6.7.4 Navigable string\nA string corresponds to a bit of text or content within a tag. Beautiful Soup uses the NavigableString class to contain this text. In our HTML we can obtain the name of the first player by extracting the sting of the Tag object tag_child as follows:\n\ntag_string = tag_child.string\ntag_string\n\nA NavigableString is just like a Python string or Unicode string, to be more precise. The main difference is that it also supports some BeautifulSoup features. We can covert it to sting object in Python:\n\nunicode_string = str(tag_child.string)\nunicode_string\n\n\n\n6.7.5 Filter\nFilters allow you to find complex patterns, the simplest filter is a string. In this section we will pass a string to a different filter method and Beautiful Soup will perform a match against that exact string. Consider the following HTML of rocket launchs:\n<table>\n  <tr>\n    <td id='flight' >Flight No</td>\n    <td>Launch site</td> \n    <td>Payload mass</td>\n   </tr>\n  <tr> \n    <td>1</td>\n    <td><a href='https://en.wikipedia.org/wiki/Florida'>Florida</a></td>\n    <td>300 kg</td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td><a href='https://en.wikipedia.org/wiki/Texas'>Texas</a></td>\n    <td>94 kg</td>\n  </tr>\n  <tr>\n    <td>3</td>\n    <td><a href='https://en.wikipedia.org/wiki/Florida'>Florida<a> </td>\n    <td>80 kg</td>\n  </tr>\n</table>\n\n\n\n\nFlight No\n\n\nLaunch site\n\n\nPayload mass\n\n\n\n\n1\n\n\nFlorida\n\n\n300 kg\n\n\n\n\n2\n\n\nTexas\n\n\n94 kg\n\n\n\n\n3\n\n\nFlorida\n\n\n80 kg\n\n\n\n\nWe can store it as a string in the variable table:\n\ntable=\"<table><tr><td id='flight'>Flight No</td><td>Launch site</td> <td>Payload mass</td></tr><tr> <td>1</td><td><a href='https://en.wikipedia.org/wiki/Florida'>Florida<a></td><td>300 kg</td></tr><tr><td>2</td><td><a href='https://en.wikipedia.org/wiki/Texas'>Texas</a></td><td>94 kg</td></tr><tr><td>3</td><td><a href='https://en.wikipedia.org/wiki/Florida'>Florida<a> </td><td>80 kg</td></tr></table>\"\n\ntable_bs = BeautifulSoup(table, \"html.parser\")\ntable_bs\n\n\n6.7.5.1 Find_all\nThe find_all() method looks through a tag’s descendants and retrieves all descendants that match your filters.\nThe Method signature for find_all(name, attrs, recursive, string, limit, **kwargs)\n\n6.7.5.1.1 Name\nWhen we set the name parameter to a tag name, the method will extract all the tags with that name and its children.\n\ntable_rows = table_bs.find_all('tr')\ntable_rows\n\nThe result is a Python Iterable just like a list, each element is a tag object:\n\nfirst_row =table_rows[0]\nfirst_row\n\nwe can obtain the child with:\n\nfirst_row.td\n\nIf we iterate through the list, each element corresponds to a row in the table:\n\nfor i, row in enumerate(table_rows):\n    print(\"row\", i, \"is\", row)\n\nAs row is a cell object, we can apply the method find_all to it and extract table cells in the object cells using the tag td, this is all the children with the name td. The result is a list, each element corresponds to a cell and is a Tag object, we can iterate through this list as well. We can extract the content using the string attribute.\n\nfor i, row in enumerate(table_rows):\n    print(\"row\", i)\n    cells = row.find_all('td')\n    for j, cell in enumerate(cells):\n        print(\"column\", j, \"cell\", cell)\n\nIf we use a list we can match against any item in that list.\n\nlist_input=table_bs .find_all(name=[\"tr\", \"td\"])\nlist_input\n\n\n\n6.7.5.1.2 Attributes\nIf the argument is not recognized it will be turned into a filter on the tag’s attributes. For example the id argument, Beautiful Soup will filter against each tag’s id attribute. For example, the first td elements have a value of id of flight, therefore we can filter based on that id value.\n\ntable_bs.find_all(id=\"flight\")\n\nWe can find all the elements that have links to the Florida Wikipedia page:\n\nlist_input=table_bs.find_all(href=\"https://en.wikipedia.org/wiki/Florida\")\nlist_input\n\nIf we set the href attribute to True, regardless of what the value is, the code finds all tags with href value:\n\ntable_bs.find_all(href=True)\n\nThere are other methods for dealing with attributes and other related methods; Check out the following link\n\n\n6.7.5.1.3 Strings\nWith string you can search for strings instead of tags, where we find all the elments with Florida:\n\ntable_bs.find_all(string = \"Florida\")\n\n\n\n6.7.5.1.4 find\nThe find_all() method scans the entire document looking for results, it’s if you are looking for one element you can use the find() method to find the first element in the document. Consider the following two tables:\n\nRocket Launch\n\n\n\n\n\n\nFlight No\n\n\nLaunch site\n\n\nPayload mass\n\n\n\n\n1\n\n\nFlorida\n\n\n300 kg\n\n\n\n\n2\n\n\nTexas\n\n\n94 kg\n\n\n\n\n3\n\n\nFlorida\n\n\n80 kg\n\n\n\n\n\n\n\nPizza Party\n\n\n\n\n\n\nPizza Place\n\n\nOrders\n\n\nSlices\n\n\n\n\nDomino’s Pizza\n\n\n10\n\n\n100\n\n\n\n\nLittle Caesars\n\n\n12\n\n\n144\n\n\n\n\nPapa John’s\n\n\n15\n\n\n165\n\n\n\n\n\n\n\ntwo_tables=\"<h3>Rocket Launch </h3><p><table class='rocket'><tr><td>Flight No</td><td>Launch site</td> <td>Payload mass</td></tr><tr><td>1</td><td>Florida</td><td>300 kg</td></tr><tr><td>2</td><td>Texas</td><td>94 kg</td></tr><tr><td>3</td><td>Florida </td><td>80 kg</td></tr></table></p><p><h3>Pizza Party  </h3><table class='pizza'><tr><td>Pizza Place</td><td>Orders</td> <td>Slices </td></tr><tr><td>Domino's Pizza</td><td>10</td><td>100</td></tr><tr><td>Little Caesars</td><td>12</td><td >144 </td></tr><tr><td>Papa John's </td><td>15 </td><td>165</td></tr>\"\n\ntwo_tables_bs= BeautifulSoup(two_tables, 'html.parser')\n\nAccess the first table with the tag name table:\n\ntwo_tables_bs.find(\"table\")\n\nWe can filter on the class attribute to find the second table, but because class is a keyword in Python, we add an underscore.\n\ntwo_tables_bs.find(\"table\",class_='pizza')\n\n\n\n\n\n6.7.6 Downloading and scraping from a web paste\n\n#download the contents from a webpage\nurl = \"http://www.ibm.com\"\n\n#use get to download the contents of the webpage in text format and store in a variable called data:\ndata = requests.get(url).text\n\n#create a beautiful soup object\nsoup = BeautifulSoup(data,\"html.parser\")\n\n#scrape all links (in html anchor/link is represented by the tag <a>)\nfor link in soup.find_all('a', href = True):\n    print(link.get('href'))\n\nWe can also Scrape all images Tags\n\nfor link in soup.find_all('img'):\n    print(link)\n    print(link.get('src'))\n\n\n6.7.6.1 Scrape data from html tables\n\n#The below url contains an html table with data about colors and color codes.\nurl = \"https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DA0321EN-SkillsNetwork/labs/datasets/HTMLColorCodes.html\"\n\nBefore proceeding to scrape a web site, you need to examine the contents, and the way data is organized on the website. Open the above url in your browser and check how many rows and columns (32 and 6) are there in the color table.\n\n# get the contents of the webpage in text format and store in a variable called data\ndata  = requests.get(url).text\n\n#convert to a soup object\nsoup = BeautifulSoup(data,\"html.parser\")\n\n#find a table in the html webpage via the table tag\ntable = soup.find('table')\n\n#get all rows from the table via the tr tag\nfor row in table.find_all('tr'):\n    #get all columns for each row using the td tag\n    cols = row.find_all('td')\n    #store the value in column3 as color name\n    color_name = cols[2].string\n    #store the color code in column 4 as color_code\n    color_code = cols[3].string\n    print(\"{}--->{}\".format(color_name, color_code))\n\n\n#Get all rows from the table\nfor row in table.find_all('tr'): # in html table row is represented by the tag <tr>\n    # Get all columns in each row.\n    cols = row.find_all('td') # in html a column is represented by the tag <td>\n    color_name = cols[2].string # store the value in column 3 as color_name\n    color_code = cols[3].string # store the value in column 4 as color_code\n    print(\"{}--->{}\".format(color_name,color_code))\n\n\n\n6.7.6.2 Scrape data from HTML tables into a DataFrame using BeautifulSoup and Pandas\n\nimport pandas as pd \n\n#The below url contains html tables with data about world population.\nurl = \"https://en.wikipedia.org/wiki/World_population\"\n\n#get the contents and convert\ndata = requests.get(url).text\nsoup = BeautifulSoup(data, \"html.parser\")\n\n#find all html tables\ntables = soup.find_all('table')\n\n#see how many tables we got\nlen(tables)\n\nAssume that we are looking for the 10 most densly populated countries table, we can look through the tables list and find the right one we are look for based on the data in each table or we can search for the table name if it is in the table but this option might not always work.\n\nfor index,table in enumerate(tables):\n    if (\"10 most densely populated countries\" in str(table)):\n        table_index = index\nprint(table_index)\n\nSee if you can locate the table name of the table, 10 most densly populated countries, below.\n\n#print(tables[table_index].prettify())\n\nNow, we can extract data\n\npopulation_data = pd.DataFrame(columns=[\"Rank\", \"Country\", \"Population\", \"Area\", \"Density\"])\n\nfor row in tables[table_index].tbody.find_all(\"tr\"):\n    col = row.find_all(\"td\")\n    if (col != []):\n        rank = col[0].text\n        country = col[1].text\n        population = col[2].text.strip()\n        area = col[3].text.strip()\n        density = col[4].text.strip()\n        population_data = population_data.append({\"Rank\":rank, \"Country\":country, \"Population\":population, \"Area\":area, \"Density\":density}, ignore_index=True)\n\npopulation_data\n\n\n\n6.7.6.3 Scrape data from HTML tables into a DataFrame using BeautifulSoup and read_html\nUsing the same url, data, soup, and tables object as in the last section we can use the read_html function to create a DataFrame.\nRemember the table we need is located in tables[table_index]\nWe can now use the pandas function read_html and give it the string version of the table as well as the flavor which is the parsing engine bs4.\n\n#pd.read_html(str(tables[5]))\n\nThe function read_html always returns a list of DataFrames so we must pick the one we want out of the list.\n\npopulation_data_read_html = pd.read_html(str(tables[5]), flavor='bs4')[0]\n#population_data_read_html\n\n\n\n6.7.6.4 Scrape data from HTML tables into a dataframe using read_html\nWe can also use the read_html function to directly get DataFrames from a url.\n\ndataframe_list = pd.read_html(url)\n\n#check if we find the tables again\nprint(len(dataframe_list))\n\n#get the data we need\n#dataframe_list[5]\n\nWe can also use the match parameter to select the specific table we want. If the table contains a string matching the text it will be read.\n\ndf = pd.read_html(url, match=\"10 most densely populated countries\")[0]\n#df\n\n\n\n\n6.7.7 Working with different file formats\nData engineering is one of the most critical and foundational skills in any data scientist’s toolkit.\nThere are several steps in Data Engineering process.\n\nExtract - Data extraction is getting data from multiple sources. Ex. Data extraction from a website using Web scraping or gathering information from the data that are stored in different formats(JSON, CSV, XLSX etc.).\nTransform - Tarnsforming the data means removing the data that we don’t need for further analysis and converting the data in the format that all the data from the multiple sources is in the same format.\nLoad - Loading the data inside a data warehouse. Data warehouse essentially contains large volumes of data that are accessed to gather insights.\n\nA file format is a standard way in which information is encoded for storage in a file. First, the file format specifies whether the file is a binary or ASCII file. Second, it shows how the information is organized. For example, the comma-separated values (CSV) file format stores tabular data in plain text.\nTo identify a file format, you can usually look at the file extension to get an idea. For example, a file saved with name “Data” in “CSV” format will appear as “Data.csv”. By noticing the “.csv” extension, we can clearly identify that it is a “CSV” file and the data is stored in a tabular format.\n\n6.7.7.1 csv\nThe Comma-separated values file format falls under a spreadsheet file format.\nIn a spreadsheet file format, data is stored in cells. Each cell is organized in rows and columns. A column in the spreadsheet file can have different types. For example, a column can be of string type, a date type, or an integer type.\nEach line in CSV file represents an observation, or commonly called a record. Each record may contain one or more fields which are separated by a comma.\nWe use pandas.read_csv() function to read the csv file. In the parentheses, we put the file path along with a quotation mark as an argument, so that pandas will read the file into a data frame from that address. The file path can be either a URL or your local file address.\n\nimport pandas as pd\nimport numpy as np\n\ndf = pd.read_csv(\"../data/addresses.csv\", header=None)\ndf\n\nWe can also add column headers:\n\ndf.columns = [\"FirstName\", \"LastName\", \"Location\", \"City\", \"State\", \"AreaCode\"]\n#df\n\n\n\n6.7.7.2 Pandas transform function\nPython’s Transform function returns a self-produced dataframe with transformed values after applying the function specified in its parameter.\n\n#create a test df\ndf=pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), columns=['a', 'b', 'c'])\ndf\n\n#add 10 to each element in a dataframe\ndf = df.transform(func = lambda x : x + 10)\nprint(df)\n\n#to find the square root to each element of the dataframe\nresult = df.transform(func = [\"sqrt\"])\nprint(result)\n\n\n\n6.7.7.3 Json\nJSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write.\nJSON is built on two structures:\n\nA collection of name/value pairs. In various languages, this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array.\nAn ordered list of values. In most languages, this is realized as an array, vector, list, or sequence.\n\nJSON is a language-independent data format. It was derived from JavaScript, but many modern programming languages include code to generate and parse JSON-format data. It is a very common data format with a diverse range of applications.\nThe text in JSON is done through quoted string which contains the values in key-value mappings within { }. It is similar to the dictionary in Python.\n\n6.7.7.3.1 Writing JSON to a file\nThis is usually called serialization. It is the process of converting an object into a special format which is suitable for transmitting over the network or storing in file or database.\nTo handle the data flow in a file, the JSON library in Python uses the dump() or dumps() function to convert the Python objects into their respective JSON object. This makes it easy to write data to files.\n\nimport json\n\nperson = {\n    'first_name' : 'Mark',\n    'last_name' : 'abc',\n    'age' : 27,\n    'address': {\n        \"streetAddress\": \"21 2nd Street\",\n        \"city\": \"New York\",\n        \"state\": \"NY\",\n        \"postalCode\": \"10021-3100\"\n    }\n}\n\nperson\n\njson.dump() method can be used for writing to JSON file.\nSyntax: json.dump(dict, file_pointer)\nParameters:\n\ndictionary – name of the dictionary which should be converted to JSON object.\nfile pointer – pointer of the file opened in write or append mode.\n\n\nwith open('../data/person.json', 'w') as f:  # writing JSON object\n    json.dump(person, f)\n\njson.dumps() that helps in converting a dictionary to a JSON object.\nIt takes two parameters:\n\ndictionary – name of the dictionary which should be converted to JSON object.\nindent – defines the number of units for indentation\n\n\n# Serializing json  \njson_object = json.dumps(person, indent = 4) \n  \n# Writing to sample.json \nwith open(\"../data/sample.json\", \"w\") as outfile: \n    outfile.write(json_object) \n\nprint(json_object)\n\n\n\n6.7.7.3.2 Reading JSON to a file\nThis process is usually called Deserialization - it is the reverse of serialization. It converts the special format returned by the serialization back into a usable object.\nUsing json.load() The JSON package has json.load() function that loads the json content from a json file into a dictionary.\nIt takes one parameter:\nFile pointer: A file pointer that points to a JSON file.\n\n#open a json file\nwith open('../data/sample.json', 'r') as openfile:\n    json_object = json.load(openfile)\n\nprint(json_object) \nprint(type(json_object)) \n\n\n\n\n6.7.7.4 Reading XLSX to a file\n\ndf = pd.read_excel(\"../data/file_example_XLSX_10.xlsx\", engine='openpyxl')\ndf\n\n\n\n6.7.7.5 XML format\nXML is also known as Extensible Markup Language. As the name suggests, it is a markup language. It has certain rules for encoding data. XML file format is a human-readable and machine-readable file format.\nPandas does not include any methods to read and write XML files. Here, we will take a look at how we can use other modules to read data from an XML file, and load it into a Pandas DataFrame.\n\n6.7.7.5.1 Writing with xml.etree.ElementTree\nThe xml.etree.ElementTree module comes built-in with Python. It provides functionality for parsing and creating XML documents. ElementTree represents the XML document as a tree. We can move across the document using nodes which are elements and sub-elements of the XML file.\nFor more information please read the xml.etree.ElementTree documentation.\n\nimport xml.etree.ElementTree as ET\n\n# create the file structure\nemployee = ET.Element('employee')\ndetails = ET.SubElement(employee, 'details')\nfirst = ET.SubElement(details, 'firstname')\nsecond = ET.SubElement(details, 'lastname')\nthird = ET.SubElement(details, 'age')\nfirst.text = 'Shiv'\nsecond.text = 'Mishra'\nthird.text = '23'\n\n# create a new XML file with the results\nmydata1 = ET.ElementTree(employee)\n# myfile = open(\"items2.xml\", \"wb\")\n# myfile.write(mydata)\nwith open(\"../data/new_sample.xml\", \"wb\") as files:\n    mydata1.write(files)\n\n\n\n6.7.7.5.2 Reading with xml.etree.ElementTree¶\nYou would need to firstly parse an XML file and create a list of columns for data frame, then extract useful information from the XML file and add to a pandas data frame.\nHere is a sample code that you can use.:\n\nimport xml.etree.ElementTree as etree\n\ntree = etree.parse(\"../data/Sample-employee-XML-file.xml\")\n\nroot = tree.getroot()\ncolumns = [\"firstname\", \"lastname\", \"title\", \"division\", \"building\",\"room\"]\n\ndatatframe = pd.DataFrame(columns = columns)\n\nfor node in root: \n    firstname = node.find(\"firstname\").text\n    lastname = node.find(\"lastname\").text \n    title = node.find(\"title\").text \n    division = node.find(\"division\").text \n    building = node.find(\"building\").text\n    room = node.find(\"room\").text\n    datatframe = datatframe.append(pd.Series([firstname, lastname, title, division, building, room], index = columns), ignore_index = True)\n\ndatatframe\n\n\n\n6.7.7.5.3 Reading xml file using pandas.read_xml function\nWe can also read the downloaded xml file using the read_xml function present in the pandas library which returns a Dataframe object.\nFor more information read the pandas.read_xml documentation.\n\n# Herein xpath we mention the set of xml nodes to be considered for migrating  to the dataframe which in this case is details node under employees.\ndf2=pd.read_xml(\"../data/Sample-employee-XML-file.xml\") \ndf2\n\n\n\n\n6.7.7.6 Binary file format\n“Binary” files are any files where the format isn’t made up of readable characters. It contain formatting information that only certain applications or processors can understand. While humans can read text files, binary files must be run on the appropriate software or processor before humans can read them.\nBinary files can range from image files like JPEGs or GIFs, audio files like MP3s or binary document formats like Word or PDF.\nLet’s see how to read an Image file.\n\n6.7.7.6.1 Reading an image file\nPython supports very powerful tools when it comes to image processing. Let’s see how to process the images using the PIL library.\nPIL is the Python Imaging Library which provides the python interpreter with image editing capabilities.\n\nfrom PIL import Image \n\n# Read image \nimg = Image.open('../data/dog.jpg') \n  \n# Output Images \ndisplay(img)"
  },
  {
    "objectID": "code/Week5_API_and_Data_collection.html#data-analysis",
    "href": "code/Week5_API_and_Data_collection.html#data-analysis",
    "title": "6  APIs and Data collection",
    "section": "6.8 Data analysis",
    "text": "6.8 Data analysis\nIn this section, you will learn how to approach data acquisition in various ways and obtain necessary insights from a dataset. By the end of this lab, you will successfully load the data into Jupyter Notebook and gain some fundamental insights via the Pandas Library.\nIn our case, the Diabetes Dataset is an online source and it is in CSV (comma separated value) format. Let’s use this dataset as an example to practice data reading.\nContext: This dataset is originally from the National Institute of Diabetes and Digestive and Kidney Diseases. The objective of the dataset is to diagnostically predict whether or not a patient has diabetes, based on certain diagnostic measurements included in the dataset. Several constraints were placed on the selection of these instances from a larger database. In particular, all patients here are females at least 21 years of age of Pima Indian heritage.\nContent: The datasets consists of several medical predictor variables and one target variable, Outcome. Predictor variables includes the number of pregnancies the patient has had, their BMI, insulin level, age, and so on.\nWe have 768 rows and 9 columns. The first 8 columns represent the features and the last column represent the target/label.\n\ndf = pd.read_csv(\"../data/diabetes.csv\")\ndf.head()\n\nThis method prints information about a DataFrame including the index dtype and columns, non-null values and memory usage\n\ndf.info()\n\nPandas describe() is used to view some basic statistical details like percentile, mean, standard deviation, etc. of a data frame or a series of numeric values. When this method is applied to a series of strings, it returns a different output\n\ndf.describe()\n\n\n6.8.1 Identifying and handling missing values\nWe use Python’s built-in functions to identify these missing values. There are two methods to detect missing data:\n.isnull()\n.notnull()\nThe output is a boolean value indicating whether the value that is passed into the argument is in fact missing data. “True” stands for missing value, while “False” stands for not missing value.\n\nmissing_data = df.isnull()\nmissing_data.head()\n\nCount missing values in each column Using a for loop in Python, we can quickly figure out the number of missing values in each column. As mentioned above, “True” represents a missing value, “False” means the value is present in the dataset. In the body of the for loop the method “.value_counts()” counts the number of “True” values.\n\nfor column in missing_data.columns.values.tolist():\n    print(column)\n    print(missing_data[column].value_counts())\n    print(\"\")\n\nAs you can see above, there is no missing values in the dataset.\nCorrect data format Check all data is in the correct format (int, float, text or other).\nIn Pandas, we use\n.dtype() to check the data type\n.astype() to change the data type\nNumerical variables should have type ‘float’ or ‘int’.\n\ndf.dtypes\n\n\n\n6.8.2 Data vis\nVisualization is one of the best way to get insights from the dataset. Seaborn and Matplotlib are two of Python’s most powerful visualization libraries.\n\n# import libraries\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n#define categories\nlabels= 'Diabetic','Not Diabetic'\n\nplt.pie(df['Outcome'].value_counts(),labels=labels,autopct='%0.02f%%')\nplt.legend()\nplt.show()\n\n\ndf.dtypes"
  }
]