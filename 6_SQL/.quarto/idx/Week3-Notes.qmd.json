{"title":"Using String Patterns","markdown":{"headingText":"Using String Patterns","containsRefs":false,"markdown":"\n- What if we don't know exactly what to specify in the where clause?\n- A where clause always requires a predicate, i.e. an expression that evaluates to true, false or unknown\n- We can use the `LIKE` predicate with string patterns for searching a pattern in a column\n- For example we only remember that the authors first name starts with R we can do\n\n```\nselect firstname from Author\nwhere firstname LIKE R%\n```\n\n# Using Ranges\n\n- The percent sign (a wildcard character used to substitute other characters) can be placed before the pattern, after the pattern, or both before and after the pattern\n- Now lets retrieve the list of books whose number of pages is more than 290, but less than 300 to find a range \n\n```\nselect title,pages from Author\nwhere pages >=290 AND pages <= 300\n```\n\n- Alternatively, we can use a range of numbers to specify a condition\n\n```\nselect title,pages from Author\nwhere pages between 290 AND 300\n```\n\n# Using a set of values\n\n- In some cases, there are data values that cannot be grouped under ranges\n- I.e. retrieve authors from AU or Brasil\n\n```\nselect firstname,lastname,country from Author\nwhere country='AU' OR country='BR'\n```\n\n- How to we retrieve authors from india, australia and china without having a where clause that becomes too long? For this we can use the `IN` operator that allows us to specifiy a list of expressions\n\n\n```\nselect firstname,lastname,country from Author\nwhere country IN ('AU','BR')\n```\n\n# Sorting result sets\n\n- We can for example display the results of a search in alphabetical order to make it easier to read via the `order by` clause\n- By default ascending order is used\n\n```\nselect title from Book\nOrder by title\n```\n\n- descending order using the `DESC` keyword\n\n```\nselect title from Book\nOrder by title DESC\n```\n\n- Order by column sequence number, i.e. select by the 2nd column \n\n```\nselect title,pages from Book\nOrder by 2\n```\n\n\n# Grouping result sets\n\n## Eliminating duplicates using the DISTINCT clause\n\n- This would list all countries our authors come from but including duplicates\n\n```\nselect country from Author\nOrder by 1\n```\n\n- This would list all countries our authors without duplocates\n\n```\nselect distinct(country) from Author\n```\n\n## Grouping results with the Group by clause\n\n- How many authors come from the same country?\n\n```\nselect country, count(country) from author\nGroup by country\n```\n\n- we can assign a column name to the result set. We do this using the \"as\" keyword\n\n```\nselect country, count(country) as Count from author\nGroup by country\n```\n\n## Restricting the results set using the HAVING clause\n\n- Lets check if there are more than 4 authors from the same country\n\n```\nselect country, count(country) from author\nGroup by country\nHaving count(country) > 4\n```\n\n# Exercise\n\n1. Load hr_data database\n\n```{r setup}\nlibrary(DBI)\nlibrary(RSQLite)\ndb = dbConnect(RSQLite::SQLite(), dbname =\"Week3/tables/employees.db\")\n\n#set connection for each chunk, other wise we would need `{sql, connection=\"db\"}`\nknitr::opts_chunk$set(connection = \"db\", max.print = 10)\n```\n\n2. Retrieve all employees whose address is in Elgin,IL. view the table as is too see how to do this\n\n```{sql, connection=\"db\"}\nselect * from employees\n```\n\n```{sql}\nselect * from employees\nwhere address like \"%Elgin,IL\"\n```\n\n2. Retrieve all employees who were born during the 1970's.\n\n```{sql}\nselect * from employees\nwhere b_date like '%/197%'\n```\n\n3. Retrieve all employees in department 5 whose salary is between 60000 and 70000.\n\n```{sql}\nselect * from employees\nwhere dep_id = 5 and (salary between 60000 and 70000)\n```\n\n4. Retrieve a list of employees ordered by department ID.\n\n```{sql}\nselect f_name,dep_id from employees\norder by dep_id\n```\n5. Retrieve a list of employees ordered in descending order by department ID and within each department ordered alphabetically in descending order by last name.\n\n```{sql}\nselect f_name,l_name,dep_id from employees\norder by dep_id DESC, l_name desc\n```\n6. Retrieve a list of employees ordered in descending order by department ID and within each department ordered alphabetically in descending order by last name. BUT  use department name instead of department ID. Retrieve a list of employees ordered by department name, and within each department ordered alphabetically in descending order by last name.\n\n**Notice** In the SQL Query above, D and E are aliases for the table names. Once you define an alias like D in your query, you can simply write D.COLUMN_NAME rather than the full form DEPARTMENTS.COLUMN_NAME.\n\n```{sql}\nselect d.dep_name,e.f_name,e.l_name from employees as E, departments as D\nwhere e.dep_id = d.dep_id\n```\n7. For each department ID retrieve the number of employees in the department.\n\nselect country, count(country) from author\nGroup by country\n\n```{sql}\nselect dep_id, count(*) from employees\ngroup by dep_id\n```\n\n8. For each department retrieve the number of employees in the department, and the average employee salary in the department..\n\n```{sql}\nselect dep_id, count(f_name),avg(salary) from employees\ngroup by dep_id\n```\n\n9. Label the computed columns in the result set of SQL problem 8 as NUM_EMPLOYEES and AVG_SALARY.\n\n```{sql}\nselect dep_id, count(f_name) as \"num_employees\" ,avg(salary) as \"avg_salary\" from employees\ngroup by dep_id\n```\n\n\n\n10. In SQL problem 9., order the result set by Average Salary..\n\n```{sql}\nselect dep_id, count(f_name) as \"num_employees\" ,avg(salary) as \"avg_salary\" from employees\ngroup by dep_id\norder by avg_salary\n```\n\n11. In SQL problem 10, limit the result to departments with fewer than 4 employees.\n\n```{sql}\nselect dep_id, count(f_name) as \"num_employees\" ,avg(salary) as \"avg_salary\" from employees\ngroup by dep_id\nhaving count(*) < 4\n```\n\n# Build in database functions\n\n- Database functions can reduce the amount of data that needs to be retrieved and thus reducing network traffic and bandwidth use\n- Its also possible to define your own functions\n\n## Aggregate or Column functions\n\n- An aggregate function takes a collection of like values, such as all of the values in a column, as input, and returns a single value or null\n- Examples for an aggregate function: \n  - sum(): add up all values i.e. to add all values in the cost column\n  \n  ```\n  select SUM(cost) from petrescue\n  ```\n\n  ```\n  #use `as` to name the resulting output column \n  select SUM(cost) as sum_of_cost\n  from petrescue\n  ```\n  \n  - min(): returns the lowest value\n  - max(): returns the highest value; i.e. lets get the maximum quantity of an animal:\n  \n  ```\n  select Max(quantity) from petrescue\n  ```\n\n  ```\n  #get the min value off the ID column for only a subset of the data, i.e. only dogs\n  select min(id) from petrescue\n  where Animal='dog'\n  ```\n  \n  - avg(): return the average or mean value; i.e. specify the average cost\n  \n  ```\n  select avg(cost) from petrescue\n  ```\n  \n  ```\n  #we can also perform math operations between columns\n  #i.e. we can calulate the avg cost per dog\n  select avg(cost) from petrescue\n  select avg(cost/quantity) from petrescue\n  where animal='dog'\n  ```\n  \n  - etc(): \n\n\n\n## Scalar and string functions\n\n\n- Scalar: perform operations on every input value\n- Examples:\n  - round(): ie. round up/down every  value in the cost column we do:\n  \n  ```\n  select round(cost) from petrescue\n  ```\n  \n  - length(): for example retrieve the length of each value in the animal column. If we have strings, we perform a string function.\n  \n  ```\n  select length(animal) from petrescue\n  ```\n  \n  - ucase/lcase(): return upper or lower case values of string. I.e. if we want to retrieve the values in the animal column in uppercase:\n  \n  ```\n  select upcase(animal) from petrescue\n  ```\n\n  ```\n  #if we want to lower case value for the cat in the animal column, we can add a where clause\n  select * from petrescue\n  where lcase(animal)='cat'\n  ```\n\n  ```\n  #use disting to get unique values for the animal colum\n  select distinct(ucase(animal)) from petrescue\n  ```\n\n## Date and time build-in functions\n\n- Most databases contain special datatypes for dates and times\n- I.e. DB2 contains types for:\n  - Date: YYYYMMDD\n  - Time: HHMMSS\n  - Timestamp: YYYYXXDDHHMMSSZZZZZZ\n- Functions to extract dates/times:\n  - year()\n  - month() \n  - day() \n  - dayofmonth()     \n  - dayofweek() \n  - dayofyear() \n  - week() \n  - hour() \n  - minute() \n  - second() \n\nI.e. get the day portion from each rescue date\n\n```\nselect day(rescuedate) from petrescue\nwhere animal = 'cat'\n```\n\nI.e. get the number of rescues during the month of may\n\n```\nselect count(*) from petrescue\nwhere month(rescuedate)='05'\n```\n\nI.e. what date is it 3d after each rescue date\n\n```\nselect (rescuedate + 3 days) from petrescue\n```\n\n- Special registers:\n  - current_date\n  - current_time\n  - i.e. find out how many days have passed since each rescuedate till now. The result will be in YMMDD\n  \n  ```\n  select (current_date - rescuedate) from petrescue\n  ```\n\n\n## Exercise\n\n1. Load hr_data database\n\n```{r}\ndb3 <- dbConnect(RSQLite::SQLite(), \":memory:\")\n```\n\n```{sql, connection=\"db3\"}\n-- Create the PETRESCUE table\ncreate table PETRESCUE (\n        ID INTEGER NOT NULL,\n        ANIMAL VARCHAR(20),\n        QUANTITY INTEGER,\n        COST DECIMAL(6,2),\n        RESCUEDATE DATE,\n        PRIMARY KEY (ID)\n        );\n```\n\n```{sql, connection=\"db3\"}\n-- Insert sample data into PETRESCUE table\ninsert into PETRESCUE values\n        (1,'Cat',9,450.09,'2018-05-29'),\n        (2,'Dog',3,666.66,'2018-06-01'),\n        (3,'Dog',1,100.00,'2018-06-04'),\n        (4,'Parrot',2,50.00,'2018-06-04'),\n        (5,'Dog',1,75.75,'2018-06-10'),\n        (6,'Hamster',6,60.60,'2018-06-11'),\n        (7,'Cat',1,44.44,'2018-06-11'),\n        (8,'Goldfish',24,48.48,'2018-06-14'),\n        (9,'Dog',2,222.22,'2018-06-15')\n\n;\n```\n\n```{sql, connection=\"db3\"}\nselect * from petrescue\n```\n\n2. Enter a function that calculates the total cost of all animal rescues in the PETRESCUE table.\n\n```{sql, connection=\"db3\"}\nselect sum(cost) from petrescue\n```\n\n\n2. Enter a function that displays the total cost of all animal rescues in the PETRESCUE table in a column called SUM_OF_COST.\n\n```{sql, connection=\"db3\"}\nselect sum(cost) as SUM_OF_COST from petrescue\n```\n\n3. Enter a function that displays the maximum quantity of animals rescued.\n\n```{sql, connection=\"db3\"}\nselect max(quantity) from petrescue\n```\n\n4. Enter a function that displays the average cost of animals rescued\n\n```{sql, connection=\"db3\"}\nselect avg(cost) from petrescue\n```\n\n5. Enter a function that displays the average cost of rescuing a dog.\n\n```{sql, connection=\"db3\"}\nselect AVG(COST/QUANTITY) from PETRESCUE\nwhere animal='Dog'\n```\n\n6. Enter a function that displays the rounded cost of each rescue.\n\n```{sql, connection=\"db3\"}\nselect round(cost) from petrescue\n```\n\n6. Enter a function that displays the length of each animal name.\n\n```{sql, connection=\"db3\"}\nselect distinct(animal), length(animal) from petrescue\n```\n\n7. Enter a function that displays the animal name in each rescue in uppercase.\n\n**Notice: ucase becomes upper in SQlite**\n\n```{sql, connection=\"db3\"}\nselect upper(animal) from petrescue\n```\n\n8. Enter a function that displays the animal name in each rescue in uppercase without duplications.\n\n**Notice: ucase becomes upper in SQlite**\n\n```{sql, connection=\"db3\"}\nselect distinct(upper(animal)) from petrescue\n```\n\n9. Enter a query that displays all the columns from the PETRESCUE table, where the animal(s) rescued are cats. Use cat in lower case in the query.\n\n**Notice: lcase becomes lower in SQlite**\n\n```{sql, connection=\"db3\"}\nselect * from petrescue\nwhere lower(animal)='cat'\n```\n\n\n\n10. Enter a function that displays the day of the month when cats have been rescued.\n\n**Notice: SQlite uses a different syntax for finding time**\n\n```\nselect day(rescuedate) from petrescue\nwhere lower(animal)='cat'\n```\n\n```{sql, connection=\"db3\"}\nselect strftime('%d', RESCUEDATE)  from petrescue\nwhere lower(animal)='cat'\n```\n\n\n11. Enter a function that displays the number of rescues on the 5th month.\n**Notice: SQlite uses a different syntax for finding time**\n\n```\nselect sum(quantity) from petrescue\nwhere month(rescuedate)='05'\n```\n\n```{sql, connection=\"db3\"}\nselect sum(quantity) from petrescue\nwhere strftime('%m', RESCUEDATE)='05'\n```\n12. Enter a function that displays the number of rescues on the 14th day of the month.\n\n**Notice: SQlite uses a different syntax for finding time**\n\n```\nselect count(*) from petrescue\nwhere day(rescuedate)='14'\n```\n\n```{sql, connection=\"db3\"}\nselect sum(quantity) from petrescue\nwhere strftime('%d', RESCUEDATE)='14'\n```\n13. Animals rescued should see the vet within three days of arrivals. Enter a function that displays the third day from each rescue.\n\n**Notice: SQlite uses a different syntax for finding time**\n\n```\nselect (rescuedate+3) from petrescue\n```\n\n```{sql, connection=\"db3\"}\nselect id,date(rescuedate, '+3 day') from petrescue\n```\n\n14. Enter a function that displays the length of time the animals have been rescued; the difference between today’s date and the rescue date.\n\n**Notice: SQlite uses a different syntax for finding time**\n\n```\nselect (current_date - rescuedate) from petrescue\n```\n\n```{sql, connection=\"db3\"}\nselect date(rescuedate - 'now' ) from PETRESCUE\n```\n\n# Sub-queries and nested selects\n\n- Sub-query: a query inside a query\n\n```\nselect column1 from table\nwhere column2 = select(max(column2) from table)\n```\n\ni.e. retrieve the list of employees who earn more than the avg salary. For this we can not use `where salary > avg(salary)` since aggregate functions can not always be used in a where clause. However, we can use a sub-select experession\n\n```\nselect emp_id, f_name,salary from employees\nwhere salary <(select avg(salary) from employees)\n```\n\nThe sub-select clause doesn't have to be in the where clause, we can also use it on the list of columns to be selected. **Column expressions** =  substitute column names with a sub-query. I.e. compare the salary of each employee with the average salary\n\n```\nselect emp_id,salary, (select avg(salary) from employees) as avg_salary from employees\n```\n\nWe can also make sub-queries a part of the FROM clause to substitute the table name with a sub-query = **derived tables or table expressions**.  I.e. lets make a derived table with only 3 columns\n\n```\nselect * from (select emp_id, f_name, l_name from employees) as EMP4ALL\n```\n\n# Nested select statement\n\n```\nSELECT column_name [, column_name ]\nFROM table1 [, table2 ]\nWHERE column_name OPERATOR\n   (SELECT column_name [, column_name ]\n   FROM table1 [, table2 ]\n   WHERE condition);\n```\n\n## Examples\n\n```{sql}\nselect * from employees\n```\n\n\n1. Execute a failing query (i.e. one which gives an error) to retrieve all employees records whose salary is lower than the average salary.\n\n```\nselect * from employees\nwhere salary < avg(salary)\n```\n\n2. Execute a working query using a sub-select to retrieve all employees records whose salary is lower than the average salary.\n\n```{sql}\nselect * from employees\nwhere salary <(select avg(salary) from employees)\n```\n\n3. Execute a Column Expression that retrieves all employees records with EMP_ID, SALARY and maximum salary as MAX_SALARY in every row.\n\n```{sql}\nselect emp_id,salary,(select max(salary)from employees) as max_salary from employees\n```\n4. Execute a Table Expression for the EMPLOYEES table that excludes columns with sensitive employee data (i.e. does not include columns: SSN, B_DATE, SEX, ADDRESS, SALARY).\n\n\n```{sql}\nselect * from ( select EMP_ID, F_NAME, L_NAME from employees) AS EMP4ALL;\n```\n\n# Working with multiple tables\n\nWays to access multiple tables in the same query are:\n1. Sub-queries\n2. Implicit join\n3. Join operators, such as inner join, outer join, ...\n\n\n\n## Accessing tables using sub-queries\n\n- I.e. lets only retrieve employee records for which a dep_id exists in the Departments table\n\n```\nselect * from employee\nwhere dep_id in (select dep_id from departments)\n```\n\n\n- I.e. lets only retrieve employees from a specific location via the location id found in the departments table\n\n```\nselect * from employee\nwhere dep_id in (select dep_id from departments where loc_id=\"L0002\")\n```\n\n\n\n- I.e. lets retrieve the dep_id and name for employees who earn more than 70,000 dollars\n\n```\nselect dep_id,dep_name from departments\nwhere dep_id in (select dep_id from employees where salary > 70000)\n```\n\n\n## Accessing tables with an implicit join\n\n- I.e. we can specify two tables in the FROM clause as shown below. This results in a table join without using the join operator. This action below is called a full join, or a cartesian join, because every row in the first table is joined with every row in the 2nd table\n\n```\nselect * from employees,departments\n```\n\n\n- We can use additional operands to limit the results set. I.e. only show rows with matching dep_ids. Below we prefix the name of the column with the name of the table, i.e. we use employees.dep_id. \n\n```\nselect * from employees, department\nwhere employees.dep_id = departments.dep_id\n```\n\n- If the table names are long we also can use aliases. I.e. we can use the alias E for the employee table and then use these aliases in the where clause\n\n```\nselect * from employees E, department D\nwhere E.dep_id = D.dep_id\n```\n\n- lets now see the department name for each employee \n\n```\nselect emp_id, dep_name from employees E, department D\nwhere E.dep_id = D.dep_id\n```\n\n- We can also for the example above fix the column names using aliases\n\n```\nselect e.emp_id, d.dep_name from employees E, department D\nwhere E.dep_id = D.dep_id\n```\n\n## Exercise\n\n1. Retrieve only the EMPLOYEES records that correspond to jobs in the JOBS table.\n\n```{sql}\nselect * from jobs\n```\n\n```{sql}\nselect * from employees\nwhere job_id in (select job_id from jobs)\n```\n2. Retrieve only the list of employees whose JOB_TITLE is Jr. Designer.\n\n```{sql}\nselect * from employees\nwhere job_id in (select job_id from jobs where job_title=\"Jr. Designer\")\n```\n\n\n3. Retrieve JOB information and who earn more than $70,000.\n\n```{sql}\nselect * from jobs\nwhere job_id in (select job_id from employees where salary > 70000)\n```\n\n4. Retrieve JOB information and whose birth year is after 1976.\n\nMysql\n\n```\nselect * from jobs\nwhere job_id in (select job_id from employees where year(b_date)>1976)\n```\n\nSQlite\n\n```{sql}\nselect * from jobs\nwhere job_id in (select job_id from employees where strftime('%Y', employees.b_date) > '1976')\n```\n5. Retrieve JOB information for female employees whose birth year is after 1976.\n\nMysql \n\n```\nselect JOB_TITLE, MIN_SALARY,MAX_SALARY,JOB_IDENT from jobs \nwhere JOB_IDENT IN (select JOB_ID from employees where YEAR(B_DATE)>1976 and SEX='F' );\n```\n\n\nSQlite \n\n```{sql}\nselect JOB_TITLE, min_sal,max_sal,job_id from jobs \nwhere job_id IN (select JOB_ID from employees where strftime('%Y', employees.b_date) < '1961'  and SEX='F' );\n```\n\n6. Perform an implicit cartesian/cross join between EMPLOYEES and JOBS tables.\n\n```{sql}\nselect * from employees,jobs\n```\n\n7. Retrieve only the EMPLOYEES records that correspond to jobs in the JOBS table.\n\n```{sql}\nselect * from employees e,jobs j\nwhere e.job_id = j.job_id\n```\n8. Redo the previous query, but retrieve only the Employee ID, Employee Name and Job Title.\n\n```{sql}\nselect e.emp_id,e.f_name,j.job_title from employees e,jobs j\nwhere e.job_id = j.job_id\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"Week3-Notes.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.168","bibliography":["references.bib"],"space-before-code-block":"10pt","space-after-code-block":"8pt","linespacing":"22pt plus2pt","frontmatter-linespacing":"17pt plus1pt minus1pt","title-size":"22pt","title-size-linespacing":"28pt","gap-before-crest":"25mm","gap-after-crest":"25mm","execute-dir":"file","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"pdflatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","highlight-style":"github","output-file":"Week3-Notes.pdf"},"language":{},"metadata":{"block-headings":true,"bibliography":["references.bib"],"space-before-code-block":"10pt","space-after-code-block":"8pt","linespacing":"22pt plus2pt","frontmatter-linespacing":"17pt plus1pt minus1pt","title-size":"22pt","title-size-linespacing":"28pt","gap-before-crest":"25mm","gap-after-crest":"25mm","execute-dir":"file","documentclass":"scrreprt","geometry":["heightrounded"],"pandoc_args":"--listings","header-includes":["\\usepackage{fvextra} \\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}"],"colorlinks":true,"code-block-bg":"D3D3D3"},"extensions":{"book":{}}}}}